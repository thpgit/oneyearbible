/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/main.ts");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/es6-promise/dist/es6-promise.js":
/*!******************************************************!*\
  !*** ./node_modules/es6-promise/dist/es6-promise.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(process, global) {/*!\n * @overview es6-promise - a tiny implementation of Promises/A+.\n * @copyright Copyright (c) 2014 Yehuda Katz, Tom Dale, Stefan Penner and contributors (Conversion to ES6 API by Jake Archibald)\n * @license   Licensed under MIT license\n *            See https://raw.githubusercontent.com/stefanpenner/es6-promise/master/LICENSE\n * @version   v4.2.8+1e68dce6\n */\n\n(function (global, factory) {\n\t true ? module.exports = factory() :\n\tundefined;\n}(this, (function () { 'use strict';\n\nfunction objectOrFunction(x) {\n  var type = typeof x;\n  return x !== null && (type === 'object' || type === 'function');\n}\n\nfunction isFunction(x) {\n  return typeof x === 'function';\n}\n\n\n\nvar _isArray = void 0;\nif (Array.isArray) {\n  _isArray = Array.isArray;\n} else {\n  _isArray = function (x) {\n    return Object.prototype.toString.call(x) === '[object Array]';\n  };\n}\n\nvar isArray = _isArray;\n\nvar len = 0;\nvar vertxNext = void 0;\nvar customSchedulerFn = void 0;\n\nvar asap = function asap(callback, arg) {\n  queue[len] = callback;\n  queue[len + 1] = arg;\n  len += 2;\n  if (len === 2) {\n    // If len is 2, that means that we need to schedule an async flush.\n    // If additional callbacks are queued before the queue is flushed, they\n    // will be processed by this flush that we are scheduling.\n    if (customSchedulerFn) {\n      customSchedulerFn(flush);\n    } else {\n      scheduleFlush();\n    }\n  }\n};\n\nfunction setScheduler(scheduleFn) {\n  customSchedulerFn = scheduleFn;\n}\n\nfunction setAsap(asapFn) {\n  asap = asapFn;\n}\n\nvar browserWindow = typeof window !== 'undefined' ? window : undefined;\nvar browserGlobal = browserWindow || {};\nvar BrowserMutationObserver = browserGlobal.MutationObserver || browserGlobal.WebKitMutationObserver;\nvar isNode = typeof self === 'undefined' && typeof process !== 'undefined' && {}.toString.call(process) === '[object process]';\n\n// test for web worker but not in IE10\nvar isWorker = typeof Uint8ClampedArray !== 'undefined' && typeof importScripts !== 'undefined' && typeof MessageChannel !== 'undefined';\n\n// node\nfunction useNextTick() {\n  // node version 0.10.x displays a deprecation warning when nextTick is used recursively\n  // see https://github.com/cujojs/when/issues/410 for details\n  return function () {\n    return process.nextTick(flush);\n  };\n}\n\n// vertx\nfunction useVertxTimer() {\n  if (typeof vertxNext !== 'undefined') {\n    return function () {\n      vertxNext(flush);\n    };\n  }\n\n  return useSetTimeout();\n}\n\nfunction useMutationObserver() {\n  var iterations = 0;\n  var observer = new BrowserMutationObserver(flush);\n  var node = document.createTextNode('');\n  observer.observe(node, { characterData: true });\n\n  return function () {\n    node.data = iterations = ++iterations % 2;\n  };\n}\n\n// web worker\nfunction useMessageChannel() {\n  var channel = new MessageChannel();\n  channel.port1.onmessage = flush;\n  return function () {\n    return channel.port2.postMessage(0);\n  };\n}\n\nfunction useSetTimeout() {\n  // Store setTimeout reference so es6-promise will be unaffected by\n  // other code modifying setTimeout (like sinon.useFakeTimers())\n  var globalSetTimeout = setTimeout;\n  return function () {\n    return globalSetTimeout(flush, 1);\n  };\n}\n\nvar queue = new Array(1000);\nfunction flush() {\n  for (var i = 0; i < len; i += 2) {\n    var callback = queue[i];\n    var arg = queue[i + 1];\n\n    callback(arg);\n\n    queue[i] = undefined;\n    queue[i + 1] = undefined;\n  }\n\n  len = 0;\n}\n\nfunction attemptVertx() {\n  try {\n    var vertx = Function('return this')().require('vertx');\n    vertxNext = vertx.runOnLoop || vertx.runOnContext;\n    return useVertxTimer();\n  } catch (e) {\n    return useSetTimeout();\n  }\n}\n\nvar scheduleFlush = void 0;\n// Decide what async method to use to triggering processing of queued callbacks:\nif (isNode) {\n  scheduleFlush = useNextTick();\n} else if (BrowserMutationObserver) {\n  scheduleFlush = useMutationObserver();\n} else if (isWorker) {\n  scheduleFlush = useMessageChannel();\n} else if (browserWindow === undefined && \"function\" === 'function') {\n  scheduleFlush = attemptVertx();\n} else {\n  scheduleFlush = useSetTimeout();\n}\n\nfunction then(onFulfillment, onRejection) {\n  var parent = this;\n\n  var child = new this.constructor(noop);\n\n  if (child[PROMISE_ID] === undefined) {\n    makePromise(child);\n  }\n\n  var _state = parent._state;\n\n\n  if (_state) {\n    var callback = arguments[_state - 1];\n    asap(function () {\n      return invokeCallback(_state, child, callback, parent._result);\n    });\n  } else {\n    subscribe(parent, child, onFulfillment, onRejection);\n  }\n\n  return child;\n}\n\n/**\n  `Promise.resolve` returns a promise that will become resolved with the\n  passed `value`. It is shorthand for the following:\n\n  ```javascript\n  let promise = new Promise(function(resolve, reject){\n    resolve(1);\n  });\n\n  promise.then(function(value){\n    // value === 1\n  });\n  ```\n\n  Instead of writing the above, your code now simply becomes the following:\n\n  ```javascript\n  let promise = Promise.resolve(1);\n\n  promise.then(function(value){\n    // value === 1\n  });\n  ```\n\n  @method resolve\n  @static\n  @param {Any} value value that the returned promise will be resolved with\n  Useful for tooling.\n  @return {Promise} a promise that will become fulfilled with the given\n  `value`\n*/\nfunction resolve$1(object) {\n  /*jshint validthis:true */\n  var Constructor = this;\n\n  if (object && typeof object === 'object' && object.constructor === Constructor) {\n    return object;\n  }\n\n  var promise = new Constructor(noop);\n  resolve(promise, object);\n  return promise;\n}\n\nvar PROMISE_ID = Math.random().toString(36).substring(2);\n\nfunction noop() {}\n\nvar PENDING = void 0;\nvar FULFILLED = 1;\nvar REJECTED = 2;\n\nfunction selfFulfillment() {\n  return new TypeError(\"You cannot resolve a promise with itself\");\n}\n\nfunction cannotReturnOwn() {\n  return new TypeError('A promises callback cannot return that same promise.');\n}\n\nfunction tryThen(then$$1, value, fulfillmentHandler, rejectionHandler) {\n  try {\n    then$$1.call(value, fulfillmentHandler, rejectionHandler);\n  } catch (e) {\n    return e;\n  }\n}\n\nfunction handleForeignThenable(promise, thenable, then$$1) {\n  asap(function (promise) {\n    var sealed = false;\n    var error = tryThen(then$$1, thenable, function (value) {\n      if (sealed) {\n        return;\n      }\n      sealed = true;\n      if (thenable !== value) {\n        resolve(promise, value);\n      } else {\n        fulfill(promise, value);\n      }\n    }, function (reason) {\n      if (sealed) {\n        return;\n      }\n      sealed = true;\n\n      reject(promise, reason);\n    }, 'Settle: ' + (promise._label || ' unknown promise'));\n\n    if (!sealed && error) {\n      sealed = true;\n      reject(promise, error);\n    }\n  }, promise);\n}\n\nfunction handleOwnThenable(promise, thenable) {\n  if (thenable._state === FULFILLED) {\n    fulfill(promise, thenable._result);\n  } else if (thenable._state === REJECTED) {\n    reject(promise, thenable._result);\n  } else {\n    subscribe(thenable, undefined, function (value) {\n      return resolve(promise, value);\n    }, function (reason) {\n      return reject(promise, reason);\n    });\n  }\n}\n\nfunction handleMaybeThenable(promise, maybeThenable, then$$1) {\n  if (maybeThenable.constructor === promise.constructor && then$$1 === then && maybeThenable.constructor.resolve === resolve$1) {\n    handleOwnThenable(promise, maybeThenable);\n  } else {\n    if (then$$1 === undefined) {\n      fulfill(promise, maybeThenable);\n    } else if (isFunction(then$$1)) {\n      handleForeignThenable(promise, maybeThenable, then$$1);\n    } else {\n      fulfill(promise, maybeThenable);\n    }\n  }\n}\n\nfunction resolve(promise, value) {\n  if (promise === value) {\n    reject(promise, selfFulfillment());\n  } else if (objectOrFunction(value)) {\n    var then$$1 = void 0;\n    try {\n      then$$1 = value.then;\n    } catch (error) {\n      reject(promise, error);\n      return;\n    }\n    handleMaybeThenable(promise, value, then$$1);\n  } else {\n    fulfill(promise, value);\n  }\n}\n\nfunction publishRejection(promise) {\n  if (promise._onerror) {\n    promise._onerror(promise._result);\n  }\n\n  publish(promise);\n}\n\nfunction fulfill(promise, value) {\n  if (promise._state !== PENDING) {\n    return;\n  }\n\n  promise._result = value;\n  promise._state = FULFILLED;\n\n  if (promise._subscribers.length !== 0) {\n    asap(publish, promise);\n  }\n}\n\nfunction reject(promise, reason) {\n  if (promise._state !== PENDING) {\n    return;\n  }\n  promise._state = REJECTED;\n  promise._result = reason;\n\n  asap(publishRejection, promise);\n}\n\nfunction subscribe(parent, child, onFulfillment, onRejection) {\n  var _subscribers = parent._subscribers;\n  var length = _subscribers.length;\n\n\n  parent._onerror = null;\n\n  _subscribers[length] = child;\n  _subscribers[length + FULFILLED] = onFulfillment;\n  _subscribers[length + REJECTED] = onRejection;\n\n  if (length === 0 && parent._state) {\n    asap(publish, parent);\n  }\n}\n\nfunction publish(promise) {\n  var subscribers = promise._subscribers;\n  var settled = promise._state;\n\n  if (subscribers.length === 0) {\n    return;\n  }\n\n  var child = void 0,\n      callback = void 0,\n      detail = promise._result;\n\n  for (var i = 0; i < subscribers.length; i += 3) {\n    child = subscribers[i];\n    callback = subscribers[i + settled];\n\n    if (child) {\n      invokeCallback(settled, child, callback, detail);\n    } else {\n      callback(detail);\n    }\n  }\n\n  promise._subscribers.length = 0;\n}\n\nfunction invokeCallback(settled, promise, callback, detail) {\n  var hasCallback = isFunction(callback),\n      value = void 0,\n      error = void 0,\n      succeeded = true;\n\n  if (hasCallback) {\n    try {\n      value = callback(detail);\n    } catch (e) {\n      succeeded = false;\n      error = e;\n    }\n\n    if (promise === value) {\n      reject(promise, cannotReturnOwn());\n      return;\n    }\n  } else {\n    value = detail;\n  }\n\n  if (promise._state !== PENDING) {\n    // noop\n  } else if (hasCallback && succeeded) {\n    resolve(promise, value);\n  } else if (succeeded === false) {\n    reject(promise, error);\n  } else if (settled === FULFILLED) {\n    fulfill(promise, value);\n  } else if (settled === REJECTED) {\n    reject(promise, value);\n  }\n}\n\nfunction initializePromise(promise, resolver) {\n  try {\n    resolver(function resolvePromise(value) {\n      resolve(promise, value);\n    }, function rejectPromise(reason) {\n      reject(promise, reason);\n    });\n  } catch (e) {\n    reject(promise, e);\n  }\n}\n\nvar id = 0;\nfunction nextId() {\n  return id++;\n}\n\nfunction makePromise(promise) {\n  promise[PROMISE_ID] = id++;\n  promise._state = undefined;\n  promise._result = undefined;\n  promise._subscribers = [];\n}\n\nfunction validationError() {\n  return new Error('Array Methods must be provided an Array');\n}\n\nvar Enumerator = function () {\n  function Enumerator(Constructor, input) {\n    this._instanceConstructor = Constructor;\n    this.promise = new Constructor(noop);\n\n    if (!this.promise[PROMISE_ID]) {\n      makePromise(this.promise);\n    }\n\n    if (isArray(input)) {\n      this.length = input.length;\n      this._remaining = input.length;\n\n      this._result = new Array(this.length);\n\n      if (this.length === 0) {\n        fulfill(this.promise, this._result);\n      } else {\n        this.length = this.length || 0;\n        this._enumerate(input);\n        if (this._remaining === 0) {\n          fulfill(this.promise, this._result);\n        }\n      }\n    } else {\n      reject(this.promise, validationError());\n    }\n  }\n\n  Enumerator.prototype._enumerate = function _enumerate(input) {\n    for (var i = 0; this._state === PENDING && i < input.length; i++) {\n      this._eachEntry(input[i], i);\n    }\n  };\n\n  Enumerator.prototype._eachEntry = function _eachEntry(entry, i) {\n    var c = this._instanceConstructor;\n    var resolve$$1 = c.resolve;\n\n\n    if (resolve$$1 === resolve$1) {\n      var _then = void 0;\n      var error = void 0;\n      var didError = false;\n      try {\n        _then = entry.then;\n      } catch (e) {\n        didError = true;\n        error = e;\n      }\n\n      if (_then === then && entry._state !== PENDING) {\n        this._settledAt(entry._state, i, entry._result);\n      } else if (typeof _then !== 'function') {\n        this._remaining--;\n        this._result[i] = entry;\n      } else if (c === Promise$1) {\n        var promise = new c(noop);\n        if (didError) {\n          reject(promise, error);\n        } else {\n          handleMaybeThenable(promise, entry, _then);\n        }\n        this._willSettleAt(promise, i);\n      } else {\n        this._willSettleAt(new c(function (resolve$$1) {\n          return resolve$$1(entry);\n        }), i);\n      }\n    } else {\n      this._willSettleAt(resolve$$1(entry), i);\n    }\n  };\n\n  Enumerator.prototype._settledAt = function _settledAt(state, i, value) {\n    var promise = this.promise;\n\n\n    if (promise._state === PENDING) {\n      this._remaining--;\n\n      if (state === REJECTED) {\n        reject(promise, value);\n      } else {\n        this._result[i] = value;\n      }\n    }\n\n    if (this._remaining === 0) {\n      fulfill(promise, this._result);\n    }\n  };\n\n  Enumerator.prototype._willSettleAt = function _willSettleAt(promise, i) {\n    var enumerator = this;\n\n    subscribe(promise, undefined, function (value) {\n      return enumerator._settledAt(FULFILLED, i, value);\n    }, function (reason) {\n      return enumerator._settledAt(REJECTED, i, reason);\n    });\n  };\n\n  return Enumerator;\n}();\n\n/**\n  `Promise.all` accepts an array of promises, and returns a new promise which\n  is fulfilled with an array of fulfillment values for the passed promises, or\n  rejected with the reason of the first passed promise to be rejected. It casts all\n  elements of the passed iterable to promises as it runs this algorithm.\n\n  Example:\n\n  ```javascript\n  let promise1 = resolve(1);\n  let promise2 = resolve(2);\n  let promise3 = resolve(3);\n  let promises = [ promise1, promise2, promise3 ];\n\n  Promise.all(promises).then(function(array){\n    // The array here would be [ 1, 2, 3 ];\n  });\n  ```\n\n  If any of the `promises` given to `all` are rejected, the first promise\n  that is rejected will be given as an argument to the returned promises's\n  rejection handler. For example:\n\n  Example:\n\n  ```javascript\n  let promise1 = resolve(1);\n  let promise2 = reject(new Error(\"2\"));\n  let promise3 = reject(new Error(\"3\"));\n  let promises = [ promise1, promise2, promise3 ];\n\n  Promise.all(promises).then(function(array){\n    // Code here never runs because there are rejected promises!\n  }, function(error) {\n    // error.message === \"2\"\n  });\n  ```\n\n  @method all\n  @static\n  @param {Array} entries array of promises\n  @param {String} label optional string for labeling the promise.\n  Useful for tooling.\n  @return {Promise} promise that is fulfilled when all `promises` have been\n  fulfilled, or rejected if any of them become rejected.\n  @static\n*/\nfunction all(entries) {\n  return new Enumerator(this, entries).promise;\n}\n\n/**\n  `Promise.race` returns a new promise which is settled in the same way as the\n  first passed promise to settle.\n\n  Example:\n\n  ```javascript\n  let promise1 = new Promise(function(resolve, reject){\n    setTimeout(function(){\n      resolve('promise 1');\n    }, 200);\n  });\n\n  let promise2 = new Promise(function(resolve, reject){\n    setTimeout(function(){\n      resolve('promise 2');\n    }, 100);\n  });\n\n  Promise.race([promise1, promise2]).then(function(result){\n    // result === 'promise 2' because it was resolved before promise1\n    // was resolved.\n  });\n  ```\n\n  `Promise.race` is deterministic in that only the state of the first\n  settled promise matters. For example, even if other promises given to the\n  `promises` array argument are resolved, but the first settled promise has\n  become rejected before the other promises became fulfilled, the returned\n  promise will become rejected:\n\n  ```javascript\n  let promise1 = new Promise(function(resolve, reject){\n    setTimeout(function(){\n      resolve('promise 1');\n    }, 200);\n  });\n\n  let promise2 = new Promise(function(resolve, reject){\n    setTimeout(function(){\n      reject(new Error('promise 2'));\n    }, 100);\n  });\n\n  Promise.race([promise1, promise2]).then(function(result){\n    // Code here never runs\n  }, function(reason){\n    // reason.message === 'promise 2' because promise 2 became rejected before\n    // promise 1 became fulfilled\n  });\n  ```\n\n  An example real-world use case is implementing timeouts:\n\n  ```javascript\n  Promise.race([ajax('foo.json'), timeout(5000)])\n  ```\n\n  @method race\n  @static\n  @param {Array} promises array of promises to observe\n  Useful for tooling.\n  @return {Promise} a promise which settles in the same way as the first passed\n  promise to settle.\n*/\nfunction race(entries) {\n  /*jshint validthis:true */\n  var Constructor = this;\n\n  if (!isArray(entries)) {\n    return new Constructor(function (_, reject) {\n      return reject(new TypeError('You must pass an array to race.'));\n    });\n  } else {\n    return new Constructor(function (resolve, reject) {\n      var length = entries.length;\n      for (var i = 0; i < length; i++) {\n        Constructor.resolve(entries[i]).then(resolve, reject);\n      }\n    });\n  }\n}\n\n/**\n  `Promise.reject` returns a promise rejected with the passed `reason`.\n  It is shorthand for the following:\n\n  ```javascript\n  let promise = new Promise(function(resolve, reject){\n    reject(new Error('WHOOPS'));\n  });\n\n  promise.then(function(value){\n    // Code here doesn't run because the promise is rejected!\n  }, function(reason){\n    // reason.message === 'WHOOPS'\n  });\n  ```\n\n  Instead of writing the above, your code now simply becomes the following:\n\n  ```javascript\n  let promise = Promise.reject(new Error('WHOOPS'));\n\n  promise.then(function(value){\n    // Code here doesn't run because the promise is rejected!\n  }, function(reason){\n    // reason.message === 'WHOOPS'\n  });\n  ```\n\n  @method reject\n  @static\n  @param {Any} reason value that the returned promise will be rejected with.\n  Useful for tooling.\n  @return {Promise} a promise rejected with the given `reason`.\n*/\nfunction reject$1(reason) {\n  /*jshint validthis:true */\n  var Constructor = this;\n  var promise = new Constructor(noop);\n  reject(promise, reason);\n  return promise;\n}\n\nfunction needsResolver() {\n  throw new TypeError('You must pass a resolver function as the first argument to the promise constructor');\n}\n\nfunction needsNew() {\n  throw new TypeError(\"Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.\");\n}\n\n/**\n  Promise objects represent the eventual result of an asynchronous operation. The\n  primary way of interacting with a promise is through its `then` method, which\n  registers callbacks to receive either a promise's eventual value or the reason\n  why the promise cannot be fulfilled.\n\n  Terminology\n  -----------\n\n  - `promise` is an object or function with a `then` method whose behavior conforms to this specification.\n  - `thenable` is an object or function that defines a `then` method.\n  - `value` is any legal JavaScript value (including undefined, a thenable, or a promise).\n  - `exception` is a value that is thrown using the throw statement.\n  - `reason` is a value that indicates why a promise was rejected.\n  - `settled` the final resting state of a promise, fulfilled or rejected.\n\n  A promise can be in one of three states: pending, fulfilled, or rejected.\n\n  Promises that are fulfilled have a fulfillment value and are in the fulfilled\n  state.  Promises that are rejected have a rejection reason and are in the\n  rejected state.  A fulfillment value is never a thenable.\n\n  Promises can also be said to *resolve* a value.  If this value is also a\n  promise, then the original promise's settled state will match the value's\n  settled state.  So a promise that *resolves* a promise that rejects will\n  itself reject, and a promise that *resolves* a promise that fulfills will\n  itself fulfill.\n\n\n  Basic Usage:\n  ------------\n\n  ```js\n  let promise = new Promise(function(resolve, reject) {\n    // on success\n    resolve(value);\n\n    // on failure\n    reject(reason);\n  });\n\n  promise.then(function(value) {\n    // on fulfillment\n  }, function(reason) {\n    // on rejection\n  });\n  ```\n\n  Advanced Usage:\n  ---------------\n\n  Promises shine when abstracting away asynchronous interactions such as\n  `XMLHttpRequest`s.\n\n  ```js\n  function getJSON(url) {\n    return new Promise(function(resolve, reject){\n      let xhr = new XMLHttpRequest();\n\n      xhr.open('GET', url);\n      xhr.onreadystatechange = handler;\n      xhr.responseType = 'json';\n      xhr.setRequestHeader('Accept', 'application/json');\n      xhr.send();\n\n      function handler() {\n        if (this.readyState === this.DONE) {\n          if (this.status === 200) {\n            resolve(this.response);\n          } else {\n            reject(new Error('getJSON: `' + url + '` failed with status: [' + this.status + ']'));\n          }\n        }\n      };\n    });\n  }\n\n  getJSON('/posts.json').then(function(json) {\n    // on fulfillment\n  }, function(reason) {\n    // on rejection\n  });\n  ```\n\n  Unlike callbacks, promises are great composable primitives.\n\n  ```js\n  Promise.all([\n    getJSON('/posts'),\n    getJSON('/comments')\n  ]).then(function(values){\n    values[0] // => postsJSON\n    values[1] // => commentsJSON\n\n    return values;\n  });\n  ```\n\n  @class Promise\n  @param {Function} resolver\n  Useful for tooling.\n  @constructor\n*/\n\nvar Promise$1 = function () {\n  function Promise(resolver) {\n    this[PROMISE_ID] = nextId();\n    this._result = this._state = undefined;\n    this._subscribers = [];\n\n    if (noop !== resolver) {\n      typeof resolver !== 'function' && needsResolver();\n      this instanceof Promise ? initializePromise(this, resolver) : needsNew();\n    }\n  }\n\n  /**\n  The primary way of interacting with a promise is through its `then` method,\n  which registers callbacks to receive either a promise's eventual value or the\n  reason why the promise cannot be fulfilled.\n   ```js\n  findUser().then(function(user){\n    // user is available\n  }, function(reason){\n    // user is unavailable, and you are given the reason why\n  });\n  ```\n   Chaining\n  --------\n   The return value of `then` is itself a promise.  This second, 'downstream'\n  promise is resolved with the return value of the first promise's fulfillment\n  or rejection handler, or rejected if the handler throws an exception.\n   ```js\n  findUser().then(function (user) {\n    return user.name;\n  }, function (reason) {\n    return 'default name';\n  }).then(function (userName) {\n    // If `findUser` fulfilled, `userName` will be the user's name, otherwise it\n    // will be `'default name'`\n  });\n   findUser().then(function (user) {\n    throw new Error('Found user, but still unhappy');\n  }, function (reason) {\n    throw new Error('`findUser` rejected and we're unhappy');\n  }).then(function (value) {\n    // never reached\n  }, function (reason) {\n    // if `findUser` fulfilled, `reason` will be 'Found user, but still unhappy'.\n    // If `findUser` rejected, `reason` will be '`findUser` rejected and we're unhappy'.\n  });\n  ```\n  If the downstream promise does not specify a rejection handler, rejection reasons will be propagated further downstream.\n   ```js\n  findUser().then(function (user) {\n    throw new PedagogicalException('Upstream error');\n  }).then(function (value) {\n    // never reached\n  }).then(function (value) {\n    // never reached\n  }, function (reason) {\n    // The `PedgagocialException` is propagated all the way down to here\n  });\n  ```\n   Assimilation\n  ------------\n   Sometimes the value you want to propagate to a downstream promise can only be\n  retrieved asynchronously. This can be achieved by returning a promise in the\n  fulfillment or rejection handler. The downstream promise will then be pending\n  until the returned promise is settled. This is called *assimilation*.\n   ```js\n  findUser().then(function (user) {\n    return findCommentsByAuthor(user);\n  }).then(function (comments) {\n    // The user's comments are now available\n  });\n  ```\n   If the assimliated promise rejects, then the downstream promise will also reject.\n   ```js\n  findUser().then(function (user) {\n    return findCommentsByAuthor(user);\n  }).then(function (comments) {\n    // If `findCommentsByAuthor` fulfills, we'll have the value here\n  }, function (reason) {\n    // If `findCommentsByAuthor` rejects, we'll have the reason here\n  });\n  ```\n   Simple Example\n  --------------\n   Synchronous Example\n   ```javascript\n  let result;\n   try {\n    result = findResult();\n    // success\n  } catch(reason) {\n    // failure\n  }\n  ```\n   Errback Example\n   ```js\n  findResult(function(result, err){\n    if (err) {\n      // failure\n    } else {\n      // success\n    }\n  });\n  ```\n   Promise Example;\n   ```javascript\n  findResult().then(function(result){\n    // success\n  }, function(reason){\n    // failure\n  });\n  ```\n   Advanced Example\n  --------------\n   Synchronous Example\n   ```javascript\n  let author, books;\n   try {\n    author = findAuthor();\n    books  = findBooksByAuthor(author);\n    // success\n  } catch(reason) {\n    // failure\n  }\n  ```\n   Errback Example\n   ```js\n   function foundBooks(books) {\n   }\n   function failure(reason) {\n   }\n   findAuthor(function(author, err){\n    if (err) {\n      failure(err);\n      // failure\n    } else {\n      try {\n        findBoooksByAuthor(author, function(books, err) {\n          if (err) {\n            failure(err);\n          } else {\n            try {\n              foundBooks(books);\n            } catch(reason) {\n              failure(reason);\n            }\n          }\n        });\n      } catch(error) {\n        failure(err);\n      }\n      // success\n    }\n  });\n  ```\n   Promise Example;\n   ```javascript\n  findAuthor().\n    then(findBooksByAuthor).\n    then(function(books){\n      // found books\n  }).catch(function(reason){\n    // something went wrong\n  });\n  ```\n   @method then\n  @param {Function} onFulfilled\n  @param {Function} onRejected\n  Useful for tooling.\n  @return {Promise}\n  */\n\n  /**\n  `catch` is simply sugar for `then(undefined, onRejection)` which makes it the same\n  as the catch block of a try/catch statement.\n  ```js\n  function findAuthor(){\n  throw new Error('couldn't find that author');\n  }\n  // synchronous\n  try {\n  findAuthor();\n  } catch(reason) {\n  // something went wrong\n  }\n  // async with promises\n  findAuthor().catch(function(reason){\n  // something went wrong\n  });\n  ```\n  @method catch\n  @param {Function} onRejection\n  Useful for tooling.\n  @return {Promise}\n  */\n\n\n  Promise.prototype.catch = function _catch(onRejection) {\n    return this.then(null, onRejection);\n  };\n\n  /**\n    `finally` will be invoked regardless of the promise's fate just as native\n    try/catch/finally behaves\n  \n    Synchronous example:\n  \n    ```js\n    findAuthor() {\n      if (Math.random() > 0.5) {\n        throw new Error();\n      }\n      return new Author();\n    }\n  \n    try {\n      return findAuthor(); // succeed or fail\n    } catch(error) {\n      return findOtherAuther();\n    } finally {\n      // always runs\n      // doesn't affect the return value\n    }\n    ```\n  \n    Asynchronous example:\n  \n    ```js\n    findAuthor().catch(function(reason){\n      return findOtherAuther();\n    }).finally(function(){\n      // author was either found, or not\n    });\n    ```\n  \n    @method finally\n    @param {Function} callback\n    @return {Promise}\n  */\n\n\n  Promise.prototype.finally = function _finally(callback) {\n    var promise = this;\n    var constructor = promise.constructor;\n\n    if (isFunction(callback)) {\n      return promise.then(function (value) {\n        return constructor.resolve(callback()).then(function () {\n          return value;\n        });\n      }, function (reason) {\n        return constructor.resolve(callback()).then(function () {\n          throw reason;\n        });\n      });\n    }\n\n    return promise.then(callback, callback);\n  };\n\n  return Promise;\n}();\n\nPromise$1.prototype.then = then;\nPromise$1.all = all;\nPromise$1.race = race;\nPromise$1.resolve = resolve$1;\nPromise$1.reject = reject$1;\nPromise$1._setScheduler = setScheduler;\nPromise$1._setAsap = setAsap;\nPromise$1._asap = asap;\n\n/*global self*/\nfunction polyfill() {\n  var local = void 0;\n\n  if (typeof global !== 'undefined') {\n    local = global;\n  } else if (typeof self !== 'undefined') {\n    local = self;\n  } else {\n    try {\n      local = Function('return this')();\n    } catch (e) {\n      throw new Error('polyfill failed because global object is unavailable in this environment');\n    }\n  }\n\n  var P = local.Promise;\n\n  if (P) {\n    var promiseToString = null;\n    try {\n      promiseToString = Object.prototype.toString.call(P.resolve());\n    } catch (e) {\n      // silently ignored\n    }\n\n    if (promiseToString === '[object Promise]' && !P.cast) {\n      return;\n    }\n  }\n\n  local.Promise = Promise$1;\n}\n\n// Strange compat..\nPromise$1.polyfill = polyfill;\nPromise$1.Promise = Promise$1;\n\nreturn Promise$1;\n\n})));\n\n\n\n//# sourceMappingURL=es6-promise.map\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../process/browser.js */ \"./node_modules/process/browser.js\"), __webpack_require__(/*! ./../../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZXM2LXByb21pc2UvZGlzdC9lczYtcHJvbWlzZS5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lczYtcHJvbWlzZS9kaXN0L2VzNi1wcm9taXNlLmpzPzEzNjgiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBAb3ZlcnZpZXcgZXM2LXByb21pc2UgLSBhIHRpbnkgaW1wbGVtZW50YXRpb24gb2YgUHJvbWlzZXMvQSsuXG4gKiBAY29weXJpZ2h0IENvcHlyaWdodCAoYykgMjAxNCBZZWh1ZGEgS2F0eiwgVG9tIERhbGUsIFN0ZWZhbiBQZW5uZXIgYW5kIGNvbnRyaWJ1dG9ycyAoQ29udmVyc2lvbiB0byBFUzYgQVBJIGJ5IEpha2UgQXJjaGliYWxkKVxuICogQGxpY2Vuc2UgICBMaWNlbnNlZCB1bmRlciBNSVQgbGljZW5zZVxuICogICAgICAgICAgICBTZWUgaHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL3N0ZWZhbnBlbm5lci9lczYtcHJvbWlzZS9tYXN0ZXIvTElDRU5TRVxuICogQHZlcnNpb24gICB2NC4yLjgrMWU2OGRjZTZcbiAqL1xuXG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuXHR0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKSA6XG5cdHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShmYWN0b3J5KSA6XG5cdChnbG9iYWwuRVM2UHJvbWlzZSA9IGZhY3RvcnkoKSk7XG59KHRoaXMsIChmdW5jdGlvbiAoKSB7ICd1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gb2JqZWN0T3JGdW5jdGlvbih4KSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIHg7XG4gIHJldHVybiB4ICE9PSBudWxsICYmICh0eXBlID09PSAnb2JqZWN0JyB8fCB0eXBlID09PSAnZnVuY3Rpb24nKTtcbn1cblxuZnVuY3Rpb24gaXNGdW5jdGlvbih4KSB7XG4gIHJldHVybiB0eXBlb2YgeCA9PT0gJ2Z1bmN0aW9uJztcbn1cblxuXG5cbnZhciBfaXNBcnJheSA9IHZvaWQgMDtcbmlmIChBcnJheS5pc0FycmF5KSB7XG4gIF9pc0FycmF5ID0gQXJyYXkuaXNBcnJheTtcbn0gZWxzZSB7XG4gIF9pc0FycmF5ID0gZnVuY3Rpb24gKHgpIHtcbiAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHgpID09PSAnW29iamVjdCBBcnJheV0nO1xuICB9O1xufVxuXG52YXIgaXNBcnJheSA9IF9pc0FycmF5O1xuXG52YXIgbGVuID0gMDtcbnZhciB2ZXJ0eE5leHQgPSB2b2lkIDA7XG52YXIgY3VzdG9tU2NoZWR1bGVyRm4gPSB2b2lkIDA7XG5cbnZhciBhc2FwID0gZnVuY3Rpb24gYXNhcChjYWxsYmFjaywgYXJnKSB7XG4gIHF1ZXVlW2xlbl0gPSBjYWxsYmFjaztcbiAgcXVldWVbbGVuICsgMV0gPSBhcmc7XG4gIGxlbiArPSAyO1xuICBpZiAobGVuID09PSAyKSB7XG4gICAgLy8gSWYgbGVuIGlzIDIsIHRoYXQgbWVhbnMgdGhhdCB3ZSBuZWVkIHRvIHNjaGVkdWxlIGFuIGFzeW5jIGZsdXNoLlxuICAgIC8vIElmIGFkZGl0aW9uYWwgY2FsbGJhY2tzIGFyZSBxdWV1ZWQgYmVmb3JlIHRoZSBxdWV1ZSBpcyBmbHVzaGVkLCB0aGV5XG4gICAgLy8gd2lsbCBiZSBwcm9jZXNzZWQgYnkgdGhpcyBmbHVzaCB0aGF0IHdlIGFyZSBzY2hlZHVsaW5nLlxuICAgIGlmIChjdXN0b21TY2hlZHVsZXJGbikge1xuICAgICAgY3VzdG9tU2NoZWR1bGVyRm4oZmx1c2gpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzY2hlZHVsZUZsdXNoKCk7XG4gICAgfVxuICB9XG59O1xuXG5mdW5jdGlvbiBzZXRTY2hlZHVsZXIoc2NoZWR1bGVGbikge1xuICBjdXN0b21TY2hlZHVsZXJGbiA9IHNjaGVkdWxlRm47XG59XG5cbmZ1bmN0aW9uIHNldEFzYXAoYXNhcEZuKSB7XG4gIGFzYXAgPSBhc2FwRm47XG59XG5cbnZhciBicm93c2VyV2luZG93ID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cgOiB1bmRlZmluZWQ7XG52YXIgYnJvd3Nlckdsb2JhbCA9IGJyb3dzZXJXaW5kb3cgfHwge307XG52YXIgQnJvd3Nlck11dGF0aW9uT2JzZXJ2ZXIgPSBicm93c2VyR2xvYmFsLk11dGF0aW9uT2JzZXJ2ZXIgfHwgYnJvd3Nlckdsb2JhbC5XZWJLaXRNdXRhdGlvbk9ic2VydmVyO1xudmFyIGlzTm9kZSA9IHR5cGVvZiBzZWxmID09PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiYge30udG9TdHJpbmcuY2FsbChwcm9jZXNzKSA9PT0gJ1tvYmplY3QgcHJvY2Vzc10nO1xuXG4vLyB0ZXN0IGZvciB3ZWIgd29ya2VyIGJ1dCBub3QgaW4gSUUxMFxudmFyIGlzV29ya2VyID0gdHlwZW9mIFVpbnQ4Q2xhbXBlZEFycmF5ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgaW1wb3J0U2NyaXB0cyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIE1lc3NhZ2VDaGFubmVsICE9PSAndW5kZWZpbmVkJztcblxuLy8gbm9kZVxuZnVuY3Rpb24gdXNlTmV4dFRpY2soKSB7XG4gIC8vIG5vZGUgdmVyc2lvbiAwLjEwLnggZGlzcGxheXMgYSBkZXByZWNhdGlvbiB3YXJuaW5nIHdoZW4gbmV4dFRpY2sgaXMgdXNlZCByZWN1cnNpdmVseVxuICAvLyBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2N1am9qcy93aGVuL2lzc3Vlcy80MTAgZm9yIGRldGFpbHNcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gcHJvY2Vzcy5uZXh0VGljayhmbHVzaCk7XG4gIH07XG59XG5cbi8vIHZlcnR4XG5mdW5jdGlvbiB1c2VWZXJ0eFRpbWVyKCkge1xuICBpZiAodHlwZW9mIHZlcnR4TmV4dCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgdmVydHhOZXh0KGZsdXNoKTtcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIHVzZVNldFRpbWVvdXQoKTtcbn1cblxuZnVuY3Rpb24gdXNlTXV0YXRpb25PYnNlcnZlcigpIHtcbiAgdmFyIGl0ZXJhdGlvbnMgPSAwO1xuICB2YXIgb2JzZXJ2ZXIgPSBuZXcgQnJvd3Nlck11dGF0aW9uT2JzZXJ2ZXIoZmx1c2gpO1xuICB2YXIgbm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcnKTtcbiAgb2JzZXJ2ZXIub2JzZXJ2ZShub2RlLCB7IGNoYXJhY3RlckRhdGE6IHRydWUgfSk7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICBub2RlLmRhdGEgPSBpdGVyYXRpb25zID0gKytpdGVyYXRpb25zICUgMjtcbiAgfTtcbn1cblxuLy8gd2ViIHdvcmtlclxuZnVuY3Rpb24gdXNlTWVzc2FnZUNoYW5uZWwoKSB7XG4gIHZhciBjaGFubmVsID0gbmV3IE1lc3NhZ2VDaGFubmVsKCk7XG4gIGNoYW5uZWwucG9ydDEub25tZXNzYWdlID0gZmx1c2g7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGNoYW5uZWwucG9ydDIucG9zdE1lc3NhZ2UoMCk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHVzZVNldFRpbWVvdXQoKSB7XG4gIC8vIFN0b3JlIHNldFRpbWVvdXQgcmVmZXJlbmNlIHNvIGVzNi1wcm9taXNlIHdpbGwgYmUgdW5hZmZlY3RlZCBieVxuICAvLyBvdGhlciBjb2RlIG1vZGlmeWluZyBzZXRUaW1lb3V0IChsaWtlIHNpbm9uLnVzZUZha2VUaW1lcnMoKSlcbiAgdmFyIGdsb2JhbFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBnbG9iYWxTZXRUaW1lb3V0KGZsdXNoLCAxKTtcbiAgfTtcbn1cblxudmFyIHF1ZXVlID0gbmV3IEFycmF5KDEwMDApO1xuZnVuY3Rpb24gZmx1c2goKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDIpIHtcbiAgICB2YXIgY2FsbGJhY2sgPSBxdWV1ZVtpXTtcbiAgICB2YXIgYXJnID0gcXVldWVbaSArIDFdO1xuXG4gICAgY2FsbGJhY2soYXJnKTtcblxuICAgIHF1ZXVlW2ldID0gdW5kZWZpbmVkO1xuICAgIHF1ZXVlW2kgKyAxXSA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIGxlbiA9IDA7XG59XG5cbmZ1bmN0aW9uIGF0dGVtcHRWZXJ0eCgpIHtcbiAgdHJ5IHtcbiAgICB2YXIgdmVydHggPSBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpLnJlcXVpcmUoJ3ZlcnR4Jyk7XG4gICAgdmVydHhOZXh0ID0gdmVydHgucnVuT25Mb29wIHx8IHZlcnR4LnJ1bk9uQ29udGV4dDtcbiAgICByZXR1cm4gdXNlVmVydHhUaW1lcigpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIHVzZVNldFRpbWVvdXQoKTtcbiAgfVxufVxuXG52YXIgc2NoZWR1bGVGbHVzaCA9IHZvaWQgMDtcbi8vIERlY2lkZSB3aGF0IGFzeW5jIG1ldGhvZCB0byB1c2UgdG8gdHJpZ2dlcmluZyBwcm9jZXNzaW5nIG9mIHF1ZXVlZCBjYWxsYmFja3M6XG5pZiAoaXNOb2RlKSB7XG4gIHNjaGVkdWxlRmx1c2ggPSB1c2VOZXh0VGljaygpO1xufSBlbHNlIGlmIChCcm93c2VyTXV0YXRpb25PYnNlcnZlcikge1xuICBzY2hlZHVsZUZsdXNoID0gdXNlTXV0YXRpb25PYnNlcnZlcigpO1xufSBlbHNlIGlmIChpc1dvcmtlcikge1xuICBzY2hlZHVsZUZsdXNoID0gdXNlTWVzc2FnZUNoYW5uZWwoKTtcbn0gZWxzZSBpZiAoYnJvd3NlcldpbmRvdyA9PT0gdW5kZWZpbmVkICYmIHR5cGVvZiByZXF1aXJlID09PSAnZnVuY3Rpb24nKSB7XG4gIHNjaGVkdWxlRmx1c2ggPSBhdHRlbXB0VmVydHgoKTtcbn0gZWxzZSB7XG4gIHNjaGVkdWxlRmx1c2ggPSB1c2VTZXRUaW1lb3V0KCk7XG59XG5cbmZ1bmN0aW9uIHRoZW4ob25GdWxmaWxsbWVudCwgb25SZWplY3Rpb24pIHtcbiAgdmFyIHBhcmVudCA9IHRoaXM7XG5cbiAgdmFyIGNoaWxkID0gbmV3IHRoaXMuY29uc3RydWN0b3Iobm9vcCk7XG5cbiAgaWYgKGNoaWxkW1BST01JU0VfSURdID09PSB1bmRlZmluZWQpIHtcbiAgICBtYWtlUHJvbWlzZShjaGlsZCk7XG4gIH1cblxuICB2YXIgX3N0YXRlID0gcGFyZW50Ll9zdGF0ZTtcblxuXG4gIGlmIChfc3RhdGUpIHtcbiAgICB2YXIgY2FsbGJhY2sgPSBhcmd1bWVudHNbX3N0YXRlIC0gMV07XG4gICAgYXNhcChmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gaW52b2tlQ2FsbGJhY2soX3N0YXRlLCBjaGlsZCwgY2FsbGJhY2ssIHBhcmVudC5fcmVzdWx0KTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBzdWJzY3JpYmUocGFyZW50LCBjaGlsZCwgb25GdWxmaWxsbWVudCwgb25SZWplY3Rpb24pO1xuICB9XG5cbiAgcmV0dXJuIGNoaWxkO1xufVxuXG4vKipcbiAgYFByb21pc2UucmVzb2x2ZWAgcmV0dXJucyBhIHByb21pc2UgdGhhdCB3aWxsIGJlY29tZSByZXNvbHZlZCB3aXRoIHRoZVxuICBwYXNzZWQgYHZhbHVlYC4gSXQgaXMgc2hvcnRoYW5kIGZvciB0aGUgZm9sbG93aW5nOlxuXG4gIGBgYGphdmFzY3JpcHRcbiAgbGV0IHByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3Qpe1xuICAgIHJlc29sdmUoMSk7XG4gIH0pO1xuXG4gIHByb21pc2UudGhlbihmdW5jdGlvbih2YWx1ZSl7XG4gICAgLy8gdmFsdWUgPT09IDFcbiAgfSk7XG4gIGBgYFxuXG4gIEluc3RlYWQgb2Ygd3JpdGluZyB0aGUgYWJvdmUsIHlvdXIgY29kZSBub3cgc2ltcGx5IGJlY29tZXMgdGhlIGZvbGxvd2luZzpcblxuICBgYGBqYXZhc2NyaXB0XG4gIGxldCBwcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKDEpO1xuXG4gIHByb21pc2UudGhlbihmdW5jdGlvbih2YWx1ZSl7XG4gICAgLy8gdmFsdWUgPT09IDFcbiAgfSk7XG4gIGBgYFxuXG4gIEBtZXRob2QgcmVzb2x2ZVxuICBAc3RhdGljXG4gIEBwYXJhbSB7QW55fSB2YWx1ZSB2YWx1ZSB0aGF0IHRoZSByZXR1cm5lZCBwcm9taXNlIHdpbGwgYmUgcmVzb2x2ZWQgd2l0aFxuICBVc2VmdWwgZm9yIHRvb2xpbmcuXG4gIEByZXR1cm4ge1Byb21pc2V9IGEgcHJvbWlzZSB0aGF0IHdpbGwgYmVjb21lIGZ1bGZpbGxlZCB3aXRoIHRoZSBnaXZlblxuICBgdmFsdWVgXG4qL1xuZnVuY3Rpb24gcmVzb2x2ZSQxKG9iamVjdCkge1xuICAvKmpzaGludCB2YWxpZHRoaXM6dHJ1ZSAqL1xuICB2YXIgQ29uc3RydWN0b3IgPSB0aGlzO1xuXG4gIGlmIChvYmplY3QgJiYgdHlwZW9mIG9iamVjdCA9PT0gJ29iamVjdCcgJiYgb2JqZWN0LmNvbnN0cnVjdG9yID09PSBDb25zdHJ1Y3Rvcikge1xuICAgIHJldHVybiBvYmplY3Q7XG4gIH1cblxuICB2YXIgcHJvbWlzZSA9IG5ldyBDb25zdHJ1Y3Rvcihub29wKTtcbiAgcmVzb2x2ZShwcm9taXNlLCBvYmplY3QpO1xuICByZXR1cm4gcHJvbWlzZTtcbn1cblxudmFyIFBST01JU0VfSUQgPSBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHJpbmcoMik7XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG52YXIgUEVORElORyA9IHZvaWQgMDtcbnZhciBGVUxGSUxMRUQgPSAxO1xudmFyIFJFSkVDVEVEID0gMjtcblxuZnVuY3Rpb24gc2VsZkZ1bGZpbGxtZW50KCkge1xuICByZXR1cm4gbmV3IFR5cGVFcnJvcihcIllvdSBjYW5ub3QgcmVzb2x2ZSBhIHByb21pc2Ugd2l0aCBpdHNlbGZcIik7XG59XG5cbmZ1bmN0aW9uIGNhbm5vdFJldHVybk93bigpIHtcbiAgcmV0dXJuIG5ldyBUeXBlRXJyb3IoJ0EgcHJvbWlzZXMgY2FsbGJhY2sgY2Fubm90IHJldHVybiB0aGF0IHNhbWUgcHJvbWlzZS4nKTtcbn1cblxuZnVuY3Rpb24gdHJ5VGhlbih0aGVuJCQxLCB2YWx1ZSwgZnVsZmlsbG1lbnRIYW5kbGVyLCByZWplY3Rpb25IYW5kbGVyKSB7XG4gIHRyeSB7XG4gICAgdGhlbiQkMS5jYWxsKHZhbHVlLCBmdWxmaWxsbWVudEhhbmRsZXIsIHJlamVjdGlvbkhhbmRsZXIpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGU7XG4gIH1cbn1cblxuZnVuY3Rpb24gaGFuZGxlRm9yZWlnblRoZW5hYmxlKHByb21pc2UsIHRoZW5hYmxlLCB0aGVuJCQxKSB7XG4gIGFzYXAoZnVuY3Rpb24gKHByb21pc2UpIHtcbiAgICB2YXIgc2VhbGVkID0gZmFsc2U7XG4gICAgdmFyIGVycm9yID0gdHJ5VGhlbih0aGVuJCQxLCB0aGVuYWJsZSwgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICBpZiAoc2VhbGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHNlYWxlZCA9IHRydWU7XG4gICAgICBpZiAodGhlbmFibGUgIT09IHZhbHVlKSB7XG4gICAgICAgIHJlc29sdmUocHJvbWlzZSwgdmFsdWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZnVsZmlsbChwcm9taXNlLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfSwgZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgaWYgKHNlYWxlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBzZWFsZWQgPSB0cnVlO1xuXG4gICAgICByZWplY3QocHJvbWlzZSwgcmVhc29uKTtcbiAgICB9LCAnU2V0dGxlOiAnICsgKHByb21pc2UuX2xhYmVsIHx8ICcgdW5rbm93biBwcm9taXNlJykpO1xuXG4gICAgaWYgKCFzZWFsZWQgJiYgZXJyb3IpIHtcbiAgICAgIHNlYWxlZCA9IHRydWU7XG4gICAgICByZWplY3QocHJvbWlzZSwgZXJyb3IpO1xuICAgIH1cbiAgfSwgcHJvbWlzZSk7XG59XG5cbmZ1bmN0aW9uIGhhbmRsZU93blRoZW5hYmxlKHByb21pc2UsIHRoZW5hYmxlKSB7XG4gIGlmICh0aGVuYWJsZS5fc3RhdGUgPT09IEZVTEZJTExFRCkge1xuICAgIGZ1bGZpbGwocHJvbWlzZSwgdGhlbmFibGUuX3Jlc3VsdCk7XG4gIH0gZWxzZSBpZiAodGhlbmFibGUuX3N0YXRlID09PSBSRUpFQ1RFRCkge1xuICAgIHJlamVjdChwcm9taXNlLCB0aGVuYWJsZS5fcmVzdWx0KTtcbiAgfSBlbHNlIHtcbiAgICBzdWJzY3JpYmUodGhlbmFibGUsIHVuZGVmaW5lZCwgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICByZXR1cm4gcmVzb2x2ZShwcm9taXNlLCB2YWx1ZSk7XG4gICAgfSwgZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgcmV0dXJuIHJlamVjdChwcm9taXNlLCByZWFzb24pO1xuICAgIH0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGhhbmRsZU1heWJlVGhlbmFibGUocHJvbWlzZSwgbWF5YmVUaGVuYWJsZSwgdGhlbiQkMSkge1xuICBpZiAobWF5YmVUaGVuYWJsZS5jb25zdHJ1Y3RvciA9PT0gcHJvbWlzZS5jb25zdHJ1Y3RvciAmJiB0aGVuJCQxID09PSB0aGVuICYmIG1heWJlVGhlbmFibGUuY29uc3RydWN0b3IucmVzb2x2ZSA9PT0gcmVzb2x2ZSQxKSB7XG4gICAgaGFuZGxlT3duVGhlbmFibGUocHJvbWlzZSwgbWF5YmVUaGVuYWJsZSk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKHRoZW4kJDEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgZnVsZmlsbChwcm9taXNlLCBtYXliZVRoZW5hYmxlKTtcbiAgICB9IGVsc2UgaWYgKGlzRnVuY3Rpb24odGhlbiQkMSkpIHtcbiAgICAgIGhhbmRsZUZvcmVpZ25UaGVuYWJsZShwcm9taXNlLCBtYXliZVRoZW5hYmxlLCB0aGVuJCQxKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZnVsZmlsbChwcm9taXNlLCBtYXliZVRoZW5hYmxlKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVzb2x2ZShwcm9taXNlLCB2YWx1ZSkge1xuICBpZiAocHJvbWlzZSA9PT0gdmFsdWUpIHtcbiAgICByZWplY3QocHJvbWlzZSwgc2VsZkZ1bGZpbGxtZW50KCkpO1xuICB9IGVsc2UgaWYgKG9iamVjdE9yRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgdmFyIHRoZW4kJDEgPSB2b2lkIDA7XG4gICAgdHJ5IHtcbiAgICAgIHRoZW4kJDEgPSB2YWx1ZS50aGVuO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICByZWplY3QocHJvbWlzZSwgZXJyb3IpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBoYW5kbGVNYXliZVRoZW5hYmxlKHByb21pc2UsIHZhbHVlLCB0aGVuJCQxKTtcbiAgfSBlbHNlIHtcbiAgICBmdWxmaWxsKHByb21pc2UsIHZhbHVlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwdWJsaXNoUmVqZWN0aW9uKHByb21pc2UpIHtcbiAgaWYgKHByb21pc2UuX29uZXJyb3IpIHtcbiAgICBwcm9taXNlLl9vbmVycm9yKHByb21pc2UuX3Jlc3VsdCk7XG4gIH1cblxuICBwdWJsaXNoKHByb21pc2UpO1xufVxuXG5mdW5jdGlvbiBmdWxmaWxsKHByb21pc2UsIHZhbHVlKSB7XG4gIGlmIChwcm9taXNlLl9zdGF0ZSAhPT0gUEVORElORykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHByb21pc2UuX3Jlc3VsdCA9IHZhbHVlO1xuICBwcm9taXNlLl9zdGF0ZSA9IEZVTEZJTExFRDtcblxuICBpZiAocHJvbWlzZS5fc3Vic2NyaWJlcnMubGVuZ3RoICE9PSAwKSB7XG4gICAgYXNhcChwdWJsaXNoLCBwcm9taXNlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZWplY3QocHJvbWlzZSwgcmVhc29uKSB7XG4gIGlmIChwcm9taXNlLl9zdGF0ZSAhPT0gUEVORElORykge1xuICAgIHJldHVybjtcbiAgfVxuICBwcm9taXNlLl9zdGF0ZSA9IFJFSkVDVEVEO1xuICBwcm9taXNlLl9yZXN1bHQgPSByZWFzb247XG5cbiAgYXNhcChwdWJsaXNoUmVqZWN0aW9uLCBwcm9taXNlKTtcbn1cblxuZnVuY3Rpb24gc3Vic2NyaWJlKHBhcmVudCwgY2hpbGQsIG9uRnVsZmlsbG1lbnQsIG9uUmVqZWN0aW9uKSB7XG4gIHZhciBfc3Vic2NyaWJlcnMgPSBwYXJlbnQuX3N1YnNjcmliZXJzO1xuICB2YXIgbGVuZ3RoID0gX3N1YnNjcmliZXJzLmxlbmd0aDtcblxuXG4gIHBhcmVudC5fb25lcnJvciA9IG51bGw7XG5cbiAgX3N1YnNjcmliZXJzW2xlbmd0aF0gPSBjaGlsZDtcbiAgX3N1YnNjcmliZXJzW2xlbmd0aCArIEZVTEZJTExFRF0gPSBvbkZ1bGZpbGxtZW50O1xuICBfc3Vic2NyaWJlcnNbbGVuZ3RoICsgUkVKRUNURURdID0gb25SZWplY3Rpb247XG5cbiAgaWYgKGxlbmd0aCA9PT0gMCAmJiBwYXJlbnQuX3N0YXRlKSB7XG4gICAgYXNhcChwdWJsaXNoLCBwYXJlbnQpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHB1Ymxpc2gocHJvbWlzZSkge1xuICB2YXIgc3Vic2NyaWJlcnMgPSBwcm9taXNlLl9zdWJzY3JpYmVycztcbiAgdmFyIHNldHRsZWQgPSBwcm9taXNlLl9zdGF0ZTtcblxuICBpZiAoc3Vic2NyaWJlcnMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGNoaWxkID0gdm9pZCAwLFxuICAgICAgY2FsbGJhY2sgPSB2b2lkIDAsXG4gICAgICBkZXRhaWwgPSBwcm9taXNlLl9yZXN1bHQ7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdWJzY3JpYmVycy5sZW5ndGg7IGkgKz0gMykge1xuICAgIGNoaWxkID0gc3Vic2NyaWJlcnNbaV07XG4gICAgY2FsbGJhY2sgPSBzdWJzY3JpYmVyc1tpICsgc2V0dGxlZF07XG5cbiAgICBpZiAoY2hpbGQpIHtcbiAgICAgIGludm9rZUNhbGxiYWNrKHNldHRsZWQsIGNoaWxkLCBjYWxsYmFjaywgZGV0YWlsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2FsbGJhY2soZGV0YWlsKTtcbiAgICB9XG4gIH1cblxuICBwcm9taXNlLl9zdWJzY3JpYmVycy5sZW5ndGggPSAwO1xufVxuXG5mdW5jdGlvbiBpbnZva2VDYWxsYmFjayhzZXR0bGVkLCBwcm9taXNlLCBjYWxsYmFjaywgZGV0YWlsKSB7XG4gIHZhciBoYXNDYWxsYmFjayA9IGlzRnVuY3Rpb24oY2FsbGJhY2spLFxuICAgICAgdmFsdWUgPSB2b2lkIDAsXG4gICAgICBlcnJvciA9IHZvaWQgMCxcbiAgICAgIHN1Y2NlZWRlZCA9IHRydWU7XG5cbiAgaWYgKGhhc0NhbGxiYWNrKSB7XG4gICAgdHJ5IHtcbiAgICAgIHZhbHVlID0gY2FsbGJhY2soZGV0YWlsKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBzdWNjZWVkZWQgPSBmYWxzZTtcbiAgICAgIGVycm9yID0gZTtcbiAgICB9XG5cbiAgICBpZiAocHJvbWlzZSA9PT0gdmFsdWUpIHtcbiAgICAgIHJlamVjdChwcm9taXNlLCBjYW5ub3RSZXR1cm5Pd24oKSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhbHVlID0gZGV0YWlsO1xuICB9XG5cbiAgaWYgKHByb21pc2UuX3N0YXRlICE9PSBQRU5ESU5HKSB7XG4gICAgLy8gbm9vcFxuICB9IGVsc2UgaWYgKGhhc0NhbGxiYWNrICYmIHN1Y2NlZWRlZCkge1xuICAgIHJlc29sdmUocHJvbWlzZSwgdmFsdWUpO1xuICB9IGVsc2UgaWYgKHN1Y2NlZWRlZCA9PT0gZmFsc2UpIHtcbiAgICByZWplY3QocHJvbWlzZSwgZXJyb3IpO1xuICB9IGVsc2UgaWYgKHNldHRsZWQgPT09IEZVTEZJTExFRCkge1xuICAgIGZ1bGZpbGwocHJvbWlzZSwgdmFsdWUpO1xuICB9IGVsc2UgaWYgKHNldHRsZWQgPT09IFJFSkVDVEVEKSB7XG4gICAgcmVqZWN0KHByb21pc2UsIHZhbHVlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpbml0aWFsaXplUHJvbWlzZShwcm9taXNlLCByZXNvbHZlcikge1xuICB0cnkge1xuICAgIHJlc29sdmVyKGZ1bmN0aW9uIHJlc29sdmVQcm9taXNlKHZhbHVlKSB7XG4gICAgICByZXNvbHZlKHByb21pc2UsIHZhbHVlKTtcbiAgICB9LCBmdW5jdGlvbiByZWplY3RQcm9taXNlKHJlYXNvbikge1xuICAgICAgcmVqZWN0KHByb21pc2UsIHJlYXNvbik7XG4gICAgfSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZWplY3QocHJvbWlzZSwgZSk7XG4gIH1cbn1cblxudmFyIGlkID0gMDtcbmZ1bmN0aW9uIG5leHRJZCgpIHtcbiAgcmV0dXJuIGlkKys7XG59XG5cbmZ1bmN0aW9uIG1ha2VQcm9taXNlKHByb21pc2UpIHtcbiAgcHJvbWlzZVtQUk9NSVNFX0lEXSA9IGlkKys7XG4gIHByb21pc2UuX3N0YXRlID0gdW5kZWZpbmVkO1xuICBwcm9taXNlLl9yZXN1bHQgPSB1bmRlZmluZWQ7XG4gIHByb21pc2UuX3N1YnNjcmliZXJzID0gW107XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRpb25FcnJvcigpIHtcbiAgcmV0dXJuIG5ldyBFcnJvcignQXJyYXkgTWV0aG9kcyBtdXN0IGJlIHByb3ZpZGVkIGFuIEFycmF5Jyk7XG59XG5cbnZhciBFbnVtZXJhdG9yID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBFbnVtZXJhdG9yKENvbnN0cnVjdG9yLCBpbnB1dCkge1xuICAgIHRoaXMuX2luc3RhbmNlQ29uc3RydWN0b3IgPSBDb25zdHJ1Y3RvcjtcbiAgICB0aGlzLnByb21pc2UgPSBuZXcgQ29uc3RydWN0b3Iobm9vcCk7XG5cbiAgICBpZiAoIXRoaXMucHJvbWlzZVtQUk9NSVNFX0lEXSkge1xuICAgICAgbWFrZVByb21pc2UodGhpcy5wcm9taXNlKTtcbiAgICB9XG5cbiAgICBpZiAoaXNBcnJheShpbnB1dCkpIHtcbiAgICAgIHRoaXMubGVuZ3RoID0gaW5wdXQubGVuZ3RoO1xuICAgICAgdGhpcy5fcmVtYWluaW5nID0gaW5wdXQubGVuZ3RoO1xuXG4gICAgICB0aGlzLl9yZXN1bHQgPSBuZXcgQXJyYXkodGhpcy5sZW5ndGgpO1xuXG4gICAgICBpZiAodGhpcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgZnVsZmlsbCh0aGlzLnByb21pc2UsIHRoaXMuX3Jlc3VsdCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmxlbmd0aCA9IHRoaXMubGVuZ3RoIHx8IDA7XG4gICAgICAgIHRoaXMuX2VudW1lcmF0ZShpbnB1dCk7XG4gICAgICAgIGlmICh0aGlzLl9yZW1haW5pbmcgPT09IDApIHtcbiAgICAgICAgICBmdWxmaWxsKHRoaXMucHJvbWlzZSwgdGhpcy5fcmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZWplY3QodGhpcy5wcm9taXNlLCB2YWxpZGF0aW9uRXJyb3IoKSk7XG4gICAgfVxuICB9XG5cbiAgRW51bWVyYXRvci5wcm90b3R5cGUuX2VudW1lcmF0ZSA9IGZ1bmN0aW9uIF9lbnVtZXJhdGUoaW5wdXQpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgdGhpcy5fc3RhdGUgPT09IFBFTkRJTkcgJiYgaSA8IGlucHV0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLl9lYWNoRW50cnkoaW5wdXRbaV0sIGkpO1xuICAgIH1cbiAgfTtcblxuICBFbnVtZXJhdG9yLnByb3RvdHlwZS5fZWFjaEVudHJ5ID0gZnVuY3Rpb24gX2VhY2hFbnRyeShlbnRyeSwgaSkge1xuICAgIHZhciBjID0gdGhpcy5faW5zdGFuY2VDb25zdHJ1Y3RvcjtcbiAgICB2YXIgcmVzb2x2ZSQkMSA9IGMucmVzb2x2ZTtcblxuXG4gICAgaWYgKHJlc29sdmUkJDEgPT09IHJlc29sdmUkMSkge1xuICAgICAgdmFyIF90aGVuID0gdm9pZCAwO1xuICAgICAgdmFyIGVycm9yID0gdm9pZCAwO1xuICAgICAgdmFyIGRpZEVycm9yID0gZmFsc2U7XG4gICAgICB0cnkge1xuICAgICAgICBfdGhlbiA9IGVudHJ5LnRoZW47XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGRpZEVycm9yID0gdHJ1ZTtcbiAgICAgICAgZXJyb3IgPSBlO1xuICAgICAgfVxuXG4gICAgICBpZiAoX3RoZW4gPT09IHRoZW4gJiYgZW50cnkuX3N0YXRlICE9PSBQRU5ESU5HKSB7XG4gICAgICAgIHRoaXMuX3NldHRsZWRBdChlbnRyeS5fc3RhdGUsIGksIGVudHJ5Ll9yZXN1bHQpO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgX3RoZW4gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhpcy5fcmVtYWluaW5nLS07XG4gICAgICAgIHRoaXMuX3Jlc3VsdFtpXSA9IGVudHJ5O1xuICAgICAgfSBlbHNlIGlmIChjID09PSBQcm9taXNlJDEpIHtcbiAgICAgICAgdmFyIHByb21pc2UgPSBuZXcgYyhub29wKTtcbiAgICAgICAgaWYgKGRpZEVycm9yKSB7XG4gICAgICAgICAgcmVqZWN0KHByb21pc2UsIGVycm9yKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBoYW5kbGVNYXliZVRoZW5hYmxlKHByb21pc2UsIGVudHJ5LCBfdGhlbik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fd2lsbFNldHRsZUF0KHByb21pc2UsIGkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fd2lsbFNldHRsZUF0KG5ldyBjKGZ1bmN0aW9uIChyZXNvbHZlJCQxKSB7XG4gICAgICAgICAgcmV0dXJuIHJlc29sdmUkJDEoZW50cnkpO1xuICAgICAgICB9KSwgaSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3dpbGxTZXR0bGVBdChyZXNvbHZlJCQxKGVudHJ5KSwgaSk7XG4gICAgfVxuICB9O1xuXG4gIEVudW1lcmF0b3IucHJvdG90eXBlLl9zZXR0bGVkQXQgPSBmdW5jdGlvbiBfc2V0dGxlZEF0KHN0YXRlLCBpLCB2YWx1ZSkge1xuICAgIHZhciBwcm9taXNlID0gdGhpcy5wcm9taXNlO1xuXG5cbiAgICBpZiAocHJvbWlzZS5fc3RhdGUgPT09IFBFTkRJTkcpIHtcbiAgICAgIHRoaXMuX3JlbWFpbmluZy0tO1xuXG4gICAgICBpZiAoc3RhdGUgPT09IFJFSkVDVEVEKSB7XG4gICAgICAgIHJlamVjdChwcm9taXNlLCB2YWx1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9yZXN1bHRbaV0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpcy5fcmVtYWluaW5nID09PSAwKSB7XG4gICAgICBmdWxmaWxsKHByb21pc2UsIHRoaXMuX3Jlc3VsdCk7XG4gICAgfVxuICB9O1xuXG4gIEVudW1lcmF0b3IucHJvdG90eXBlLl93aWxsU2V0dGxlQXQgPSBmdW5jdGlvbiBfd2lsbFNldHRsZUF0KHByb21pc2UsIGkpIHtcbiAgICB2YXIgZW51bWVyYXRvciA9IHRoaXM7XG5cbiAgICBzdWJzY3JpYmUocHJvbWlzZSwgdW5kZWZpbmVkLCBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIHJldHVybiBlbnVtZXJhdG9yLl9zZXR0bGVkQXQoRlVMRklMTEVELCBpLCB2YWx1ZSk7XG4gICAgfSwgZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgcmV0dXJuIGVudW1lcmF0b3IuX3NldHRsZWRBdChSRUpFQ1RFRCwgaSwgcmVhc29uKTtcbiAgICB9KTtcbiAgfTtcblxuICByZXR1cm4gRW51bWVyYXRvcjtcbn0oKTtcblxuLyoqXG4gIGBQcm9taXNlLmFsbGAgYWNjZXB0cyBhbiBhcnJheSBvZiBwcm9taXNlcywgYW5kIHJldHVybnMgYSBuZXcgcHJvbWlzZSB3aGljaFxuICBpcyBmdWxmaWxsZWQgd2l0aCBhbiBhcnJheSBvZiBmdWxmaWxsbWVudCB2YWx1ZXMgZm9yIHRoZSBwYXNzZWQgcHJvbWlzZXMsIG9yXG4gIHJlamVjdGVkIHdpdGggdGhlIHJlYXNvbiBvZiB0aGUgZmlyc3QgcGFzc2VkIHByb21pc2UgdG8gYmUgcmVqZWN0ZWQuIEl0IGNhc3RzIGFsbFxuICBlbGVtZW50cyBvZiB0aGUgcGFzc2VkIGl0ZXJhYmxlIHRvIHByb21pc2VzIGFzIGl0IHJ1bnMgdGhpcyBhbGdvcml0aG0uXG5cbiAgRXhhbXBsZTpcblxuICBgYGBqYXZhc2NyaXB0XG4gIGxldCBwcm9taXNlMSA9IHJlc29sdmUoMSk7XG4gIGxldCBwcm9taXNlMiA9IHJlc29sdmUoMik7XG4gIGxldCBwcm9taXNlMyA9IHJlc29sdmUoMyk7XG4gIGxldCBwcm9taXNlcyA9IFsgcHJvbWlzZTEsIHByb21pc2UyLCBwcm9taXNlMyBdO1xuXG4gIFByb21pc2UuYWxsKHByb21pc2VzKS50aGVuKGZ1bmN0aW9uKGFycmF5KXtcbiAgICAvLyBUaGUgYXJyYXkgaGVyZSB3b3VsZCBiZSBbIDEsIDIsIDMgXTtcbiAgfSk7XG4gIGBgYFxuXG4gIElmIGFueSBvZiB0aGUgYHByb21pc2VzYCBnaXZlbiB0byBgYWxsYCBhcmUgcmVqZWN0ZWQsIHRoZSBmaXJzdCBwcm9taXNlXG4gIHRoYXQgaXMgcmVqZWN0ZWQgd2lsbCBiZSBnaXZlbiBhcyBhbiBhcmd1bWVudCB0byB0aGUgcmV0dXJuZWQgcHJvbWlzZXMnc1xuICByZWplY3Rpb24gaGFuZGxlci4gRm9yIGV4YW1wbGU6XG5cbiAgRXhhbXBsZTpcblxuICBgYGBqYXZhc2NyaXB0XG4gIGxldCBwcm9taXNlMSA9IHJlc29sdmUoMSk7XG4gIGxldCBwcm9taXNlMiA9IHJlamVjdChuZXcgRXJyb3IoXCIyXCIpKTtcbiAgbGV0IHByb21pc2UzID0gcmVqZWN0KG5ldyBFcnJvcihcIjNcIikpO1xuICBsZXQgcHJvbWlzZXMgPSBbIHByb21pc2UxLCBwcm9taXNlMiwgcHJvbWlzZTMgXTtcblxuICBQcm9taXNlLmFsbChwcm9taXNlcykudGhlbihmdW5jdGlvbihhcnJheSl7XG4gICAgLy8gQ29kZSBoZXJlIG5ldmVyIHJ1bnMgYmVjYXVzZSB0aGVyZSBhcmUgcmVqZWN0ZWQgcHJvbWlzZXMhXG4gIH0sIGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgLy8gZXJyb3IubWVzc2FnZSA9PT0gXCIyXCJcbiAgfSk7XG4gIGBgYFxuXG4gIEBtZXRob2QgYWxsXG4gIEBzdGF0aWNcbiAgQHBhcmFtIHtBcnJheX0gZW50cmllcyBhcnJheSBvZiBwcm9taXNlc1xuICBAcGFyYW0ge1N0cmluZ30gbGFiZWwgb3B0aW9uYWwgc3RyaW5nIGZvciBsYWJlbGluZyB0aGUgcHJvbWlzZS5cbiAgVXNlZnVsIGZvciB0b29saW5nLlxuICBAcmV0dXJuIHtQcm9taXNlfSBwcm9taXNlIHRoYXQgaXMgZnVsZmlsbGVkIHdoZW4gYWxsIGBwcm9taXNlc2AgaGF2ZSBiZWVuXG4gIGZ1bGZpbGxlZCwgb3IgcmVqZWN0ZWQgaWYgYW55IG9mIHRoZW0gYmVjb21lIHJlamVjdGVkLlxuICBAc3RhdGljXG4qL1xuZnVuY3Rpb24gYWxsKGVudHJpZXMpIHtcbiAgcmV0dXJuIG5ldyBFbnVtZXJhdG9yKHRoaXMsIGVudHJpZXMpLnByb21pc2U7XG59XG5cbi8qKlxuICBgUHJvbWlzZS5yYWNlYCByZXR1cm5zIGEgbmV3IHByb21pc2Ugd2hpY2ggaXMgc2V0dGxlZCBpbiB0aGUgc2FtZSB3YXkgYXMgdGhlXG4gIGZpcnN0IHBhc3NlZCBwcm9taXNlIHRvIHNldHRsZS5cblxuICBFeGFtcGxlOlxuXG4gIGBgYGphdmFzY3JpcHRcbiAgbGV0IHByb21pc2UxID0gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KXtcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XG4gICAgICByZXNvbHZlKCdwcm9taXNlIDEnKTtcbiAgICB9LCAyMDApO1xuICB9KTtcblxuICBsZXQgcHJvbWlzZTIgPSBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3Qpe1xuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcbiAgICAgIHJlc29sdmUoJ3Byb21pc2UgMicpO1xuICAgIH0sIDEwMCk7XG4gIH0pO1xuXG4gIFByb21pc2UucmFjZShbcHJvbWlzZTEsIHByb21pc2UyXSkudGhlbihmdW5jdGlvbihyZXN1bHQpe1xuICAgIC8vIHJlc3VsdCA9PT0gJ3Byb21pc2UgMicgYmVjYXVzZSBpdCB3YXMgcmVzb2x2ZWQgYmVmb3JlIHByb21pc2UxXG4gICAgLy8gd2FzIHJlc29sdmVkLlxuICB9KTtcbiAgYGBgXG5cbiAgYFByb21pc2UucmFjZWAgaXMgZGV0ZXJtaW5pc3RpYyBpbiB0aGF0IG9ubHkgdGhlIHN0YXRlIG9mIHRoZSBmaXJzdFxuICBzZXR0bGVkIHByb21pc2UgbWF0dGVycy4gRm9yIGV4YW1wbGUsIGV2ZW4gaWYgb3RoZXIgcHJvbWlzZXMgZ2l2ZW4gdG8gdGhlXG4gIGBwcm9taXNlc2AgYXJyYXkgYXJndW1lbnQgYXJlIHJlc29sdmVkLCBidXQgdGhlIGZpcnN0IHNldHRsZWQgcHJvbWlzZSBoYXNcbiAgYmVjb21lIHJlamVjdGVkIGJlZm9yZSB0aGUgb3RoZXIgcHJvbWlzZXMgYmVjYW1lIGZ1bGZpbGxlZCwgdGhlIHJldHVybmVkXG4gIHByb21pc2Ugd2lsbCBiZWNvbWUgcmVqZWN0ZWQ6XG5cbiAgYGBgamF2YXNjcmlwdFxuICBsZXQgcHJvbWlzZTEgPSBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3Qpe1xuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcbiAgICAgIHJlc29sdmUoJ3Byb21pc2UgMScpO1xuICAgIH0sIDIwMCk7XG4gIH0pO1xuXG4gIGxldCBwcm9taXNlMiA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCl7XG4gICAgc2V0VGltZW91dChmdW5jdGlvbigpe1xuICAgICAgcmVqZWN0KG5ldyBFcnJvcigncHJvbWlzZSAyJykpO1xuICAgIH0sIDEwMCk7XG4gIH0pO1xuXG4gIFByb21pc2UucmFjZShbcHJvbWlzZTEsIHByb21pc2UyXSkudGhlbihmdW5jdGlvbihyZXN1bHQpe1xuICAgIC8vIENvZGUgaGVyZSBuZXZlciBydW5zXG4gIH0sIGZ1bmN0aW9uKHJlYXNvbil7XG4gICAgLy8gcmVhc29uLm1lc3NhZ2UgPT09ICdwcm9taXNlIDInIGJlY2F1c2UgcHJvbWlzZSAyIGJlY2FtZSByZWplY3RlZCBiZWZvcmVcbiAgICAvLyBwcm9taXNlIDEgYmVjYW1lIGZ1bGZpbGxlZFxuICB9KTtcbiAgYGBgXG5cbiAgQW4gZXhhbXBsZSByZWFsLXdvcmxkIHVzZSBjYXNlIGlzIGltcGxlbWVudGluZyB0aW1lb3V0czpcblxuICBgYGBqYXZhc2NyaXB0XG4gIFByb21pc2UucmFjZShbYWpheCgnZm9vLmpzb24nKSwgdGltZW91dCg1MDAwKV0pXG4gIGBgYFxuXG4gIEBtZXRob2QgcmFjZVxuICBAc3RhdGljXG4gIEBwYXJhbSB7QXJyYXl9IHByb21pc2VzIGFycmF5IG9mIHByb21pc2VzIHRvIG9ic2VydmVcbiAgVXNlZnVsIGZvciB0b29saW5nLlxuICBAcmV0dXJuIHtQcm9taXNlfSBhIHByb21pc2Ugd2hpY2ggc2V0dGxlcyBpbiB0aGUgc2FtZSB3YXkgYXMgdGhlIGZpcnN0IHBhc3NlZFxuICBwcm9taXNlIHRvIHNldHRsZS5cbiovXG5mdW5jdGlvbiByYWNlKGVudHJpZXMpIHtcbiAgLypqc2hpbnQgdmFsaWR0aGlzOnRydWUgKi9cbiAgdmFyIENvbnN0cnVjdG9yID0gdGhpcztcblxuICBpZiAoIWlzQXJyYXkoZW50cmllcykpIHtcbiAgICByZXR1cm4gbmV3IENvbnN0cnVjdG9yKGZ1bmN0aW9uIChfLCByZWplY3QpIHtcbiAgICAgIHJldHVybiByZWplY3QobmV3IFR5cGVFcnJvcignWW91IG11c3QgcGFzcyBhbiBhcnJheSB0byByYWNlLicpKTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbmV3IENvbnN0cnVjdG9yKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIHZhciBsZW5ndGggPSBlbnRyaWVzLmxlbmd0aDtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgQ29uc3RydWN0b3IucmVzb2x2ZShlbnRyaWVzW2ldKS50aGVuKHJlc29sdmUsIHJlamVjdCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cblxuLyoqXG4gIGBQcm9taXNlLnJlamVjdGAgcmV0dXJucyBhIHByb21pc2UgcmVqZWN0ZWQgd2l0aCB0aGUgcGFzc2VkIGByZWFzb25gLlxuICBJdCBpcyBzaG9ydGhhbmQgZm9yIHRoZSBmb2xsb3dpbmc6XG5cbiAgYGBgamF2YXNjcmlwdFxuICBsZXQgcHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCl7XG4gICAgcmVqZWN0KG5ldyBFcnJvcignV0hPT1BTJykpO1xuICB9KTtcblxuICBwcm9taXNlLnRoZW4oZnVuY3Rpb24odmFsdWUpe1xuICAgIC8vIENvZGUgaGVyZSBkb2Vzbid0IHJ1biBiZWNhdXNlIHRoZSBwcm9taXNlIGlzIHJlamVjdGVkIVxuICB9LCBmdW5jdGlvbihyZWFzb24pe1xuICAgIC8vIHJlYXNvbi5tZXNzYWdlID09PSAnV0hPT1BTJ1xuICB9KTtcbiAgYGBgXG5cbiAgSW5zdGVhZCBvZiB3cml0aW5nIHRoZSBhYm92ZSwgeW91ciBjb2RlIG5vdyBzaW1wbHkgYmVjb21lcyB0aGUgZm9sbG93aW5nOlxuXG4gIGBgYGphdmFzY3JpcHRcbiAgbGV0IHByb21pc2UgPSBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoJ1dIT09QUycpKTtcblxuICBwcm9taXNlLnRoZW4oZnVuY3Rpb24odmFsdWUpe1xuICAgIC8vIENvZGUgaGVyZSBkb2Vzbid0IHJ1biBiZWNhdXNlIHRoZSBwcm9taXNlIGlzIHJlamVjdGVkIVxuICB9LCBmdW5jdGlvbihyZWFzb24pe1xuICAgIC8vIHJlYXNvbi5tZXNzYWdlID09PSAnV0hPT1BTJ1xuICB9KTtcbiAgYGBgXG5cbiAgQG1ldGhvZCByZWplY3RcbiAgQHN0YXRpY1xuICBAcGFyYW0ge0FueX0gcmVhc29uIHZhbHVlIHRoYXQgdGhlIHJldHVybmVkIHByb21pc2Ugd2lsbCBiZSByZWplY3RlZCB3aXRoLlxuICBVc2VmdWwgZm9yIHRvb2xpbmcuXG4gIEByZXR1cm4ge1Byb21pc2V9IGEgcHJvbWlzZSByZWplY3RlZCB3aXRoIHRoZSBnaXZlbiBgcmVhc29uYC5cbiovXG5mdW5jdGlvbiByZWplY3QkMShyZWFzb24pIHtcbiAgLypqc2hpbnQgdmFsaWR0aGlzOnRydWUgKi9cbiAgdmFyIENvbnN0cnVjdG9yID0gdGhpcztcbiAgdmFyIHByb21pc2UgPSBuZXcgQ29uc3RydWN0b3Iobm9vcCk7XG4gIHJlamVjdChwcm9taXNlLCByZWFzb24pO1xuICByZXR1cm4gcHJvbWlzZTtcbn1cblxuZnVuY3Rpb24gbmVlZHNSZXNvbHZlcigpIHtcbiAgdGhyb3cgbmV3IFR5cGVFcnJvcignWW91IG11c3QgcGFzcyBhIHJlc29sdmVyIGZ1bmN0aW9uIGFzIHRoZSBmaXJzdCBhcmd1bWVudCB0byB0aGUgcHJvbWlzZSBjb25zdHJ1Y3RvcicpO1xufVxuXG5mdW5jdGlvbiBuZWVkc05ldygpIHtcbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkZhaWxlZCB0byBjb25zdHJ1Y3QgJ1Byb21pc2UnOiBQbGVhc2UgdXNlIHRoZSAnbmV3JyBvcGVyYXRvciwgdGhpcyBvYmplY3QgY29uc3RydWN0b3IgY2Fubm90IGJlIGNhbGxlZCBhcyBhIGZ1bmN0aW9uLlwiKTtcbn1cblxuLyoqXG4gIFByb21pc2Ugb2JqZWN0cyByZXByZXNlbnQgdGhlIGV2ZW50dWFsIHJlc3VsdCBvZiBhbiBhc3luY2hyb25vdXMgb3BlcmF0aW9uLiBUaGVcbiAgcHJpbWFyeSB3YXkgb2YgaW50ZXJhY3Rpbmcgd2l0aCBhIHByb21pc2UgaXMgdGhyb3VnaCBpdHMgYHRoZW5gIG1ldGhvZCwgd2hpY2hcbiAgcmVnaXN0ZXJzIGNhbGxiYWNrcyB0byByZWNlaXZlIGVpdGhlciBhIHByb21pc2UncyBldmVudHVhbCB2YWx1ZSBvciB0aGUgcmVhc29uXG4gIHdoeSB0aGUgcHJvbWlzZSBjYW5ub3QgYmUgZnVsZmlsbGVkLlxuXG4gIFRlcm1pbm9sb2d5XG4gIC0tLS0tLS0tLS0tXG5cbiAgLSBgcHJvbWlzZWAgaXMgYW4gb2JqZWN0IG9yIGZ1bmN0aW9uIHdpdGggYSBgdGhlbmAgbWV0aG9kIHdob3NlIGJlaGF2aW9yIGNvbmZvcm1zIHRvIHRoaXMgc3BlY2lmaWNhdGlvbi5cbiAgLSBgdGhlbmFibGVgIGlzIGFuIG9iamVjdCBvciBmdW5jdGlvbiB0aGF0IGRlZmluZXMgYSBgdGhlbmAgbWV0aG9kLlxuICAtIGB2YWx1ZWAgaXMgYW55IGxlZ2FsIEphdmFTY3JpcHQgdmFsdWUgKGluY2x1ZGluZyB1bmRlZmluZWQsIGEgdGhlbmFibGUsIG9yIGEgcHJvbWlzZSkuXG4gIC0gYGV4Y2VwdGlvbmAgaXMgYSB2YWx1ZSB0aGF0IGlzIHRocm93biB1c2luZyB0aGUgdGhyb3cgc3RhdGVtZW50LlxuICAtIGByZWFzb25gIGlzIGEgdmFsdWUgdGhhdCBpbmRpY2F0ZXMgd2h5IGEgcHJvbWlzZSB3YXMgcmVqZWN0ZWQuXG4gIC0gYHNldHRsZWRgIHRoZSBmaW5hbCByZXN0aW5nIHN0YXRlIG9mIGEgcHJvbWlzZSwgZnVsZmlsbGVkIG9yIHJlamVjdGVkLlxuXG4gIEEgcHJvbWlzZSBjYW4gYmUgaW4gb25lIG9mIHRocmVlIHN0YXRlczogcGVuZGluZywgZnVsZmlsbGVkLCBvciByZWplY3RlZC5cblxuICBQcm9taXNlcyB0aGF0IGFyZSBmdWxmaWxsZWQgaGF2ZSBhIGZ1bGZpbGxtZW50IHZhbHVlIGFuZCBhcmUgaW4gdGhlIGZ1bGZpbGxlZFxuICBzdGF0ZS4gIFByb21pc2VzIHRoYXQgYXJlIHJlamVjdGVkIGhhdmUgYSByZWplY3Rpb24gcmVhc29uIGFuZCBhcmUgaW4gdGhlXG4gIHJlamVjdGVkIHN0YXRlLiAgQSBmdWxmaWxsbWVudCB2YWx1ZSBpcyBuZXZlciBhIHRoZW5hYmxlLlxuXG4gIFByb21pc2VzIGNhbiBhbHNvIGJlIHNhaWQgdG8gKnJlc29sdmUqIGEgdmFsdWUuICBJZiB0aGlzIHZhbHVlIGlzIGFsc28gYVxuICBwcm9taXNlLCB0aGVuIHRoZSBvcmlnaW5hbCBwcm9taXNlJ3Mgc2V0dGxlZCBzdGF0ZSB3aWxsIG1hdGNoIHRoZSB2YWx1ZSdzXG4gIHNldHRsZWQgc3RhdGUuICBTbyBhIHByb21pc2UgdGhhdCAqcmVzb2x2ZXMqIGEgcHJvbWlzZSB0aGF0IHJlamVjdHMgd2lsbFxuICBpdHNlbGYgcmVqZWN0LCBhbmQgYSBwcm9taXNlIHRoYXQgKnJlc29sdmVzKiBhIHByb21pc2UgdGhhdCBmdWxmaWxscyB3aWxsXG4gIGl0c2VsZiBmdWxmaWxsLlxuXG5cbiAgQmFzaWMgVXNhZ2U6XG4gIC0tLS0tLS0tLS0tLVxuXG4gIGBgYGpzXG4gIGxldCBwcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgLy8gb24gc3VjY2Vzc1xuICAgIHJlc29sdmUodmFsdWUpO1xuXG4gICAgLy8gb24gZmFpbHVyZVxuICAgIHJlamVjdChyZWFzb24pO1xuICB9KTtcblxuICBwcm9taXNlLnRoZW4oZnVuY3Rpb24odmFsdWUpIHtcbiAgICAvLyBvbiBmdWxmaWxsbWVudFxuICB9LCBmdW5jdGlvbihyZWFzb24pIHtcbiAgICAvLyBvbiByZWplY3Rpb25cbiAgfSk7XG4gIGBgYFxuXG4gIEFkdmFuY2VkIFVzYWdlOlxuICAtLS0tLS0tLS0tLS0tLS1cblxuICBQcm9taXNlcyBzaGluZSB3aGVuIGFic3RyYWN0aW5nIGF3YXkgYXN5bmNocm9ub3VzIGludGVyYWN0aW9ucyBzdWNoIGFzXG4gIGBYTUxIdHRwUmVxdWVzdGBzLlxuXG4gIGBgYGpzXG4gIGZ1bmN0aW9uIGdldEpTT04odXJsKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCl7XG4gICAgICBsZXQgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG5cbiAgICAgIHhoci5vcGVuKCdHRVQnLCB1cmwpO1xuICAgICAgeGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGhhbmRsZXI7XG4gICAgICB4aHIucmVzcG9uc2VUeXBlID0gJ2pzb24nO1xuICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoJ0FjY2VwdCcsICdhcHBsaWNhdGlvbi9qc29uJyk7XG4gICAgICB4aHIuc2VuZCgpO1xuXG4gICAgICBmdW5jdGlvbiBoYW5kbGVyKCkge1xuICAgICAgICBpZiAodGhpcy5yZWFkeVN0YXRlID09PSB0aGlzLkRPTkUpIHtcbiAgICAgICAgICBpZiAodGhpcy5zdGF0dXMgPT09IDIwMCkge1xuICAgICAgICAgICAgcmVzb2x2ZSh0aGlzLnJlc3BvbnNlKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcignZ2V0SlNPTjogYCcgKyB1cmwgKyAnYCBmYWlsZWQgd2l0aCBzdGF0dXM6IFsnICsgdGhpcy5zdGF0dXMgKyAnXScpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSk7XG4gIH1cblxuICBnZXRKU09OKCcvcG9zdHMuanNvbicpLnRoZW4oZnVuY3Rpb24oanNvbikge1xuICAgIC8vIG9uIGZ1bGZpbGxtZW50XG4gIH0sIGZ1bmN0aW9uKHJlYXNvbikge1xuICAgIC8vIG9uIHJlamVjdGlvblxuICB9KTtcbiAgYGBgXG5cbiAgVW5saWtlIGNhbGxiYWNrcywgcHJvbWlzZXMgYXJlIGdyZWF0IGNvbXBvc2FibGUgcHJpbWl0aXZlcy5cblxuICBgYGBqc1xuICBQcm9taXNlLmFsbChbXG4gICAgZ2V0SlNPTignL3Bvc3RzJyksXG4gICAgZ2V0SlNPTignL2NvbW1lbnRzJylcbiAgXSkudGhlbihmdW5jdGlvbih2YWx1ZXMpe1xuICAgIHZhbHVlc1swXSAvLyA9PiBwb3N0c0pTT05cbiAgICB2YWx1ZXNbMV0gLy8gPT4gY29tbWVudHNKU09OXG5cbiAgICByZXR1cm4gdmFsdWVzO1xuICB9KTtcbiAgYGBgXG5cbiAgQGNsYXNzIFByb21pc2VcbiAgQHBhcmFtIHtGdW5jdGlvbn0gcmVzb2x2ZXJcbiAgVXNlZnVsIGZvciB0b29saW5nLlxuICBAY29uc3RydWN0b3JcbiovXG5cbnZhciBQcm9taXNlJDEgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFByb21pc2UocmVzb2x2ZXIpIHtcbiAgICB0aGlzW1BST01JU0VfSURdID0gbmV4dElkKCk7XG4gICAgdGhpcy5fcmVzdWx0ID0gdGhpcy5fc3RhdGUgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fc3Vic2NyaWJlcnMgPSBbXTtcblxuICAgIGlmIChub29wICE9PSByZXNvbHZlcikge1xuICAgICAgdHlwZW9mIHJlc29sdmVyICE9PSAnZnVuY3Rpb24nICYmIG5lZWRzUmVzb2x2ZXIoKTtcbiAgICAgIHRoaXMgaW5zdGFuY2VvZiBQcm9taXNlID8gaW5pdGlhbGl6ZVByb21pc2UodGhpcywgcmVzb2x2ZXIpIDogbmVlZHNOZXcoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgVGhlIHByaW1hcnkgd2F5IG9mIGludGVyYWN0aW5nIHdpdGggYSBwcm9taXNlIGlzIHRocm91Z2ggaXRzIGB0aGVuYCBtZXRob2QsXG4gIHdoaWNoIHJlZ2lzdGVycyBjYWxsYmFja3MgdG8gcmVjZWl2ZSBlaXRoZXIgYSBwcm9taXNlJ3MgZXZlbnR1YWwgdmFsdWUgb3IgdGhlXG4gIHJlYXNvbiB3aHkgdGhlIHByb21pc2UgY2Fubm90IGJlIGZ1bGZpbGxlZC5cbiAgIGBgYGpzXG4gIGZpbmRVc2VyKCkudGhlbihmdW5jdGlvbih1c2VyKXtcbiAgICAvLyB1c2VyIGlzIGF2YWlsYWJsZVxuICB9LCBmdW5jdGlvbihyZWFzb24pe1xuICAgIC8vIHVzZXIgaXMgdW5hdmFpbGFibGUsIGFuZCB5b3UgYXJlIGdpdmVuIHRoZSByZWFzb24gd2h5XG4gIH0pO1xuICBgYGBcbiAgIENoYWluaW5nXG4gIC0tLS0tLS0tXG4gICBUaGUgcmV0dXJuIHZhbHVlIG9mIGB0aGVuYCBpcyBpdHNlbGYgYSBwcm9taXNlLiAgVGhpcyBzZWNvbmQsICdkb3duc3RyZWFtJ1xuICBwcm9taXNlIGlzIHJlc29sdmVkIHdpdGggdGhlIHJldHVybiB2YWx1ZSBvZiB0aGUgZmlyc3QgcHJvbWlzZSdzIGZ1bGZpbGxtZW50XG4gIG9yIHJlamVjdGlvbiBoYW5kbGVyLCBvciByZWplY3RlZCBpZiB0aGUgaGFuZGxlciB0aHJvd3MgYW4gZXhjZXB0aW9uLlxuICAgYGBganNcbiAgZmluZFVzZXIoKS50aGVuKGZ1bmN0aW9uICh1c2VyKSB7XG4gICAgcmV0dXJuIHVzZXIubmFtZTtcbiAgfSwgZnVuY3Rpb24gKHJlYXNvbikge1xuICAgIHJldHVybiAnZGVmYXVsdCBuYW1lJztcbiAgfSkudGhlbihmdW5jdGlvbiAodXNlck5hbWUpIHtcbiAgICAvLyBJZiBgZmluZFVzZXJgIGZ1bGZpbGxlZCwgYHVzZXJOYW1lYCB3aWxsIGJlIHRoZSB1c2VyJ3MgbmFtZSwgb3RoZXJ3aXNlIGl0XG4gICAgLy8gd2lsbCBiZSBgJ2RlZmF1bHQgbmFtZSdgXG4gIH0pO1xuICAgZmluZFVzZXIoKS50aGVuKGZ1bmN0aW9uICh1c2VyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdGb3VuZCB1c2VyLCBidXQgc3RpbGwgdW5oYXBweScpO1xuICB9LCBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdgZmluZFVzZXJgIHJlamVjdGVkIGFuZCB3ZSdyZSB1bmhhcHB5Jyk7XG4gIH0pLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgLy8gbmV2ZXIgcmVhY2hlZFxuICB9LCBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgLy8gaWYgYGZpbmRVc2VyYCBmdWxmaWxsZWQsIGByZWFzb25gIHdpbGwgYmUgJ0ZvdW5kIHVzZXIsIGJ1dCBzdGlsbCB1bmhhcHB5Jy5cbiAgICAvLyBJZiBgZmluZFVzZXJgIHJlamVjdGVkLCBgcmVhc29uYCB3aWxsIGJlICdgZmluZFVzZXJgIHJlamVjdGVkIGFuZCB3ZSdyZSB1bmhhcHB5Jy5cbiAgfSk7XG4gIGBgYFxuICBJZiB0aGUgZG93bnN0cmVhbSBwcm9taXNlIGRvZXMgbm90IHNwZWNpZnkgYSByZWplY3Rpb24gaGFuZGxlciwgcmVqZWN0aW9uIHJlYXNvbnMgd2lsbCBiZSBwcm9wYWdhdGVkIGZ1cnRoZXIgZG93bnN0cmVhbS5cbiAgIGBgYGpzXG4gIGZpbmRVc2VyKCkudGhlbihmdW5jdGlvbiAodXNlcikge1xuICAgIHRocm93IG5ldyBQZWRhZ29naWNhbEV4Y2VwdGlvbignVXBzdHJlYW0gZXJyb3InKTtcbiAgfSkudGhlbihmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAvLyBuZXZlciByZWFjaGVkXG4gIH0pLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgLy8gbmV2ZXIgcmVhY2hlZFxuICB9LCBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgLy8gVGhlIGBQZWRnYWdvY2lhbEV4Y2VwdGlvbmAgaXMgcHJvcGFnYXRlZCBhbGwgdGhlIHdheSBkb3duIHRvIGhlcmVcbiAgfSk7XG4gIGBgYFxuICAgQXNzaW1pbGF0aW9uXG4gIC0tLS0tLS0tLS0tLVxuICAgU29tZXRpbWVzIHRoZSB2YWx1ZSB5b3Ugd2FudCB0byBwcm9wYWdhdGUgdG8gYSBkb3duc3RyZWFtIHByb21pc2UgY2FuIG9ubHkgYmVcbiAgcmV0cmlldmVkIGFzeW5jaHJvbm91c2x5LiBUaGlzIGNhbiBiZSBhY2hpZXZlZCBieSByZXR1cm5pbmcgYSBwcm9taXNlIGluIHRoZVxuICBmdWxmaWxsbWVudCBvciByZWplY3Rpb24gaGFuZGxlci4gVGhlIGRvd25zdHJlYW0gcHJvbWlzZSB3aWxsIHRoZW4gYmUgcGVuZGluZ1xuICB1bnRpbCB0aGUgcmV0dXJuZWQgcHJvbWlzZSBpcyBzZXR0bGVkLiBUaGlzIGlzIGNhbGxlZCAqYXNzaW1pbGF0aW9uKi5cbiAgIGBgYGpzXG4gIGZpbmRVc2VyKCkudGhlbihmdW5jdGlvbiAodXNlcikge1xuICAgIHJldHVybiBmaW5kQ29tbWVudHNCeUF1dGhvcih1c2VyKTtcbiAgfSkudGhlbihmdW5jdGlvbiAoY29tbWVudHMpIHtcbiAgICAvLyBUaGUgdXNlcidzIGNvbW1lbnRzIGFyZSBub3cgYXZhaWxhYmxlXG4gIH0pO1xuICBgYGBcbiAgIElmIHRoZSBhc3NpbWxpYXRlZCBwcm9taXNlIHJlamVjdHMsIHRoZW4gdGhlIGRvd25zdHJlYW0gcHJvbWlzZSB3aWxsIGFsc28gcmVqZWN0LlxuICAgYGBganNcbiAgZmluZFVzZXIoKS50aGVuKGZ1bmN0aW9uICh1c2VyKSB7XG4gICAgcmV0dXJuIGZpbmRDb21tZW50c0J5QXV0aG9yKHVzZXIpO1xuICB9KS50aGVuKGZ1bmN0aW9uIChjb21tZW50cykge1xuICAgIC8vIElmIGBmaW5kQ29tbWVudHNCeUF1dGhvcmAgZnVsZmlsbHMsIHdlJ2xsIGhhdmUgdGhlIHZhbHVlIGhlcmVcbiAgfSwgZnVuY3Rpb24gKHJlYXNvbikge1xuICAgIC8vIElmIGBmaW5kQ29tbWVudHNCeUF1dGhvcmAgcmVqZWN0cywgd2UnbGwgaGF2ZSB0aGUgcmVhc29uIGhlcmVcbiAgfSk7XG4gIGBgYFxuICAgU2ltcGxlIEV4YW1wbGVcbiAgLS0tLS0tLS0tLS0tLS1cbiAgIFN5bmNocm9ub3VzIEV4YW1wbGVcbiAgIGBgYGphdmFzY3JpcHRcbiAgbGV0IHJlc3VsdDtcbiAgIHRyeSB7XG4gICAgcmVzdWx0ID0gZmluZFJlc3VsdCgpO1xuICAgIC8vIHN1Y2Nlc3NcbiAgfSBjYXRjaChyZWFzb24pIHtcbiAgICAvLyBmYWlsdXJlXG4gIH1cbiAgYGBgXG4gICBFcnJiYWNrIEV4YW1wbGVcbiAgIGBgYGpzXG4gIGZpbmRSZXN1bHQoZnVuY3Rpb24ocmVzdWx0LCBlcnIpe1xuICAgIGlmIChlcnIpIHtcbiAgICAgIC8vIGZhaWx1cmVcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gc3VjY2Vzc1xuICAgIH1cbiAgfSk7XG4gIGBgYFxuICAgUHJvbWlzZSBFeGFtcGxlO1xuICAgYGBgamF2YXNjcmlwdFxuICBmaW5kUmVzdWx0KCkudGhlbihmdW5jdGlvbihyZXN1bHQpe1xuICAgIC8vIHN1Y2Nlc3NcbiAgfSwgZnVuY3Rpb24ocmVhc29uKXtcbiAgICAvLyBmYWlsdXJlXG4gIH0pO1xuICBgYGBcbiAgIEFkdmFuY2VkIEV4YW1wbGVcbiAgLS0tLS0tLS0tLS0tLS1cbiAgIFN5bmNocm9ub3VzIEV4YW1wbGVcbiAgIGBgYGphdmFzY3JpcHRcbiAgbGV0IGF1dGhvciwgYm9va3M7XG4gICB0cnkge1xuICAgIGF1dGhvciA9IGZpbmRBdXRob3IoKTtcbiAgICBib29rcyAgPSBmaW5kQm9va3NCeUF1dGhvcihhdXRob3IpO1xuICAgIC8vIHN1Y2Nlc3NcbiAgfSBjYXRjaChyZWFzb24pIHtcbiAgICAvLyBmYWlsdXJlXG4gIH1cbiAgYGBgXG4gICBFcnJiYWNrIEV4YW1wbGVcbiAgIGBgYGpzXG4gICBmdW5jdGlvbiBmb3VuZEJvb2tzKGJvb2tzKSB7XG4gICB9XG4gICBmdW5jdGlvbiBmYWlsdXJlKHJlYXNvbikge1xuICAgfVxuICAgZmluZEF1dGhvcihmdW5jdGlvbihhdXRob3IsIGVycil7XG4gICAgaWYgKGVycikge1xuICAgICAgZmFpbHVyZShlcnIpO1xuICAgICAgLy8gZmFpbHVyZVxuICAgIH0gZWxzZSB7XG4gICAgICB0cnkge1xuICAgICAgICBmaW5kQm9vb2tzQnlBdXRob3IoYXV0aG9yLCBmdW5jdGlvbihib29rcywgZXJyKSB7XG4gICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgZmFpbHVyZShlcnIpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBmb3VuZEJvb2tzKGJvb2tzKTtcbiAgICAgICAgICAgIH0gY2F0Y2gocmVhc29uKSB7XG4gICAgICAgICAgICAgIGZhaWx1cmUocmVhc29uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSBjYXRjaChlcnJvcikge1xuICAgICAgICBmYWlsdXJlKGVycik7XG4gICAgICB9XG4gICAgICAvLyBzdWNjZXNzXG4gICAgfVxuICB9KTtcbiAgYGBgXG4gICBQcm9taXNlIEV4YW1wbGU7XG4gICBgYGBqYXZhc2NyaXB0XG4gIGZpbmRBdXRob3IoKS5cbiAgICB0aGVuKGZpbmRCb29rc0J5QXV0aG9yKS5cbiAgICB0aGVuKGZ1bmN0aW9uKGJvb2tzKXtcbiAgICAgIC8vIGZvdW5kIGJvb2tzXG4gIH0pLmNhdGNoKGZ1bmN0aW9uKHJlYXNvbil7XG4gICAgLy8gc29tZXRoaW5nIHdlbnQgd3JvbmdcbiAgfSk7XG4gIGBgYFxuICAgQG1ldGhvZCB0aGVuXG4gIEBwYXJhbSB7RnVuY3Rpb259IG9uRnVsZmlsbGVkXG4gIEBwYXJhbSB7RnVuY3Rpb259IG9uUmVqZWN0ZWRcbiAgVXNlZnVsIGZvciB0b29saW5nLlxuICBAcmV0dXJuIHtQcm9taXNlfVxuICAqL1xuXG4gIC8qKlxuICBgY2F0Y2hgIGlzIHNpbXBseSBzdWdhciBmb3IgYHRoZW4odW5kZWZpbmVkLCBvblJlamVjdGlvbilgIHdoaWNoIG1ha2VzIGl0IHRoZSBzYW1lXG4gIGFzIHRoZSBjYXRjaCBibG9jayBvZiBhIHRyeS9jYXRjaCBzdGF0ZW1lbnQuXG4gIGBgYGpzXG4gIGZ1bmN0aW9uIGZpbmRBdXRob3IoKXtcbiAgdGhyb3cgbmV3IEVycm9yKCdjb3VsZG4ndCBmaW5kIHRoYXQgYXV0aG9yJyk7XG4gIH1cbiAgLy8gc3luY2hyb25vdXNcbiAgdHJ5IHtcbiAgZmluZEF1dGhvcigpO1xuICB9IGNhdGNoKHJlYXNvbikge1xuICAvLyBzb21ldGhpbmcgd2VudCB3cm9uZ1xuICB9XG4gIC8vIGFzeW5jIHdpdGggcHJvbWlzZXNcbiAgZmluZEF1dGhvcigpLmNhdGNoKGZ1bmN0aW9uKHJlYXNvbil7XG4gIC8vIHNvbWV0aGluZyB3ZW50IHdyb25nXG4gIH0pO1xuICBgYGBcbiAgQG1ldGhvZCBjYXRjaFxuICBAcGFyYW0ge0Z1bmN0aW9ufSBvblJlamVjdGlvblxuICBVc2VmdWwgZm9yIHRvb2xpbmcuXG4gIEByZXR1cm4ge1Byb21pc2V9XG4gICovXG5cblxuICBQcm9taXNlLnByb3RvdHlwZS5jYXRjaCA9IGZ1bmN0aW9uIF9jYXRjaChvblJlamVjdGlvbikge1xuICAgIHJldHVybiB0aGlzLnRoZW4obnVsbCwgb25SZWplY3Rpb24pO1xuICB9O1xuXG4gIC8qKlxuICAgIGBmaW5hbGx5YCB3aWxsIGJlIGludm9rZWQgcmVnYXJkbGVzcyBvZiB0aGUgcHJvbWlzZSdzIGZhdGUganVzdCBhcyBuYXRpdmVcbiAgICB0cnkvY2F0Y2gvZmluYWxseSBiZWhhdmVzXG4gIFxuICAgIFN5bmNocm9ub3VzIGV4YW1wbGU6XG4gIFxuICAgIGBgYGpzXG4gICAgZmluZEF1dGhvcigpIHtcbiAgICAgIGlmIChNYXRoLnJhbmRvbSgpID4gMC41KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBBdXRob3IoKTtcbiAgICB9XG4gIFxuICAgIHRyeSB7XG4gICAgICByZXR1cm4gZmluZEF1dGhvcigpOyAvLyBzdWNjZWVkIG9yIGZhaWxcbiAgICB9IGNhdGNoKGVycm9yKSB7XG4gICAgICByZXR1cm4gZmluZE90aGVyQXV0aGVyKCk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIC8vIGFsd2F5cyBydW5zXG4gICAgICAvLyBkb2Vzbid0IGFmZmVjdCB0aGUgcmV0dXJuIHZhbHVlXG4gICAgfVxuICAgIGBgYFxuICBcbiAgICBBc3luY2hyb25vdXMgZXhhbXBsZTpcbiAgXG4gICAgYGBganNcbiAgICBmaW5kQXV0aG9yKCkuY2F0Y2goZnVuY3Rpb24ocmVhc29uKXtcbiAgICAgIHJldHVybiBmaW5kT3RoZXJBdXRoZXIoKTtcbiAgICB9KS5maW5hbGx5KGZ1bmN0aW9uKCl7XG4gICAgICAvLyBhdXRob3Igd2FzIGVpdGhlciBmb3VuZCwgb3Igbm90XG4gICAgfSk7XG4gICAgYGBgXG4gIFxuICAgIEBtZXRob2QgZmluYWxseVxuICAgIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAgQHJldHVybiB7UHJvbWlzZX1cbiAgKi9cblxuXG4gIFByb21pc2UucHJvdG90eXBlLmZpbmFsbHkgPSBmdW5jdGlvbiBfZmluYWxseShjYWxsYmFjaykge1xuICAgIHZhciBwcm9taXNlID0gdGhpcztcbiAgICB2YXIgY29uc3RydWN0b3IgPSBwcm9taXNlLmNvbnN0cnVjdG9yO1xuXG4gICAgaWYgKGlzRnVuY3Rpb24oY2FsbGJhY2spKSB7XG4gICAgICByZXR1cm4gcHJvbWlzZS50aGVuKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gY29uc3RydWN0b3IucmVzb2x2ZShjYWxsYmFjaygpKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH0pO1xuICAgICAgfSwgZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgICByZXR1cm4gY29uc3RydWN0b3IucmVzb2x2ZShjYWxsYmFjaygpKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB0aHJvdyByZWFzb247XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHByb21pc2UudGhlbihjYWxsYmFjaywgY2FsbGJhY2spO1xuICB9O1xuXG4gIHJldHVybiBQcm9taXNlO1xufSgpO1xuXG5Qcm9taXNlJDEucHJvdG90eXBlLnRoZW4gPSB0aGVuO1xuUHJvbWlzZSQxLmFsbCA9IGFsbDtcblByb21pc2UkMS5yYWNlID0gcmFjZTtcblByb21pc2UkMS5yZXNvbHZlID0gcmVzb2x2ZSQxO1xuUHJvbWlzZSQxLnJlamVjdCA9IHJlamVjdCQxO1xuUHJvbWlzZSQxLl9zZXRTY2hlZHVsZXIgPSBzZXRTY2hlZHVsZXI7XG5Qcm9taXNlJDEuX3NldEFzYXAgPSBzZXRBc2FwO1xuUHJvbWlzZSQxLl9hc2FwID0gYXNhcDtcblxuLypnbG9iYWwgc2VsZiovXG5mdW5jdGlvbiBwb2x5ZmlsbCgpIHtcbiAgdmFyIGxvY2FsID0gdm9pZCAwO1xuXG4gIGlmICh0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJykge1xuICAgIGxvY2FsID0gZ2xvYmFsO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJykge1xuICAgIGxvY2FsID0gc2VsZjtcbiAgfSBlbHNlIHtcbiAgICB0cnkge1xuICAgICAgbG9jYWwgPSBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigncG9seWZpbGwgZmFpbGVkIGJlY2F1c2UgZ2xvYmFsIG9iamVjdCBpcyB1bmF2YWlsYWJsZSBpbiB0aGlzIGVudmlyb25tZW50Jyk7XG4gICAgfVxuICB9XG5cbiAgdmFyIFAgPSBsb2NhbC5Qcm9taXNlO1xuXG4gIGlmIChQKSB7XG4gICAgdmFyIHByb21pc2VUb1N0cmluZyA9IG51bGw7XG4gICAgdHJ5IHtcbiAgICAgIHByb21pc2VUb1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChQLnJlc29sdmUoKSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgLy8gc2lsZW50bHkgaWdub3JlZFxuICAgIH1cblxuICAgIGlmIChwcm9taXNlVG9TdHJpbmcgPT09ICdbb2JqZWN0IFByb21pc2VdJyAmJiAhUC5jYXN0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG5cbiAgbG9jYWwuUHJvbWlzZSA9IFByb21pc2UkMTtcbn1cblxuLy8gU3RyYW5nZSBjb21wYXQuLlxuUHJvbWlzZSQxLnBvbHlmaWxsID0gcG9seWZpbGw7XG5Qcm9taXNlJDEuUHJvbWlzZSA9IFByb21pc2UkMTtcblxucmV0dXJuIFByb21pc2UkMTtcblxufSkpKTtcblxuXG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVzNi1wcm9taXNlLm1hcFxuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/es6-promise/dist/es6-promise.js\n");

/***/ }),

/***/ "./node_modules/process/browser.js":
/*!*****************************************!*\
  !*** ./node_modules/process/browser.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qcz9mMjhjIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG4vLyBjYWNoZWQgZnJvbSB3aGF0ZXZlciBnbG9iYWwgaXMgcHJlc2VudCBzbyB0aGF0IHRlc3QgcnVubmVycyB0aGF0IHN0dWIgaXRcbi8vIGRvbid0IGJyZWFrIHRoaW5ncy4gIEJ1dCB3ZSBuZWVkIHRvIHdyYXAgaXQgaW4gYSB0cnkgY2F0Y2ggaW4gY2FzZSBpdCBpc1xuLy8gd3JhcHBlZCBpbiBzdHJpY3QgbW9kZSBjb2RlIHdoaWNoIGRvZXNuJ3QgZGVmaW5lIGFueSBnbG9iYWxzLiAgSXQncyBpbnNpZGUgYVxuLy8gZnVuY3Rpb24gYmVjYXVzZSB0cnkvY2F0Y2hlcyBkZW9wdGltaXplIGluIGNlcnRhaW4gZW5naW5lcy5cblxudmFyIGNhY2hlZFNldFRpbWVvdXQ7XG52YXIgY2FjaGVkQ2xlYXJUaW1lb3V0O1xuXG5mdW5jdGlvbiBkZWZhdWx0U2V0VGltb3V0KCkge1xuICAgIHRocm93IG5ldyBFcnJvcignc2V0VGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuZnVuY3Rpb24gZGVmYXVsdENsZWFyVGltZW91dCAoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjbGVhclRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbihmdW5jdGlvbiAoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBzZXRUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBjbGVhclRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgfVxufSAoKSlcbmZ1bmN0aW9uIHJ1blRpbWVvdXQoZnVuKSB7XG4gICAgaWYgKGNhY2hlZFNldFRpbWVvdXQgPT09IHNldFRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIC8vIGlmIHNldFRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRTZXRUaW1lb3V0ID09PSBkZWZhdWx0U2V0VGltb3V0IHx8ICFjYWNoZWRTZXRUaW1lb3V0KSAmJiBzZXRUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfSBjYXRjaChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbChudWxsLCBmdW4sIDApO1xuICAgICAgICB9IGNhdGNoKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3JcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwodGhpcywgZnVuLCAwKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG59XG5mdW5jdGlvbiBydW5DbGVhclRpbWVvdXQobWFya2VyKSB7XG4gICAgaWYgKGNhY2hlZENsZWFyVGltZW91dCA9PT0gY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIC8vIGlmIGNsZWFyVGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZENsZWFyVGltZW91dCA9PT0gZGVmYXVsdENsZWFyVGltZW91dCB8fCAhY2FjaGVkQ2xlYXJUaW1lb3V0KSAmJiBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0ICB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKG51bGwsIG1hcmtlcik7XG4gICAgICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3IuXG4gICAgICAgICAgICAvLyBTb21lIHZlcnNpb25zIG9mIEkuRS4gaGF2ZSBkaWZmZXJlbnQgcnVsZXMgZm9yIGNsZWFyVGltZW91dCB2cyBzZXRUaW1lb3V0XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwodGhpcywgbWFya2VyKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG5cbn1cbnZhciBxdWV1ZSA9IFtdO1xudmFyIGRyYWluaW5nID0gZmFsc2U7XG52YXIgY3VycmVudFF1ZXVlO1xudmFyIHF1ZXVlSW5kZXggPSAtMTtcblxuZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCkge1xuICAgIGlmICghZHJhaW5pbmcgfHwgIWN1cnJlbnRRdWV1ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgaWYgKGN1cnJlbnRRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgcXVldWUgPSBjdXJyZW50UXVldWUuY29uY2F0KHF1ZXVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgfVxuICAgIGlmIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgZHJhaW5RdWV1ZSgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZHJhaW5RdWV1ZSgpIHtcbiAgICBpZiAoZHJhaW5pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdGltZW91dCA9IHJ1blRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTtcbiAgICBkcmFpbmluZyA9IHRydWU7XG5cbiAgICB2YXIgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIHdoaWxlKGxlbikge1xuICAgICAgICBjdXJyZW50UXVldWUgPSBxdWV1ZTtcbiAgICAgICAgcXVldWUgPSBbXTtcbiAgICAgICAgd2hpbGUgKCsrcXVldWVJbmRleCA8IGxlbikge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRRdWV1ZSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRRdWV1ZVtxdWV1ZUluZGV4XS5ydW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB9XG4gICAgY3VycmVudFF1ZXVlID0gbnVsbDtcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIHJ1bkNsZWFyVGltZW91dCh0aW1lb3V0KTtcbn1cblxucHJvY2Vzcy5uZXh0VGljayA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBxdWV1ZS5wdXNoKG5ldyBJdGVtKGZ1biwgYXJncykpO1xuICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IDEgJiYgIWRyYWluaW5nKSB7XG4gICAgICAgIHJ1blRpbWVvdXQoZHJhaW5RdWV1ZSk7XG4gICAgfVxufTtcblxuLy8gdjggbGlrZXMgcHJlZGljdGlibGUgb2JqZWN0c1xuZnVuY3Rpb24gSXRlbShmdW4sIGFycmF5KSB7XG4gICAgdGhpcy5mdW4gPSBmdW47XG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xufVxuSXRlbS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZnVuLmFwcGx5KG51bGwsIHRoaXMuYXJyYXkpO1xufTtcbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xucHJvY2Vzcy52ZXJzaW9uID0gJyc7IC8vIGVtcHR5IHN0cmluZyB0byBhdm9pZCByZWdleHAgaXNzdWVzXG5wcm9jZXNzLnZlcnNpb25zID0ge307XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5wcm9jZXNzLm9uID0gbm9vcDtcbnByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5vbmNlID0gbm9vcDtcbnByb2Nlc3Mub2ZmID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xucHJvY2Vzcy5lbWl0ID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZE9uY2VMaXN0ZW5lciA9IG5vb3A7XG5cbnByb2Nlc3MubGlzdGVuZXJzID0gZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIFtdIH1cblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcbnByb2Nlc3MudW1hc2sgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/process/browser.js\n");

/***/ }),

/***/ "./node_modules/ts-polyfill/dist/ts-polyfill.js":
/*!******************************************************!*\
  !*** ./node_modules/ts-polyfill/dist/ts-polyfill.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global) {var tsPolyfill = (function () {\n\t'use strict';\n\n\tvar commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};\n\n\tfunction unwrapExports (x) {\n\t\treturn x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;\n\t}\n\n\tfunction createCommonjsModule(fn, module) {\n\t\treturn module = { exports: {} }, fn(module, module.exports), module.exports;\n\t}\n\n\tvar O = 'object';\n\tvar check = function (it) {\n\t  return it && it.Math == Math && it;\n\t};\n\n\t// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028\n\tvar global_1 =\n\t  // eslint-disable-next-line no-undef\n\t  check(typeof globalThis == O && globalThis) ||\n\t  check(typeof window == O && window) ||\n\t  check(typeof self == O && self) ||\n\t  check(typeof commonjsGlobal == O && commonjsGlobal) ||\n\t  // eslint-disable-next-line no-new-func\n\t  Function('return this')();\n\n\tvar fails = function (exec) {\n\t  try {\n\t    return !!exec();\n\t  } catch (error) {\n\t    return true;\n\t  }\n\t};\n\n\t// Thank's IE8 for his funny defineProperty\n\tvar descriptors = !fails(function () {\n\t  return Object.defineProperty({}, 'a', { get: function () { return 7; } }).a != 7;\n\t});\n\n\tvar nativePropertyIsEnumerable = {}.propertyIsEnumerable;\n\tvar getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\n\n\t// Nashorn ~ JDK8 bug\n\tvar NASHORN_BUG = getOwnPropertyDescriptor && !nativePropertyIsEnumerable.call({ 1: 2 }, 1);\n\n\t// `Object.prototype.propertyIsEnumerable` method implementation\n\t// https://tc39.github.io/ecma262/#sec-object.prototype.propertyisenumerable\n\tvar f = NASHORN_BUG ? function propertyIsEnumerable(V) {\n\t  var descriptor = getOwnPropertyDescriptor(this, V);\n\t  return !!descriptor && descriptor.enumerable;\n\t} : nativePropertyIsEnumerable;\n\n\tvar objectPropertyIsEnumerable = {\n\t\tf: f\n\t};\n\n\tvar createPropertyDescriptor = function (bitmap, value) {\n\t  return {\n\t    enumerable: !(bitmap & 1),\n\t    configurable: !(bitmap & 2),\n\t    writable: !(bitmap & 4),\n\t    value: value\n\t  };\n\t};\n\n\tvar toString = {}.toString;\n\n\tvar classofRaw = function (it) {\n\t  return toString.call(it).slice(8, -1);\n\t};\n\n\tvar split = ''.split;\n\n\t// fallback for non-array-like ES3 and non-enumerable old V8 strings\n\tvar indexedObject = fails(function () {\n\t  // throws an error in rhino, see https://github.com/mozilla/rhino/issues/346\n\t  // eslint-disable-next-line no-prototype-builtins\n\t  return !Object('z').propertyIsEnumerable(0);\n\t}) ? function (it) {\n\t  return classofRaw(it) == 'String' ? split.call(it, '') : Object(it);\n\t} : Object;\n\n\t// `RequireObjectCoercible` abstract operation\n\t// https://tc39.github.io/ecma262/#sec-requireobjectcoercible\n\tvar requireObjectCoercible = function (it) {\n\t  if (it == undefined) throw TypeError(\"Can't call method on \" + it);\n\t  return it;\n\t};\n\n\t// toObject with fallback for non-array-like ES3 strings\n\n\n\n\tvar toIndexedObject = function (it) {\n\t  return indexedObject(requireObjectCoercible(it));\n\t};\n\n\tvar isObject = function (it) {\n\t  return typeof it === 'object' ? it !== null : typeof it === 'function';\n\t};\n\n\t// `ToPrimitive` abstract operation\n\t// https://tc39.github.io/ecma262/#sec-toprimitive\n\t// instead of the ES6 spec version, we didn't implement @@toPrimitive case\n\t// and the second argument - flag - preferred type is a string\n\tvar toPrimitive = function (input, PREFERRED_STRING) {\n\t  if (!isObject(input)) return input;\n\t  var fn, val;\n\t  if (PREFERRED_STRING && typeof (fn = input.toString) == 'function' && !isObject(val = fn.call(input))) return val;\n\t  if (typeof (fn = input.valueOf) == 'function' && !isObject(val = fn.call(input))) return val;\n\t  if (!PREFERRED_STRING && typeof (fn = input.toString) == 'function' && !isObject(val = fn.call(input))) return val;\n\t  throw TypeError(\"Can't convert object to primitive value\");\n\t};\n\n\tvar hasOwnProperty = {}.hasOwnProperty;\n\n\tvar has = function (it, key) {\n\t  return hasOwnProperty.call(it, key);\n\t};\n\n\tvar document$1 = global_1.document;\n\t// typeof document.createElement is 'object' in old IE\n\tvar EXISTS = isObject(document$1) && isObject(document$1.createElement);\n\n\tvar documentCreateElement = function (it) {\n\t  return EXISTS ? document$1.createElement(it) : {};\n\t};\n\n\t// Thank's IE8 for his funny defineProperty\n\tvar ie8DomDefine = !descriptors && !fails(function () {\n\t  return Object.defineProperty(documentCreateElement('div'), 'a', {\n\t    get: function () { return 7; }\n\t  }).a != 7;\n\t});\n\n\tvar nativeGetOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\n\n\t// `Object.getOwnPropertyDescriptor` method\n\t// https://tc39.github.io/ecma262/#sec-object.getownpropertydescriptor\n\tvar f$1 = descriptors ? nativeGetOwnPropertyDescriptor : function getOwnPropertyDescriptor(O, P) {\n\t  O = toIndexedObject(O);\n\t  P = toPrimitive(P, true);\n\t  if (ie8DomDefine) try {\n\t    return nativeGetOwnPropertyDescriptor(O, P);\n\t  } catch (error) { /* empty */ }\n\t  if (has(O, P)) return createPropertyDescriptor(!objectPropertyIsEnumerable.f.call(O, P), O[P]);\n\t};\n\n\tvar objectGetOwnPropertyDescriptor = {\n\t\tf: f$1\n\t};\n\n\tvar anObject = function (it) {\n\t  if (!isObject(it)) {\n\t    throw TypeError(String(it) + ' is not an object');\n\t  } return it;\n\t};\n\n\tvar nativeDefineProperty = Object.defineProperty;\n\n\t// `Object.defineProperty` method\n\t// https://tc39.github.io/ecma262/#sec-object.defineproperty\n\tvar f$2 = descriptors ? nativeDefineProperty : function defineProperty(O, P, Attributes) {\n\t  anObject(O);\n\t  P = toPrimitive(P, true);\n\t  anObject(Attributes);\n\t  if (ie8DomDefine) try {\n\t    return nativeDefineProperty(O, P, Attributes);\n\t  } catch (error) { /* empty */ }\n\t  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported');\n\t  if ('value' in Attributes) O[P] = Attributes.value;\n\t  return O;\n\t};\n\n\tvar objectDefineProperty = {\n\t\tf: f$2\n\t};\n\n\tvar hide = descriptors ? function (object, key, value) {\n\t  return objectDefineProperty.f(object, key, createPropertyDescriptor(1, value));\n\t} : function (object, key, value) {\n\t  object[key] = value;\n\t  return object;\n\t};\n\n\tvar setGlobal = function (key, value) {\n\t  try {\n\t    hide(global_1, key, value);\n\t  } catch (error) {\n\t    global_1[key] = value;\n\t  } return value;\n\t};\n\n\tvar isPure = false;\n\n\tvar shared = createCommonjsModule(function (module) {\n\tvar SHARED = '__core-js_shared__';\n\tvar store = global_1[SHARED] || setGlobal(SHARED, {});\n\n\t(module.exports = function (key, value) {\n\t  return store[key] || (store[key] = value !== undefined ? value : {});\n\t})('versions', []).push({\n\t  version: '3.2.1',\n\t  mode:  'global',\n\t  copyright: ' 2019 Denis Pushkarev (zloirock.ru)'\n\t});\n\t});\n\n\tvar functionToString = shared('native-function-to-string', Function.toString);\n\n\tvar WeakMap = global_1.WeakMap;\n\n\tvar nativeWeakMap = typeof WeakMap === 'function' && /native code/.test(functionToString.call(WeakMap));\n\n\tvar id = 0;\n\tvar postfix = Math.random();\n\n\tvar uid = function (key) {\n\t  return 'Symbol(' + String(key === undefined ? '' : key) + ')_' + (++id + postfix).toString(36);\n\t};\n\n\tvar keys = shared('keys');\n\n\tvar sharedKey = function (key) {\n\t  return keys[key] || (keys[key] = uid(key));\n\t};\n\n\tvar hiddenKeys = {};\n\n\tvar WeakMap$1 = global_1.WeakMap;\n\tvar set, get, has$1;\n\n\tvar enforce = function (it) {\n\t  return has$1(it) ? get(it) : set(it, {});\n\t};\n\n\tvar getterFor = function (TYPE) {\n\t  return function (it) {\n\t    var state;\n\t    if (!isObject(it) || (state = get(it)).type !== TYPE) {\n\t      throw TypeError('Incompatible receiver, ' + TYPE + ' required');\n\t    } return state;\n\t  };\n\t};\n\n\tif (nativeWeakMap) {\n\t  var store = new WeakMap$1();\n\t  var wmget = store.get;\n\t  var wmhas = store.has;\n\t  var wmset = store.set;\n\t  set = function (it, metadata) {\n\t    wmset.call(store, it, metadata);\n\t    return metadata;\n\t  };\n\t  get = function (it) {\n\t    return wmget.call(store, it) || {};\n\t  };\n\t  has$1 = function (it) {\n\t    return wmhas.call(store, it);\n\t  };\n\t} else {\n\t  var STATE = sharedKey('state');\n\t  hiddenKeys[STATE] = true;\n\t  set = function (it, metadata) {\n\t    hide(it, STATE, metadata);\n\t    return metadata;\n\t  };\n\t  get = function (it) {\n\t    return has(it, STATE) ? it[STATE] : {};\n\t  };\n\t  has$1 = function (it) {\n\t    return has(it, STATE);\n\t  };\n\t}\n\n\tvar internalState = {\n\t  set: set,\n\t  get: get,\n\t  has: has$1,\n\t  enforce: enforce,\n\t  getterFor: getterFor\n\t};\n\n\tvar redefine = createCommonjsModule(function (module) {\n\tvar getInternalState = internalState.get;\n\tvar enforceInternalState = internalState.enforce;\n\tvar TEMPLATE = String(functionToString).split('toString');\n\n\tshared('inspectSource', function (it) {\n\t  return functionToString.call(it);\n\t});\n\n\t(module.exports = function (O, key, value, options) {\n\t  var unsafe = options ? !!options.unsafe : false;\n\t  var simple = options ? !!options.enumerable : false;\n\t  var noTargetGet = options ? !!options.noTargetGet : false;\n\t  if (typeof value == 'function') {\n\t    if (typeof key == 'string' && !has(value, 'name')) hide(value, 'name', key);\n\t    enforceInternalState(value).source = TEMPLATE.join(typeof key == 'string' ? key : '');\n\t  }\n\t  if (O === global_1) {\n\t    if (simple) O[key] = value;\n\t    else setGlobal(key, value);\n\t    return;\n\t  } else if (!unsafe) {\n\t    delete O[key];\n\t  } else if (!noTargetGet && O[key]) {\n\t    simple = true;\n\t  }\n\t  if (simple) O[key] = value;\n\t  else hide(O, key, value);\n\t// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative\n\t})(Function.prototype, 'toString', function toString() {\n\t  return typeof this == 'function' && getInternalState(this).source || functionToString.call(this);\n\t});\n\t});\n\n\tvar path = global_1;\n\n\tvar aFunction = function (variable) {\n\t  return typeof variable == 'function' ? variable : undefined;\n\t};\n\n\tvar getBuiltIn = function (namespace, method) {\n\t  return arguments.length < 2 ? aFunction(path[namespace]) || aFunction(global_1[namespace])\n\t    : path[namespace] && path[namespace][method] || global_1[namespace] && global_1[namespace][method];\n\t};\n\n\tvar ceil = Math.ceil;\n\tvar floor = Math.floor;\n\n\t// `ToInteger` abstract operation\n\t// https://tc39.github.io/ecma262/#sec-tointeger\n\tvar toInteger = function (argument) {\n\t  return isNaN(argument = +argument) ? 0 : (argument > 0 ? floor : ceil)(argument);\n\t};\n\n\tvar min = Math.min;\n\n\t// `ToLength` abstract operation\n\t// https://tc39.github.io/ecma262/#sec-tolength\n\tvar toLength = function (argument) {\n\t  return argument > 0 ? min(toInteger(argument), 0x1FFFFFFFFFFFFF) : 0; // 2 ** 53 - 1 == 9007199254740991\n\t};\n\n\tvar max = Math.max;\n\tvar min$1 = Math.min;\n\n\t// Helper for a popular repeating case of the spec:\n\t// Let integer be ? ToInteger(index).\n\t// If integer < 0, let result be max((length + integer), 0); else let result be min(length, length).\n\tvar toAbsoluteIndex = function (index, length) {\n\t  var integer = toInteger(index);\n\t  return integer < 0 ? max(integer + length, 0) : min$1(integer, length);\n\t};\n\n\t// `Array.prototype.{ indexOf, includes }` methods implementation\n\tvar createMethod = function (IS_INCLUDES) {\n\t  return function ($this, el, fromIndex) {\n\t    var O = toIndexedObject($this);\n\t    var length = toLength(O.length);\n\t    var index = toAbsoluteIndex(fromIndex, length);\n\t    var value;\n\t    // Array#includes uses SameValueZero equality algorithm\n\t    // eslint-disable-next-line no-self-compare\n\t    if (IS_INCLUDES && el != el) while (length > index) {\n\t      value = O[index++];\n\t      // eslint-disable-next-line no-self-compare\n\t      if (value != value) return true;\n\t    // Array#indexOf ignores holes, Array#includes - not\n\t    } else for (;length > index; index++) {\n\t      if ((IS_INCLUDES || index in O) && O[index] === el) return IS_INCLUDES || index || 0;\n\t    } return !IS_INCLUDES && -1;\n\t  };\n\t};\n\n\tvar arrayIncludes = {\n\t  // `Array.prototype.includes` method\n\t  // https://tc39.github.io/ecma262/#sec-array.prototype.includes\n\t  includes: createMethod(true),\n\t  // `Array.prototype.indexOf` method\n\t  // https://tc39.github.io/ecma262/#sec-array.prototype.indexof\n\t  indexOf: createMethod(false)\n\t};\n\n\tvar indexOf = arrayIncludes.indexOf;\n\n\n\tvar objectKeysInternal = function (object, names) {\n\t  var O = toIndexedObject(object);\n\t  var i = 0;\n\t  var result = [];\n\t  var key;\n\t  for (key in O) !has(hiddenKeys, key) && has(O, key) && result.push(key);\n\t  // Don't enum bug & hidden keys\n\t  while (names.length > i) if (has(O, key = names[i++])) {\n\t    ~indexOf(result, key) || result.push(key);\n\t  }\n\t  return result;\n\t};\n\n\t// IE8- don't enum bug keys\n\tvar enumBugKeys = [\n\t  'constructor',\n\t  'hasOwnProperty',\n\t  'isPrototypeOf',\n\t  'propertyIsEnumerable',\n\t  'toLocaleString',\n\t  'toString',\n\t  'valueOf'\n\t];\n\n\tvar hiddenKeys$1 = enumBugKeys.concat('length', 'prototype');\n\n\t// `Object.getOwnPropertyNames` method\n\t// https://tc39.github.io/ecma262/#sec-object.getownpropertynames\n\tvar f$3 = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {\n\t  return objectKeysInternal(O, hiddenKeys$1);\n\t};\n\n\tvar objectGetOwnPropertyNames = {\n\t\tf: f$3\n\t};\n\n\tvar f$4 = Object.getOwnPropertySymbols;\n\n\tvar objectGetOwnPropertySymbols = {\n\t\tf: f$4\n\t};\n\n\t// all object keys, includes non-enumerable and symbols\n\tvar ownKeys = getBuiltIn('Reflect', 'ownKeys') || function ownKeys(it) {\n\t  var keys = objectGetOwnPropertyNames.f(anObject(it));\n\t  var getOwnPropertySymbols = objectGetOwnPropertySymbols.f;\n\t  return getOwnPropertySymbols ? keys.concat(getOwnPropertySymbols(it)) : keys;\n\t};\n\n\tvar copyConstructorProperties = function (target, source) {\n\t  var keys = ownKeys(source);\n\t  var defineProperty = objectDefineProperty.f;\n\t  var getOwnPropertyDescriptor = objectGetOwnPropertyDescriptor.f;\n\t  for (var i = 0; i < keys.length; i++) {\n\t    var key = keys[i];\n\t    if (!has(target, key)) defineProperty(target, key, getOwnPropertyDescriptor(source, key));\n\t  }\n\t};\n\n\tvar replacement = /#|\\.prototype\\./;\n\n\tvar isForced = function (feature, detection) {\n\t  var value = data[normalize(feature)];\n\t  return value == POLYFILL ? true\n\t    : value == NATIVE ? false\n\t    : typeof detection == 'function' ? fails(detection)\n\t    : !!detection;\n\t};\n\n\tvar normalize = isForced.normalize = function (string) {\n\t  return String(string).replace(replacement, '.').toLowerCase();\n\t};\n\n\tvar data = isForced.data = {};\n\tvar NATIVE = isForced.NATIVE = 'N';\n\tvar POLYFILL = isForced.POLYFILL = 'P';\n\n\tvar isForced_1 = isForced;\n\n\tvar getOwnPropertyDescriptor$1 = objectGetOwnPropertyDescriptor.f;\n\n\n\n\n\n\n\t/*\n\t  options.target      - name of the target object\n\t  options.global      - target is the global object\n\t  options.stat        - export as static methods of target\n\t  options.proto       - export as prototype methods of target\n\t  options.real        - real prototype method for the `pure` version\n\t  options.forced      - export even if the native feature is available\n\t  options.bind        - bind methods to the target, required for the `pure` version\n\t  options.wrap        - wrap constructors to preventing global pollution, required for the `pure` version\n\t  options.unsafe      - use the simple assignment of property instead of delete + defineProperty\n\t  options.sham        - add a flag to not completely full polyfills\n\t  options.enumerable  - export as enumerable property\n\t  options.noTargetGet - prevent calling a getter on target\n\t*/\n\tvar _export = function (options, source) {\n\t  var TARGET = options.target;\n\t  var GLOBAL = options.global;\n\t  var STATIC = options.stat;\n\t  var FORCED, target, key, targetProperty, sourceProperty, descriptor;\n\t  if (GLOBAL) {\n\t    target = global_1;\n\t  } else if (STATIC) {\n\t    target = global_1[TARGET] || setGlobal(TARGET, {});\n\t  } else {\n\t    target = (global_1[TARGET] || {}).prototype;\n\t  }\n\t  if (target) for (key in source) {\n\t    sourceProperty = source[key];\n\t    if (options.noTargetGet) {\n\t      descriptor = getOwnPropertyDescriptor$1(target, key);\n\t      targetProperty = descriptor && descriptor.value;\n\t    } else targetProperty = target[key];\n\t    FORCED = isForced_1(GLOBAL ? key : TARGET + (STATIC ? '.' : '#') + key, options.forced);\n\t    // contained in target\n\t    if (!FORCED && targetProperty !== undefined) {\n\t      if (typeof sourceProperty === typeof targetProperty) continue;\n\t      copyConstructorProperties(sourceProperty, targetProperty);\n\t    }\n\t    // add a flag to not completely full polyfills\n\t    if (options.sham || (targetProperty && targetProperty.sham)) {\n\t      hide(sourceProperty, 'sham', true);\n\t    }\n\t    // extend global\n\t    redefine(target, key, sourceProperty, options);\n\t  }\n\t};\n\n\tvar freezing = !fails(function () {\n\t  return Object.isExtensible(Object.preventExtensions({}));\n\t});\n\n\tvar internalMetadata = createCommonjsModule(function (module) {\n\tvar defineProperty = objectDefineProperty.f;\n\n\n\n\tvar METADATA = uid('meta');\n\tvar id = 0;\n\n\tvar isExtensible = Object.isExtensible || function () {\n\t  return true;\n\t};\n\n\tvar setMetadata = function (it) {\n\t  defineProperty(it, METADATA, { value: {\n\t    objectID: 'O' + ++id, // object ID\n\t    weakData: {}          // weak collections IDs\n\t  } });\n\t};\n\n\tvar fastKey = function (it, create) {\n\t  // return a primitive with prefix\n\t  if (!isObject(it)) return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;\n\t  if (!has(it, METADATA)) {\n\t    // can't set metadata to uncaught frozen object\n\t    if (!isExtensible(it)) return 'F';\n\t    // not necessary to add metadata\n\t    if (!create) return 'E';\n\t    // add missing metadata\n\t    setMetadata(it);\n\t  // return object ID\n\t  } return it[METADATA].objectID;\n\t};\n\n\tvar getWeakData = function (it, create) {\n\t  if (!has(it, METADATA)) {\n\t    // can't set metadata to uncaught frozen object\n\t    if (!isExtensible(it)) return true;\n\t    // not necessary to add metadata\n\t    if (!create) return false;\n\t    // add missing metadata\n\t    setMetadata(it);\n\t  // return the store of weak collections IDs\n\t  } return it[METADATA].weakData;\n\t};\n\n\t// add metadata on freeze-family methods calling\n\tvar onFreeze = function (it) {\n\t  if (freezing && meta.REQUIRED && isExtensible(it) && !has(it, METADATA)) setMetadata(it);\n\t  return it;\n\t};\n\n\tvar meta = module.exports = {\n\t  REQUIRED: false,\n\t  fastKey: fastKey,\n\t  getWeakData: getWeakData,\n\t  onFreeze: onFreeze\n\t};\n\n\thiddenKeys[METADATA] = true;\n\t});\n\tvar internalMetadata_1 = internalMetadata.REQUIRED;\n\tvar internalMetadata_2 = internalMetadata.fastKey;\n\tvar internalMetadata_3 = internalMetadata.getWeakData;\n\tvar internalMetadata_4 = internalMetadata.onFreeze;\n\n\tvar nativeSymbol = !!Object.getOwnPropertySymbols && !fails(function () {\n\t  // Chrome 38 Symbol has incorrect toString conversion\n\t  // eslint-disable-next-line no-undef\n\t  return !String(Symbol());\n\t});\n\n\tvar Symbol$1 = global_1.Symbol;\n\tvar store$1 = shared('wks');\n\n\tvar wellKnownSymbol = function (name) {\n\t  return store$1[name] || (store$1[name] = nativeSymbol && Symbol$1[name]\n\t    || (nativeSymbol ? Symbol$1 : uid)('Symbol.' + name));\n\t};\n\n\tvar iterators = {};\n\n\tvar ITERATOR = wellKnownSymbol('iterator');\n\tvar ArrayPrototype = Array.prototype;\n\n\t// check on default Array iterator\n\tvar isArrayIteratorMethod = function (it) {\n\t  return it !== undefined && (iterators.Array === it || ArrayPrototype[ITERATOR] === it);\n\t};\n\n\tvar aFunction$1 = function (it) {\n\t  if (typeof it != 'function') {\n\t    throw TypeError(String(it) + ' is not a function');\n\t  } return it;\n\t};\n\n\t// optional / simple context binding\n\tvar bindContext = function (fn, that, length) {\n\t  aFunction$1(fn);\n\t  if (that === undefined) return fn;\n\t  switch (length) {\n\t    case 0: return function () {\n\t      return fn.call(that);\n\t    };\n\t    case 1: return function (a) {\n\t      return fn.call(that, a);\n\t    };\n\t    case 2: return function (a, b) {\n\t      return fn.call(that, a, b);\n\t    };\n\t    case 3: return function (a, b, c) {\n\t      return fn.call(that, a, b, c);\n\t    };\n\t  }\n\t  return function (/* ...args */) {\n\t    return fn.apply(that, arguments);\n\t  };\n\t};\n\n\tvar TO_STRING_TAG = wellKnownSymbol('toStringTag');\n\t// ES3 wrong here\n\tvar CORRECT_ARGUMENTS = classofRaw(function () { return arguments; }()) == 'Arguments';\n\n\t// fallback for IE11 Script Access Denied error\n\tvar tryGet = function (it, key) {\n\t  try {\n\t    return it[key];\n\t  } catch (error) { /* empty */ }\n\t};\n\n\t// getting tag from ES6+ `Object.prototype.toString`\n\tvar classof = function (it) {\n\t  var O, tag, result;\n\t  return it === undefined ? 'Undefined' : it === null ? 'Null'\n\t    // @@toStringTag case\n\t    : typeof (tag = tryGet(O = Object(it), TO_STRING_TAG)) == 'string' ? tag\n\t    // builtinTag case\n\t    : CORRECT_ARGUMENTS ? classofRaw(O)\n\t    // ES3 arguments fallback\n\t    : (result = classofRaw(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : result;\n\t};\n\n\tvar ITERATOR$1 = wellKnownSymbol('iterator');\n\n\tvar getIteratorMethod = function (it) {\n\t  if (it != undefined) return it[ITERATOR$1]\n\t    || it['@@iterator']\n\t    || iterators[classof(it)];\n\t};\n\n\t// call something on iterator step with safe closing on error\n\tvar callWithSafeIterationClosing = function (iterator, fn, value, ENTRIES) {\n\t  try {\n\t    return ENTRIES ? fn(anObject(value)[0], value[1]) : fn(value);\n\t  // 7.4.6 IteratorClose(iterator, completion)\n\t  } catch (error) {\n\t    var returnMethod = iterator['return'];\n\t    if (returnMethod !== undefined) anObject(returnMethod.call(iterator));\n\t    throw error;\n\t  }\n\t};\n\n\tvar iterate_1 = createCommonjsModule(function (module) {\n\tvar Result = function (stopped, result) {\n\t  this.stopped = stopped;\n\t  this.result = result;\n\t};\n\n\tvar iterate = module.exports = function (iterable, fn, that, AS_ENTRIES, IS_ITERATOR) {\n\t  var boundFunction = bindContext(fn, that, AS_ENTRIES ? 2 : 1);\n\t  var iterator, iterFn, index, length, result, step;\n\n\t  if (IS_ITERATOR) {\n\t    iterator = iterable;\n\t  } else {\n\t    iterFn = getIteratorMethod(iterable);\n\t    if (typeof iterFn != 'function') throw TypeError('Target is not iterable');\n\t    // optimisation for array iterators\n\t    if (isArrayIteratorMethod(iterFn)) {\n\t      for (index = 0, length = toLength(iterable.length); length > index; index++) {\n\t        result = AS_ENTRIES\n\t          ? boundFunction(anObject(step = iterable[index])[0], step[1])\n\t          : boundFunction(iterable[index]);\n\t        if (result && result instanceof Result) return result;\n\t      } return new Result(false);\n\t    }\n\t    iterator = iterFn.call(iterable);\n\t  }\n\n\t  while (!(step = iterator.next()).done) {\n\t    result = callWithSafeIterationClosing(iterator, boundFunction, step.value, AS_ENTRIES);\n\t    if (result && result instanceof Result) return result;\n\t  } return new Result(false);\n\t};\n\n\titerate.stop = function (result) {\n\t  return new Result(true, result);\n\t};\n\t});\n\n\tvar anInstance = function (it, Constructor, name) {\n\t  if (!(it instanceof Constructor)) {\n\t    throw TypeError('Incorrect ' + (name ? name + ' ' : '') + 'invocation');\n\t  } return it;\n\t};\n\n\tvar ITERATOR$2 = wellKnownSymbol('iterator');\n\tvar SAFE_CLOSING = false;\n\n\ttry {\n\t  var called = 0;\n\t  var iteratorWithReturn = {\n\t    next: function () {\n\t      return { done: !!called++ };\n\t    },\n\t    'return': function () {\n\t      SAFE_CLOSING = true;\n\t    }\n\t  };\n\t  iteratorWithReturn[ITERATOR$2] = function () {\n\t    return this;\n\t  };\n\t  // eslint-disable-next-line no-throw-literal\n\t  Array.from(iteratorWithReturn, function () { throw 2; });\n\t} catch (error) { /* empty */ }\n\n\tvar checkCorrectnessOfIteration = function (exec, SKIP_CLOSING) {\n\t  if (!SKIP_CLOSING && !SAFE_CLOSING) return false;\n\t  var ITERATION_SUPPORT = false;\n\t  try {\n\t    var object = {};\n\t    object[ITERATOR$2] = function () {\n\t      return {\n\t        next: function () {\n\t          return { done: ITERATION_SUPPORT = true };\n\t        }\n\t      };\n\t    };\n\t    exec(object);\n\t  } catch (error) { /* empty */ }\n\t  return ITERATION_SUPPORT;\n\t};\n\n\tvar defineProperty = objectDefineProperty.f;\n\n\n\n\tvar TO_STRING_TAG$1 = wellKnownSymbol('toStringTag');\n\n\tvar setToStringTag = function (it, TAG, STATIC) {\n\t  if (it && !has(it = STATIC ? it : it.prototype, TO_STRING_TAG$1)) {\n\t    defineProperty(it, TO_STRING_TAG$1, { configurable: true, value: TAG });\n\t  }\n\t};\n\n\tvar aPossiblePrototype = function (it) {\n\t  if (!isObject(it) && it !== null) {\n\t    throw TypeError(\"Can't set \" + String(it) + ' as a prototype');\n\t  } return it;\n\t};\n\n\t// `Object.setPrototypeOf` method\n\t// https://tc39.github.io/ecma262/#sec-object.setprototypeof\n\t// Works with __proto__ only. Old v8 can't work with null proto objects.\n\t/* eslint-disable no-proto */\n\tvar objectSetPrototypeOf = Object.setPrototypeOf || ('__proto__' in {} ? function () {\n\t  var CORRECT_SETTER = false;\n\t  var test = {};\n\t  var setter;\n\t  try {\n\t    setter = Object.getOwnPropertyDescriptor(Object.prototype, '__proto__').set;\n\t    setter.call(test, []);\n\t    CORRECT_SETTER = test instanceof Array;\n\t  } catch (error) { /* empty */ }\n\t  return function setPrototypeOf(O, proto) {\n\t    anObject(O);\n\t    aPossiblePrototype(proto);\n\t    if (CORRECT_SETTER) setter.call(O, proto);\n\t    else O.__proto__ = proto;\n\t    return O;\n\t  };\n\t}() : undefined);\n\n\t// makes subclassing work correct for wrapped built-ins\n\tvar inheritIfRequired = function ($this, dummy, Wrapper) {\n\t  var NewTarget, NewTargetPrototype;\n\t  if (\n\t    // it can work only with native `setPrototypeOf`\n\t    objectSetPrototypeOf &&\n\t    // we haven't completely correct pre-ES6 way for getting `new.target`, so use this\n\t    typeof (NewTarget = dummy.constructor) == 'function' &&\n\t    NewTarget !== Wrapper &&\n\t    isObject(NewTargetPrototype = NewTarget.prototype) &&\n\t    NewTargetPrototype !== Wrapper.prototype\n\t  ) objectSetPrototypeOf($this, NewTargetPrototype);\n\t  return $this;\n\t};\n\n\tvar collection = function (CONSTRUCTOR_NAME, wrapper, common, IS_MAP, IS_WEAK) {\n\t  var NativeConstructor = global_1[CONSTRUCTOR_NAME];\n\t  var NativePrototype = NativeConstructor && NativeConstructor.prototype;\n\t  var Constructor = NativeConstructor;\n\t  var ADDER = IS_MAP ? 'set' : 'add';\n\t  var exported = {};\n\n\t  var fixMethod = function (KEY) {\n\t    var nativeMethod = NativePrototype[KEY];\n\t    redefine(NativePrototype, KEY,\n\t      KEY == 'add' ? function add(value) {\n\t        nativeMethod.call(this, value === 0 ? 0 : value);\n\t        return this;\n\t      } : KEY == 'delete' ? function (key) {\n\t        return IS_WEAK && !isObject(key) ? false : nativeMethod.call(this, key === 0 ? 0 : key);\n\t      } : KEY == 'get' ? function get(key) {\n\t        return IS_WEAK && !isObject(key) ? undefined : nativeMethod.call(this, key === 0 ? 0 : key);\n\t      } : KEY == 'has' ? function has(key) {\n\t        return IS_WEAK && !isObject(key) ? false : nativeMethod.call(this, key === 0 ? 0 : key);\n\t      } : function set(key, value) {\n\t        nativeMethod.call(this, key === 0 ? 0 : key, value);\n\t        return this;\n\t      }\n\t    );\n\t  };\n\n\t  // eslint-disable-next-line max-len\n\t  if (isForced_1(CONSTRUCTOR_NAME, typeof NativeConstructor != 'function' || !(IS_WEAK || NativePrototype.forEach && !fails(function () {\n\t    new NativeConstructor().entries().next();\n\t  })))) {\n\t    // create collection constructor\n\t    Constructor = common.getConstructor(wrapper, CONSTRUCTOR_NAME, IS_MAP, ADDER);\n\t    internalMetadata.REQUIRED = true;\n\t  } else if (isForced_1(CONSTRUCTOR_NAME, true)) {\n\t    var instance = new Constructor();\n\t    // early implementations not supports chaining\n\t    var HASNT_CHAINING = instance[ADDER](IS_WEAK ? {} : -0, 1) != instance;\n\t    // V8 ~ Chromium 40- weak-collections throws on primitives, but should return false\n\t    var THROWS_ON_PRIMITIVES = fails(function () { instance.has(1); });\n\t    // most early implementations doesn't supports iterables, most modern - not close it correctly\n\t    // eslint-disable-next-line no-new\n\t    var ACCEPT_ITERABLES = checkCorrectnessOfIteration(function (iterable) { new NativeConstructor(iterable); });\n\t    // for early implementations -0 and +0 not the same\n\t    var BUGGY_ZERO = !IS_WEAK && fails(function () {\n\t      // V8 ~ Chromium 42- fails only with 5+ elements\n\t      var $instance = new NativeConstructor();\n\t      var index = 5;\n\t      while (index--) $instance[ADDER](index, index);\n\t      return !$instance.has(-0);\n\t    });\n\n\t    if (!ACCEPT_ITERABLES) {\n\t      Constructor = wrapper(function (dummy, iterable) {\n\t        anInstance(dummy, Constructor, CONSTRUCTOR_NAME);\n\t        var that = inheritIfRequired(new NativeConstructor(), dummy, Constructor);\n\t        if (iterable != undefined) iterate_1(iterable, that[ADDER], that, IS_MAP);\n\t        return that;\n\t      });\n\t      Constructor.prototype = NativePrototype;\n\t      NativePrototype.constructor = Constructor;\n\t    }\n\n\t    if (THROWS_ON_PRIMITIVES || BUGGY_ZERO) {\n\t      fixMethod('delete');\n\t      fixMethod('has');\n\t      IS_MAP && fixMethod('get');\n\t    }\n\n\t    if (BUGGY_ZERO || HASNT_CHAINING) fixMethod(ADDER);\n\n\t    // weak collections should not contains .clear method\n\t    if (IS_WEAK && NativePrototype.clear) delete NativePrototype.clear;\n\t  }\n\n\t  exported[CONSTRUCTOR_NAME] = Constructor;\n\t  _export({ global: true, forced: Constructor != NativeConstructor }, exported);\n\n\t  setToStringTag(Constructor, CONSTRUCTOR_NAME);\n\n\t  if (!IS_WEAK) common.setStrong(Constructor, CONSTRUCTOR_NAME, IS_MAP);\n\n\t  return Constructor;\n\t};\n\n\t// `Object.keys` method\n\t// https://tc39.github.io/ecma262/#sec-object.keys\n\tvar objectKeys = Object.keys || function keys(O) {\n\t  return objectKeysInternal(O, enumBugKeys);\n\t};\n\n\t// `Object.defineProperties` method\n\t// https://tc39.github.io/ecma262/#sec-object.defineproperties\n\tvar objectDefineProperties = descriptors ? Object.defineProperties : function defineProperties(O, Properties) {\n\t  anObject(O);\n\t  var keys = objectKeys(Properties);\n\t  var length = keys.length;\n\t  var index = 0;\n\t  var key;\n\t  while (length > index) objectDefineProperty.f(O, key = keys[index++], Properties[key]);\n\t  return O;\n\t};\n\n\tvar html = getBuiltIn('document', 'documentElement');\n\n\tvar IE_PROTO = sharedKey('IE_PROTO');\n\n\tvar PROTOTYPE = 'prototype';\n\tvar Empty = function () { /* empty */ };\n\n\t// Create object with fake `null` prototype: use iframe Object with cleared prototype\n\tvar createDict = function () {\n\t  // Thrash, waste and sodomy: IE GC bug\n\t  var iframe = documentCreateElement('iframe');\n\t  var length = enumBugKeys.length;\n\t  var lt = '<';\n\t  var script = 'script';\n\t  var gt = '>';\n\t  var js = 'java' + script + ':';\n\t  var iframeDocument;\n\t  iframe.style.display = 'none';\n\t  html.appendChild(iframe);\n\t  iframe.src = String(js);\n\t  iframeDocument = iframe.contentWindow.document;\n\t  iframeDocument.open();\n\t  iframeDocument.write(lt + script + gt + 'document.F=Object' + lt + '/' + script + gt);\n\t  iframeDocument.close();\n\t  createDict = iframeDocument.F;\n\t  while (length--) delete createDict[PROTOTYPE][enumBugKeys[length]];\n\t  return createDict();\n\t};\n\n\t// `Object.create` method\n\t// https://tc39.github.io/ecma262/#sec-object.create\n\tvar objectCreate = Object.create || function create(O, Properties) {\n\t  var result;\n\t  if (O !== null) {\n\t    Empty[PROTOTYPE] = anObject(O);\n\t    result = new Empty();\n\t    Empty[PROTOTYPE] = null;\n\t    // add \"__proto__\" for Object.getPrototypeOf polyfill\n\t    result[IE_PROTO] = O;\n\t  } else result = createDict();\n\t  return Properties === undefined ? result : objectDefineProperties(result, Properties);\n\t};\n\n\thiddenKeys[IE_PROTO] = true;\n\n\tvar redefineAll = function (target, src, options) {\n\t  for (var key in src) redefine(target, key, src[key], options);\n\t  return target;\n\t};\n\n\t// `ToObject` abstract operation\n\t// https://tc39.github.io/ecma262/#sec-toobject\n\tvar toObject = function (argument) {\n\t  return Object(requireObjectCoercible(argument));\n\t};\n\n\tvar correctPrototypeGetter = !fails(function () {\n\t  function F() { /* empty */ }\n\t  F.prototype.constructor = null;\n\t  return Object.getPrototypeOf(new F()) !== F.prototype;\n\t});\n\n\tvar IE_PROTO$1 = sharedKey('IE_PROTO');\n\tvar ObjectPrototype = Object.prototype;\n\n\t// `Object.getPrototypeOf` method\n\t// https://tc39.github.io/ecma262/#sec-object.getprototypeof\n\tvar objectGetPrototypeOf = correctPrototypeGetter ? Object.getPrototypeOf : function (O) {\n\t  O = toObject(O);\n\t  if (has(O, IE_PROTO$1)) return O[IE_PROTO$1];\n\t  if (typeof O.constructor == 'function' && O instanceof O.constructor) {\n\t    return O.constructor.prototype;\n\t  } return O instanceof Object ? ObjectPrototype : null;\n\t};\n\n\tvar ITERATOR$3 = wellKnownSymbol('iterator');\n\tvar BUGGY_SAFARI_ITERATORS = false;\n\n\tvar returnThis = function () { return this; };\n\n\t// `%IteratorPrototype%` object\n\t// https://tc39.github.io/ecma262/#sec-%iteratorprototype%-object\n\tvar IteratorPrototype, PrototypeOfArrayIteratorPrototype, arrayIterator;\n\n\tif ([].keys) {\n\t  arrayIterator = [].keys();\n\t  // Safari 8 has buggy iterators w/o `next`\n\t  if (!('next' in arrayIterator)) BUGGY_SAFARI_ITERATORS = true;\n\t  else {\n\t    PrototypeOfArrayIteratorPrototype = objectGetPrototypeOf(objectGetPrototypeOf(arrayIterator));\n\t    if (PrototypeOfArrayIteratorPrototype !== Object.prototype) IteratorPrototype = PrototypeOfArrayIteratorPrototype;\n\t  }\n\t}\n\n\tif (IteratorPrototype == undefined) IteratorPrototype = {};\n\n\t// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()\n\tif ( !has(IteratorPrototype, ITERATOR$3)) hide(IteratorPrototype, ITERATOR$3, returnThis);\n\n\tvar iteratorsCore = {\n\t  IteratorPrototype: IteratorPrototype,\n\t  BUGGY_SAFARI_ITERATORS: BUGGY_SAFARI_ITERATORS\n\t};\n\n\tvar IteratorPrototype$1 = iteratorsCore.IteratorPrototype;\n\n\n\n\n\n\tvar returnThis$1 = function () { return this; };\n\n\tvar createIteratorConstructor = function (IteratorConstructor, NAME, next) {\n\t  var TO_STRING_TAG = NAME + ' Iterator';\n\t  IteratorConstructor.prototype = objectCreate(IteratorPrototype$1, { next: createPropertyDescriptor(1, next) });\n\t  setToStringTag(IteratorConstructor, TO_STRING_TAG, false);\n\t  iterators[TO_STRING_TAG] = returnThis$1;\n\t  return IteratorConstructor;\n\t};\n\n\tvar IteratorPrototype$2 = iteratorsCore.IteratorPrototype;\n\tvar BUGGY_SAFARI_ITERATORS$1 = iteratorsCore.BUGGY_SAFARI_ITERATORS;\n\tvar ITERATOR$4 = wellKnownSymbol('iterator');\n\tvar KEYS = 'keys';\n\tvar VALUES = 'values';\n\tvar ENTRIES = 'entries';\n\n\tvar returnThis$2 = function () { return this; };\n\n\tvar defineIterator = function (Iterable, NAME, IteratorConstructor, next, DEFAULT, IS_SET, FORCED) {\n\t  createIteratorConstructor(IteratorConstructor, NAME, next);\n\n\t  var getIterationMethod = function (KIND) {\n\t    if (KIND === DEFAULT && defaultIterator) return defaultIterator;\n\t    if (!BUGGY_SAFARI_ITERATORS$1 && KIND in IterablePrototype) return IterablePrototype[KIND];\n\t    switch (KIND) {\n\t      case KEYS: return function keys() { return new IteratorConstructor(this, KIND); };\n\t      case VALUES: return function values() { return new IteratorConstructor(this, KIND); };\n\t      case ENTRIES: return function entries() { return new IteratorConstructor(this, KIND); };\n\t    } return function () { return new IteratorConstructor(this); };\n\t  };\n\n\t  var TO_STRING_TAG = NAME + ' Iterator';\n\t  var INCORRECT_VALUES_NAME = false;\n\t  var IterablePrototype = Iterable.prototype;\n\t  var nativeIterator = IterablePrototype[ITERATOR$4]\n\t    || IterablePrototype['@@iterator']\n\t    || DEFAULT && IterablePrototype[DEFAULT];\n\t  var defaultIterator = !BUGGY_SAFARI_ITERATORS$1 && nativeIterator || getIterationMethod(DEFAULT);\n\t  var anyNativeIterator = NAME == 'Array' ? IterablePrototype.entries || nativeIterator : nativeIterator;\n\t  var CurrentIteratorPrototype, methods, KEY;\n\n\t  // fix native\n\t  if (anyNativeIterator) {\n\t    CurrentIteratorPrototype = objectGetPrototypeOf(anyNativeIterator.call(new Iterable()));\n\t    if (IteratorPrototype$2 !== Object.prototype && CurrentIteratorPrototype.next) {\n\t      if ( objectGetPrototypeOf(CurrentIteratorPrototype) !== IteratorPrototype$2) {\n\t        if (objectSetPrototypeOf) {\n\t          objectSetPrototypeOf(CurrentIteratorPrototype, IteratorPrototype$2);\n\t        } else if (typeof CurrentIteratorPrototype[ITERATOR$4] != 'function') {\n\t          hide(CurrentIteratorPrototype, ITERATOR$4, returnThis$2);\n\t        }\n\t      }\n\t      // Set @@toStringTag to native iterators\n\t      setToStringTag(CurrentIteratorPrototype, TO_STRING_TAG, true);\n\t    }\n\t  }\n\n\t  // fix Array#{values, @@iterator}.name in V8 / FF\n\t  if (DEFAULT == VALUES && nativeIterator && nativeIterator.name !== VALUES) {\n\t    INCORRECT_VALUES_NAME = true;\n\t    defaultIterator = function values() { return nativeIterator.call(this); };\n\t  }\n\n\t  // define iterator\n\t  if ( IterablePrototype[ITERATOR$4] !== defaultIterator) {\n\t    hide(IterablePrototype, ITERATOR$4, defaultIterator);\n\t  }\n\t  iterators[NAME] = defaultIterator;\n\n\t  // export additional methods\n\t  if (DEFAULT) {\n\t    methods = {\n\t      values: getIterationMethod(VALUES),\n\t      keys: IS_SET ? defaultIterator : getIterationMethod(KEYS),\n\t      entries: getIterationMethod(ENTRIES)\n\t    };\n\t    if (FORCED) for (KEY in methods) {\n\t      if (BUGGY_SAFARI_ITERATORS$1 || INCORRECT_VALUES_NAME || !(KEY in IterablePrototype)) {\n\t        redefine(IterablePrototype, KEY, methods[KEY]);\n\t      }\n\t    } else _export({ target: NAME, proto: true, forced: BUGGY_SAFARI_ITERATORS$1 || INCORRECT_VALUES_NAME }, methods);\n\t  }\n\n\t  return methods;\n\t};\n\n\tvar SPECIES = wellKnownSymbol('species');\n\n\tvar setSpecies = function (CONSTRUCTOR_NAME) {\n\t  var Constructor = getBuiltIn(CONSTRUCTOR_NAME);\n\t  var defineProperty = objectDefineProperty.f;\n\n\t  if (descriptors && Constructor && !Constructor[SPECIES]) {\n\t    defineProperty(Constructor, SPECIES, {\n\t      configurable: true,\n\t      get: function () { return this; }\n\t    });\n\t  }\n\t};\n\n\tvar defineProperty$1 = objectDefineProperty.f;\n\n\n\n\n\n\n\n\n\tvar fastKey = internalMetadata.fastKey;\n\n\n\tvar setInternalState = internalState.set;\n\tvar internalStateGetterFor = internalState.getterFor;\n\n\tvar collectionStrong = {\n\t  getConstructor: function (wrapper, CONSTRUCTOR_NAME, IS_MAP, ADDER) {\n\t    var C = wrapper(function (that, iterable) {\n\t      anInstance(that, C, CONSTRUCTOR_NAME);\n\t      setInternalState(that, {\n\t        type: CONSTRUCTOR_NAME,\n\t        index: objectCreate(null),\n\t        first: undefined,\n\t        last: undefined,\n\t        size: 0\n\t      });\n\t      if (!descriptors) that.size = 0;\n\t      if (iterable != undefined) iterate_1(iterable, that[ADDER], that, IS_MAP);\n\t    });\n\n\t    var getInternalState = internalStateGetterFor(CONSTRUCTOR_NAME);\n\n\t    var define = function (that, key, value) {\n\t      var state = getInternalState(that);\n\t      var entry = getEntry(that, key);\n\t      var previous, index;\n\t      // change existing entry\n\t      if (entry) {\n\t        entry.value = value;\n\t      // create new entry\n\t      } else {\n\t        state.last = entry = {\n\t          index: index = fastKey(key, true),\n\t          key: key,\n\t          value: value,\n\t          previous: previous = state.last,\n\t          next: undefined,\n\t          removed: false\n\t        };\n\t        if (!state.first) state.first = entry;\n\t        if (previous) previous.next = entry;\n\t        if (descriptors) state.size++;\n\t        else that.size++;\n\t        // add to index\n\t        if (index !== 'F') state.index[index] = entry;\n\t      } return that;\n\t    };\n\n\t    var getEntry = function (that, key) {\n\t      var state = getInternalState(that);\n\t      // fast case\n\t      var index = fastKey(key);\n\t      var entry;\n\t      if (index !== 'F') return state.index[index];\n\t      // frozen object case\n\t      for (entry = state.first; entry; entry = entry.next) {\n\t        if (entry.key == key) return entry;\n\t      }\n\t    };\n\n\t    redefineAll(C.prototype, {\n\t      // 23.1.3.1 Map.prototype.clear()\n\t      // 23.2.3.2 Set.prototype.clear()\n\t      clear: function clear() {\n\t        var that = this;\n\t        var state = getInternalState(that);\n\t        var data = state.index;\n\t        var entry = state.first;\n\t        while (entry) {\n\t          entry.removed = true;\n\t          if (entry.previous) entry.previous = entry.previous.next = undefined;\n\t          delete data[entry.index];\n\t          entry = entry.next;\n\t        }\n\t        state.first = state.last = undefined;\n\t        if (descriptors) state.size = 0;\n\t        else that.size = 0;\n\t      },\n\t      // 23.1.3.3 Map.prototype.delete(key)\n\t      // 23.2.3.4 Set.prototype.delete(value)\n\t      'delete': function (key) {\n\t        var that = this;\n\t        var state = getInternalState(that);\n\t        var entry = getEntry(that, key);\n\t        if (entry) {\n\t          var next = entry.next;\n\t          var prev = entry.previous;\n\t          delete state.index[entry.index];\n\t          entry.removed = true;\n\t          if (prev) prev.next = next;\n\t          if (next) next.previous = prev;\n\t          if (state.first == entry) state.first = next;\n\t          if (state.last == entry) state.last = prev;\n\t          if (descriptors) state.size--;\n\t          else that.size--;\n\t        } return !!entry;\n\t      },\n\t      // 23.2.3.6 Set.prototype.forEach(callbackfn, thisArg = undefined)\n\t      // 23.1.3.5 Map.prototype.forEach(callbackfn, thisArg = undefined)\n\t      forEach: function forEach(callbackfn /* , that = undefined */) {\n\t        var state = getInternalState(this);\n\t        var boundFunction = bindContext(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3);\n\t        var entry;\n\t        while (entry = entry ? entry.next : state.first) {\n\t          boundFunction(entry.value, entry.key, this);\n\t          // revert to the last existing entry\n\t          while (entry && entry.removed) entry = entry.previous;\n\t        }\n\t      },\n\t      // 23.1.3.7 Map.prototype.has(key)\n\t      // 23.2.3.7 Set.prototype.has(value)\n\t      has: function has(key) {\n\t        return !!getEntry(this, key);\n\t      }\n\t    });\n\n\t    redefineAll(C.prototype, IS_MAP ? {\n\t      // 23.1.3.6 Map.prototype.get(key)\n\t      get: function get(key) {\n\t        var entry = getEntry(this, key);\n\t        return entry && entry.value;\n\t      },\n\t      // 23.1.3.9 Map.prototype.set(key, value)\n\t      set: function set(key, value) {\n\t        return define(this, key === 0 ? 0 : key, value);\n\t      }\n\t    } : {\n\t      // 23.2.3.1 Set.prototype.add(value)\n\t      add: function add(value) {\n\t        return define(this, value = value === 0 ? 0 : value, value);\n\t      }\n\t    });\n\t    if (descriptors) defineProperty$1(C.prototype, 'size', {\n\t      get: function () {\n\t        return getInternalState(this).size;\n\t      }\n\t    });\n\t    return C;\n\t  },\n\t  setStrong: function (C, CONSTRUCTOR_NAME, IS_MAP) {\n\t    var ITERATOR_NAME = CONSTRUCTOR_NAME + ' Iterator';\n\t    var getInternalCollectionState = internalStateGetterFor(CONSTRUCTOR_NAME);\n\t    var getInternalIteratorState = internalStateGetterFor(ITERATOR_NAME);\n\t    // add .keys, .values, .entries, [@@iterator]\n\t    // 23.1.3.4, 23.1.3.8, 23.1.3.11, 23.1.3.12, 23.2.3.5, 23.2.3.8, 23.2.3.10, 23.2.3.11\n\t    defineIterator(C, CONSTRUCTOR_NAME, function (iterated, kind) {\n\t      setInternalState(this, {\n\t        type: ITERATOR_NAME,\n\t        target: iterated,\n\t        state: getInternalCollectionState(iterated),\n\t        kind: kind,\n\t        last: undefined\n\t      });\n\t    }, function () {\n\t      var state = getInternalIteratorState(this);\n\t      var kind = state.kind;\n\t      var entry = state.last;\n\t      // revert to the last existing entry\n\t      while (entry && entry.removed) entry = entry.previous;\n\t      // get next entry\n\t      if (!state.target || !(state.last = entry = entry ? entry.next : state.state.first)) {\n\t        // or finish the iteration\n\t        state.target = undefined;\n\t        return { value: undefined, done: true };\n\t      }\n\t      // return step by kind\n\t      if (kind == 'keys') return { value: entry.key, done: false };\n\t      if (kind == 'values') return { value: entry.value, done: false };\n\t      return { value: [entry.key, entry.value], done: false };\n\t    }, IS_MAP ? 'entries' : 'values', !IS_MAP, true);\n\n\t    // add [@@species], 23.1.2.2, 23.2.2.2\n\t    setSpecies(CONSTRUCTOR_NAME);\n\t  }\n\t};\n\n\t// `Map` constructor\n\t// https://tc39.github.io/ecma262/#sec-map-objects\n\tvar es_map = collection('Map', function (get) {\n\t  return function Map() { return get(this, arguments.length ? arguments[0] : undefined); };\n\t}, collectionStrong, true);\n\n\tvar TO_STRING_TAG$2 = wellKnownSymbol('toStringTag');\n\tvar test = {};\n\n\ttest[TO_STRING_TAG$2] = 'z';\n\n\t// `Object.prototype.toString` method implementation\n\t// https://tc39.github.io/ecma262/#sec-object.prototype.tostring\n\tvar objectToString = String(test) !== '[object z]' ? function toString() {\n\t  return '[object ' + classof(this) + ']';\n\t} : test.toString;\n\n\tvar ObjectPrototype$1 = Object.prototype;\n\n\t// `Object.prototype.toString` method\n\t// https://tc39.github.io/ecma262/#sec-object.prototype.tostring\n\tif (objectToString !== ObjectPrototype$1.toString) {\n\t  redefine(ObjectPrototype$1, 'toString', objectToString, { unsafe: true });\n\t}\n\n\t// `String.prototype.{ codePointAt, at }` methods implementation\n\tvar createMethod$1 = function (CONVERT_TO_STRING) {\n\t  return function ($this, pos) {\n\t    var S = String(requireObjectCoercible($this));\n\t    var position = toInteger(pos);\n\t    var size = S.length;\n\t    var first, second;\n\t    if (position < 0 || position >= size) return CONVERT_TO_STRING ? '' : undefined;\n\t    first = S.charCodeAt(position);\n\t    return first < 0xD800 || first > 0xDBFF || position + 1 === size\n\t      || (second = S.charCodeAt(position + 1)) < 0xDC00 || second > 0xDFFF\n\t        ? CONVERT_TO_STRING ? S.charAt(position) : first\n\t        : CONVERT_TO_STRING ? S.slice(position, position + 2) : (first - 0xD800 << 10) + (second - 0xDC00) + 0x10000;\n\t  };\n\t};\n\n\tvar stringMultibyte = {\n\t  // `String.prototype.codePointAt` method\n\t  // https://tc39.github.io/ecma262/#sec-string.prototype.codepointat\n\t  codeAt: createMethod$1(false),\n\t  // `String.prototype.at` method\n\t  // https://github.com/mathiasbynens/String.prototype.at\n\t  charAt: createMethod$1(true)\n\t};\n\n\tvar charAt = stringMultibyte.charAt;\n\n\n\n\tvar STRING_ITERATOR = 'String Iterator';\n\tvar setInternalState$1 = internalState.set;\n\tvar getInternalState = internalState.getterFor(STRING_ITERATOR);\n\n\t// `String.prototype[@@iterator]` method\n\t// https://tc39.github.io/ecma262/#sec-string.prototype-@@iterator\n\tdefineIterator(String, 'String', function (iterated) {\n\t  setInternalState$1(this, {\n\t    type: STRING_ITERATOR,\n\t    string: String(iterated),\n\t    index: 0\n\t  });\n\t// `%StringIteratorPrototype%.next` method\n\t// https://tc39.github.io/ecma262/#sec-%stringiteratorprototype%.next\n\t}, function next() {\n\t  var state = getInternalState(this);\n\t  var string = state.string;\n\t  var index = state.index;\n\t  var point;\n\t  if (index >= string.length) return { value: undefined, done: true };\n\t  point = charAt(string, index);\n\t  state.index += point.length;\n\t  return { value: point, done: false };\n\t});\n\n\t// iterable DOM collections\n\t// flag - `iterable` interface - 'entries', 'keys', 'values', 'forEach' methods\n\tvar domIterables = {\n\t  CSSRuleList: 0,\n\t  CSSStyleDeclaration: 0,\n\t  CSSValueList: 0,\n\t  ClientRectList: 0,\n\t  DOMRectList: 0,\n\t  DOMStringList: 0,\n\t  DOMTokenList: 1,\n\t  DataTransferItemList: 0,\n\t  FileList: 0,\n\t  HTMLAllCollection: 0,\n\t  HTMLCollection: 0,\n\t  HTMLFormElement: 0,\n\t  HTMLSelectElement: 0,\n\t  MediaList: 0,\n\t  MimeTypeArray: 0,\n\t  NamedNodeMap: 0,\n\t  NodeList: 1,\n\t  PaintRequestList: 0,\n\t  Plugin: 0,\n\t  PluginArray: 0,\n\t  SVGLengthList: 0,\n\t  SVGNumberList: 0,\n\t  SVGPathSegList: 0,\n\t  SVGPointList: 0,\n\t  SVGStringList: 0,\n\t  SVGTransformList: 0,\n\t  SourceBufferList: 0,\n\t  StyleSheetList: 0,\n\t  TextTrackCueList: 0,\n\t  TextTrackList: 0,\n\t  TouchList: 0\n\t};\n\n\tvar UNSCOPABLES = wellKnownSymbol('unscopables');\n\tvar ArrayPrototype$1 = Array.prototype;\n\n\t// Array.prototype[@@unscopables]\n\t// https://tc39.github.io/ecma262/#sec-array.prototype-@@unscopables\n\tif (ArrayPrototype$1[UNSCOPABLES] == undefined) {\n\t  hide(ArrayPrototype$1, UNSCOPABLES, objectCreate(null));\n\t}\n\n\t// add a key to Array.prototype[@@unscopables]\n\tvar addToUnscopables = function (key) {\n\t  ArrayPrototype$1[UNSCOPABLES][key] = true;\n\t};\n\n\tvar ARRAY_ITERATOR = 'Array Iterator';\n\tvar setInternalState$2 = internalState.set;\n\tvar getInternalState$1 = internalState.getterFor(ARRAY_ITERATOR);\n\n\t// `Array.prototype.entries` method\n\t// https://tc39.github.io/ecma262/#sec-array.prototype.entries\n\t// `Array.prototype.keys` method\n\t// https://tc39.github.io/ecma262/#sec-array.prototype.keys\n\t// `Array.prototype.values` method\n\t// https://tc39.github.io/ecma262/#sec-array.prototype.values\n\t// `Array.prototype[@@iterator]` method\n\t// https://tc39.github.io/ecma262/#sec-array.prototype-@@iterator\n\t// `CreateArrayIterator` internal method\n\t// https://tc39.github.io/ecma262/#sec-createarrayiterator\n\tvar es_array_iterator = defineIterator(Array, 'Array', function (iterated, kind) {\n\t  setInternalState$2(this, {\n\t    type: ARRAY_ITERATOR,\n\t    target: toIndexedObject(iterated), // target\n\t    index: 0,                          // next index\n\t    kind: kind                         // kind\n\t  });\n\t// `%ArrayIteratorPrototype%.next` method\n\t// https://tc39.github.io/ecma262/#sec-%arrayiteratorprototype%.next\n\t}, function () {\n\t  var state = getInternalState$1(this);\n\t  var target = state.target;\n\t  var kind = state.kind;\n\t  var index = state.index++;\n\t  if (!target || index >= target.length) {\n\t    state.target = undefined;\n\t    return { value: undefined, done: true };\n\t  }\n\t  if (kind == 'keys') return { value: index, done: false };\n\t  if (kind == 'values') return { value: target[index], done: false };\n\t  return { value: [index, target[index]], done: false };\n\t}, 'values');\n\n\t// argumentsList[@@iterator] is %ArrayProto_values%\n\t// https://tc39.github.io/ecma262/#sec-createunmappedargumentsobject\n\t// https://tc39.github.io/ecma262/#sec-createmappedargumentsobject\n\titerators.Arguments = iterators.Array;\n\n\t// https://tc39.github.io/ecma262/#sec-array.prototype-@@unscopables\n\taddToUnscopables('keys');\n\taddToUnscopables('values');\n\taddToUnscopables('entries');\n\n\tvar ITERATOR$5 = wellKnownSymbol('iterator');\n\tvar TO_STRING_TAG$3 = wellKnownSymbol('toStringTag');\n\tvar ArrayValues = es_array_iterator.values;\n\n\tfor (var COLLECTION_NAME in domIterables) {\n\t  var Collection = global_1[COLLECTION_NAME];\n\t  var CollectionPrototype = Collection && Collection.prototype;\n\t  if (CollectionPrototype) {\n\t    // some Chrome versions have non-configurable methods on DOMTokenList\n\t    if (CollectionPrototype[ITERATOR$5] !== ArrayValues) try {\n\t      hide(CollectionPrototype, ITERATOR$5, ArrayValues);\n\t    } catch (error) {\n\t      CollectionPrototype[ITERATOR$5] = ArrayValues;\n\t    }\n\t    if (!CollectionPrototype[TO_STRING_TAG$3]) hide(CollectionPrototype, TO_STRING_TAG$3, COLLECTION_NAME);\n\t    if (domIterables[COLLECTION_NAME]) for (var METHOD_NAME in es_array_iterator) {\n\t      // some Chrome versions have non-configurable methods on DOMTokenList\n\t      if (CollectionPrototype[METHOD_NAME] !== es_array_iterator[METHOD_NAME]) try {\n\t        hide(CollectionPrototype, METHOD_NAME, es_array_iterator[METHOD_NAME]);\n\t      } catch (error) {\n\t        CollectionPrototype[METHOD_NAME] = es_array_iterator[METHOD_NAME];\n\t      }\n\t    }\n\t  }\n\t}\n\n\tvar map = path.Map;\n\n\t// `IsArray` abstract operation\n\t// https://tc39.github.io/ecma262/#sec-isarray\n\tvar isArray = Array.isArray || function isArray(arg) {\n\t  return classofRaw(arg) == 'Array';\n\t};\n\n\tvar SPECIES$1 = wellKnownSymbol('species');\n\n\t// `ArraySpeciesCreate` abstract operation\n\t// https://tc39.github.io/ecma262/#sec-arrayspeciescreate\n\tvar arraySpeciesCreate = function (originalArray, length) {\n\t  var C;\n\t  if (isArray(originalArray)) {\n\t    C = originalArray.constructor;\n\t    // cross-realm fallback\n\t    if (typeof C == 'function' && (C === Array || isArray(C.prototype))) C = undefined;\n\t    else if (isObject(C)) {\n\t      C = C[SPECIES$1];\n\t      if (C === null) C = undefined;\n\t    }\n\t  } return new (C === undefined ? Array : C)(length === 0 ? 0 : length);\n\t};\n\n\tvar push = [].push;\n\n\t// `Array.prototype.{ forEach, map, filter, some, every, find, findIndex }` methods implementation\n\tvar createMethod$2 = function (TYPE) {\n\t  var IS_MAP = TYPE == 1;\n\t  var IS_FILTER = TYPE == 2;\n\t  var IS_SOME = TYPE == 3;\n\t  var IS_EVERY = TYPE == 4;\n\t  var IS_FIND_INDEX = TYPE == 6;\n\t  var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;\n\t  return function ($this, callbackfn, that, specificCreate) {\n\t    var O = toObject($this);\n\t    var self = indexedObject(O);\n\t    var boundFunction = bindContext(callbackfn, that, 3);\n\t    var length = toLength(self.length);\n\t    var index = 0;\n\t    var create = specificCreate || arraySpeciesCreate;\n\t    var target = IS_MAP ? create($this, length) : IS_FILTER ? create($this, 0) : undefined;\n\t    var value, result;\n\t    for (;length > index; index++) if (NO_HOLES || index in self) {\n\t      value = self[index];\n\t      result = boundFunction(value, index, O);\n\t      if (TYPE) {\n\t        if (IS_MAP) target[index] = result; // map\n\t        else if (result) switch (TYPE) {\n\t          case 3: return true;              // some\n\t          case 5: return value;             // find\n\t          case 6: return index;             // findIndex\n\t          case 2: push.call(target, value); // filter\n\t        } else if (IS_EVERY) return false;  // every\n\t      }\n\t    }\n\t    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : target;\n\t  };\n\t};\n\n\tvar arrayIteration = {\n\t  // `Array.prototype.forEach` method\n\t  // https://tc39.github.io/ecma262/#sec-array.prototype.foreach\n\t  forEach: createMethod$2(0),\n\t  // `Array.prototype.map` method\n\t  // https://tc39.github.io/ecma262/#sec-array.prototype.map\n\t  map: createMethod$2(1),\n\t  // `Array.prototype.filter` method\n\t  // https://tc39.github.io/ecma262/#sec-array.prototype.filter\n\t  filter: createMethod$2(2),\n\t  // `Array.prototype.some` method\n\t  // https://tc39.github.io/ecma262/#sec-array.prototype.some\n\t  some: createMethod$2(3),\n\t  // `Array.prototype.every` method\n\t  // https://tc39.github.io/ecma262/#sec-array.prototype.every\n\t  every: createMethod$2(4),\n\t  // `Array.prototype.find` method\n\t  // https://tc39.github.io/ecma262/#sec-array.prototype.find\n\t  find: createMethod$2(5),\n\t  // `Array.prototype.findIndex` method\n\t  // https://tc39.github.io/ecma262/#sec-array.prototype.findIndex\n\t  findIndex: createMethod$2(6)\n\t};\n\n\tvar getWeakData = internalMetadata.getWeakData;\n\n\n\n\n\n\n\n\n\tvar setInternalState$3 = internalState.set;\n\tvar internalStateGetterFor$1 = internalState.getterFor;\n\tvar find = arrayIteration.find;\n\tvar findIndex = arrayIteration.findIndex;\n\tvar id$1 = 0;\n\n\t// fallback for uncaught frozen keys\n\tvar uncaughtFrozenStore = function (store) {\n\t  return store.frozen || (store.frozen = new UncaughtFrozenStore());\n\t};\n\n\tvar UncaughtFrozenStore = function () {\n\t  this.entries = [];\n\t};\n\n\tvar findUncaughtFrozen = function (store, key) {\n\t  return find(store.entries, function (it) {\n\t    return it[0] === key;\n\t  });\n\t};\n\n\tUncaughtFrozenStore.prototype = {\n\t  get: function (key) {\n\t    var entry = findUncaughtFrozen(this, key);\n\t    if (entry) return entry[1];\n\t  },\n\t  has: function (key) {\n\t    return !!findUncaughtFrozen(this, key);\n\t  },\n\t  set: function (key, value) {\n\t    var entry = findUncaughtFrozen(this, key);\n\t    if (entry) entry[1] = value;\n\t    else this.entries.push([key, value]);\n\t  },\n\t  'delete': function (key) {\n\t    var index = findIndex(this.entries, function (it) {\n\t      return it[0] === key;\n\t    });\n\t    if (~index) this.entries.splice(index, 1);\n\t    return !!~index;\n\t  }\n\t};\n\n\tvar collectionWeak = {\n\t  getConstructor: function (wrapper, CONSTRUCTOR_NAME, IS_MAP, ADDER) {\n\t    var C = wrapper(function (that, iterable) {\n\t      anInstance(that, C, CONSTRUCTOR_NAME);\n\t      setInternalState$3(that, {\n\t        type: CONSTRUCTOR_NAME,\n\t        id: id$1++,\n\t        frozen: undefined\n\t      });\n\t      if (iterable != undefined) iterate_1(iterable, that[ADDER], that, IS_MAP);\n\t    });\n\n\t    var getInternalState = internalStateGetterFor$1(CONSTRUCTOR_NAME);\n\n\t    var define = function (that, key, value) {\n\t      var state = getInternalState(that);\n\t      var data = getWeakData(anObject(key), true);\n\t      if (data === true) uncaughtFrozenStore(state).set(key, value);\n\t      else data[state.id] = value;\n\t      return that;\n\t    };\n\n\t    redefineAll(C.prototype, {\n\t      // 23.3.3.2 WeakMap.prototype.delete(key)\n\t      // 23.4.3.3 WeakSet.prototype.delete(value)\n\t      'delete': function (key) {\n\t        var state = getInternalState(this);\n\t        if (!isObject(key)) return false;\n\t        var data = getWeakData(key);\n\t        if (data === true) return uncaughtFrozenStore(state)['delete'](key);\n\t        return data && has(data, state.id) && delete data[state.id];\n\t      },\n\t      // 23.3.3.4 WeakMap.prototype.has(key)\n\t      // 23.4.3.4 WeakSet.prototype.has(value)\n\t      has: function has$1(key) {\n\t        var state = getInternalState(this);\n\t        if (!isObject(key)) return false;\n\t        var data = getWeakData(key);\n\t        if (data === true) return uncaughtFrozenStore(state).has(key);\n\t        return data && has(data, state.id);\n\t      }\n\t    });\n\n\t    redefineAll(C.prototype, IS_MAP ? {\n\t      // 23.3.3.3 WeakMap.prototype.get(key)\n\t      get: function get(key) {\n\t        var state = getInternalState(this);\n\t        if (isObject(key)) {\n\t          var data = getWeakData(key);\n\t          if (data === true) return uncaughtFrozenStore(state).get(key);\n\t          return data ? data[state.id] : undefined;\n\t        }\n\t      },\n\t      // 23.3.3.5 WeakMap.prototype.set(key, value)\n\t      set: function set(key, value) {\n\t        return define(this, key, value);\n\t      }\n\t    } : {\n\t      // 23.4.3.1 WeakSet.prototype.add(value)\n\t      add: function add(value) {\n\t        return define(this, value, true);\n\t      }\n\t    });\n\n\t    return C;\n\t  }\n\t};\n\n\tvar es_weakMap = createCommonjsModule(function (module) {\n\n\n\n\n\n\n\tvar enforceIternalState = internalState.enforce;\n\n\n\tvar IS_IE11 = !global_1.ActiveXObject && 'ActiveXObject' in global_1;\n\tvar isExtensible = Object.isExtensible;\n\tvar InternalWeakMap;\n\n\tvar wrapper = function (get) {\n\t  return function WeakMap() {\n\t    return get(this, arguments.length ? arguments[0] : undefined);\n\t  };\n\t};\n\n\t// `WeakMap` constructor\n\t// https://tc39.github.io/ecma262/#sec-weakmap-constructor\n\tvar $WeakMap = module.exports = collection('WeakMap', wrapper, collectionWeak, true, true);\n\n\t// IE11 WeakMap frozen keys fix\n\t// We can't use feature detection because it crash some old IE builds\n\t// https://github.com/zloirock/core-js/issues/485\n\tif (nativeWeakMap && IS_IE11) {\n\t  InternalWeakMap = collectionWeak.getConstructor(wrapper, 'WeakMap', true);\n\t  internalMetadata.REQUIRED = true;\n\t  var WeakMapPrototype = $WeakMap.prototype;\n\t  var nativeDelete = WeakMapPrototype['delete'];\n\t  var nativeHas = WeakMapPrototype.has;\n\t  var nativeGet = WeakMapPrototype.get;\n\t  var nativeSet = WeakMapPrototype.set;\n\t  redefineAll(WeakMapPrototype, {\n\t    'delete': function (key) {\n\t      if (isObject(key) && !isExtensible(key)) {\n\t        var state = enforceIternalState(this);\n\t        if (!state.frozen) state.frozen = new InternalWeakMap();\n\t        return nativeDelete.call(this, key) || state.frozen['delete'](key);\n\t      } return nativeDelete.call(this, key);\n\t    },\n\t    has: function has(key) {\n\t      if (isObject(key) && !isExtensible(key)) {\n\t        var state = enforceIternalState(this);\n\t        if (!state.frozen) state.frozen = new InternalWeakMap();\n\t        return nativeHas.call(this, key) || state.frozen.has(key);\n\t      } return nativeHas.call(this, key);\n\t    },\n\t    get: function get(key) {\n\t      if (isObject(key) && !isExtensible(key)) {\n\t        var state = enforceIternalState(this);\n\t        if (!state.frozen) state.frozen = new InternalWeakMap();\n\t        return nativeHas.call(this, key) ? nativeGet.call(this, key) : state.frozen.get(key);\n\t      } return nativeGet.call(this, key);\n\t    },\n\t    set: function set(key, value) {\n\t      if (isObject(key) && !isExtensible(key)) {\n\t        var state = enforceIternalState(this);\n\t        if (!state.frozen) state.frozen = new InternalWeakMap();\n\t        nativeHas.call(this, key) ? nativeSet.call(this, key, value) : state.frozen.set(key, value);\n\t      } else nativeSet.call(this, key, value);\n\t      return this;\n\t    }\n\t  });\n\t}\n\t});\n\n\tvar weakMap = path.WeakMap;\n\n\t// `Set` constructor\n\t// https://tc39.github.io/ecma262/#sec-set-objects\n\tvar es_set = collection('Set', function (get) {\n\t  return function Set() { return get(this, arguments.length ? arguments[0] : undefined); };\n\t}, collectionStrong);\n\n\tvar set$1 = path.Set;\n\n\t// `WeakSet` constructor\n\t// https://tc39.github.io/ecma262/#sec-weakset-constructor\n\tcollection('WeakSet', function (get) {\n\t  return function WeakSet() { return get(this, arguments.length ? arguments[0] : undefined); };\n\t}, collectionWeak, false, true);\n\n\tvar weakSet = path.WeakSet;\n\n\tvar es2015Collection = createCommonjsModule(function (module, exports) {\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\t});\n\n\tunwrapExports(es2015Collection);\n\n\tvar $find = arrayIteration.find;\n\n\n\tvar FIND = 'find';\n\tvar SKIPS_HOLES = true;\n\n\t// Shouldn't skip holes\n\tif (FIND in []) Array(1)[FIND](function () { SKIPS_HOLES = false; });\n\n\t// `Array.prototype.find` method\n\t// https://tc39.github.io/ecma262/#sec-array.prototype.find\n\t_export({ target: 'Array', proto: true, forced: SKIPS_HOLES }, {\n\t  find: function find(callbackfn /* , that = undefined */) {\n\t    return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);\n\t  }\n\t});\n\n\t// https://tc39.github.io/ecma262/#sec-array.prototype-@@unscopables\n\taddToUnscopables(FIND);\n\n\tvar call = Function.call;\n\n\tvar entryUnbind = function (CONSTRUCTOR, METHOD, length) {\n\t  return bindContext(call, global_1[CONSTRUCTOR].prototype[METHOD], length);\n\t};\n\n\tvar find$1 = entryUnbind('Array', 'find');\n\n\tvar defineProperty$2 = objectDefineProperty.f;\n\n\n\n\n\n\tvar DataView = global_1.DataView;\n\tvar DataViewPrototype = DataView && DataView.prototype;\n\tvar Int8Array$1 = global_1.Int8Array;\n\tvar Int8ArrayPrototype = Int8Array$1 && Int8Array$1.prototype;\n\tvar Uint8ClampedArray = global_1.Uint8ClampedArray;\n\tvar Uint8ClampedArrayPrototype = Uint8ClampedArray && Uint8ClampedArray.prototype;\n\tvar TypedArray = Int8Array$1 && objectGetPrototypeOf(Int8Array$1);\n\tvar TypedArrayPrototype = Int8ArrayPrototype && objectGetPrototypeOf(Int8ArrayPrototype);\n\tvar ObjectPrototype$2 = Object.prototype;\n\tvar isPrototypeOf = ObjectPrototype$2.isPrototypeOf;\n\n\tvar TO_STRING_TAG$4 = wellKnownSymbol('toStringTag');\n\tvar TYPED_ARRAY_TAG = uid('TYPED_ARRAY_TAG');\n\tvar NATIVE_ARRAY_BUFFER = !!(global_1.ArrayBuffer && DataView);\n\t// Fixing native typed arrays in Opera Presto crashes the browser, see #595\n\tvar NATIVE_ARRAY_BUFFER_VIEWS = NATIVE_ARRAY_BUFFER && !!objectSetPrototypeOf && classof(global_1.opera) !== 'Opera';\n\tvar TYPED_ARRAY_TAG_REQIRED = false;\n\tvar NAME;\n\n\tvar TypedArrayConstructorsList = {\n\t  Int8Array: 1,\n\t  Uint8Array: 1,\n\t  Uint8ClampedArray: 1,\n\t  Int16Array: 2,\n\t  Uint16Array: 2,\n\t  Int32Array: 4,\n\t  Uint32Array: 4,\n\t  Float32Array: 4,\n\t  Float64Array: 8\n\t};\n\n\tvar isView = function isView(it) {\n\t  var klass = classof(it);\n\t  return klass === 'DataView' || has(TypedArrayConstructorsList, klass);\n\t};\n\n\tvar isTypedArray = function (it) {\n\t  return isObject(it) && has(TypedArrayConstructorsList, classof(it));\n\t};\n\n\tvar aTypedArray = function (it) {\n\t  if (isTypedArray(it)) return it;\n\t  throw TypeError('Target is not a typed array');\n\t};\n\n\tvar aTypedArrayConstructor = function (C) {\n\t  if (objectSetPrototypeOf) {\n\t    if (isPrototypeOf.call(TypedArray, C)) return C;\n\t  } else for (var ARRAY in TypedArrayConstructorsList) if (has(TypedArrayConstructorsList, NAME)) {\n\t    var TypedArrayConstructor = global_1[ARRAY];\n\t    if (TypedArrayConstructor && (C === TypedArrayConstructor || isPrototypeOf.call(TypedArrayConstructor, C))) {\n\t      return C;\n\t    }\n\t  } throw TypeError('Target is not a typed array constructor');\n\t};\n\n\tvar exportProto = function (KEY, property, forced) {\n\t  if (!descriptors) return;\n\t  if (forced) for (var ARRAY in TypedArrayConstructorsList) {\n\t    var TypedArrayConstructor = global_1[ARRAY];\n\t    if (TypedArrayConstructor && has(TypedArrayConstructor.prototype, KEY)) {\n\t      delete TypedArrayConstructor.prototype[KEY];\n\t    }\n\t  }\n\t  if (!TypedArrayPrototype[KEY] || forced) {\n\t    redefine(TypedArrayPrototype, KEY, forced ? property\n\t      : NATIVE_ARRAY_BUFFER_VIEWS && Int8ArrayPrototype[KEY] || property);\n\t  }\n\t};\n\n\tvar exportStatic = function (KEY, property, forced) {\n\t  var ARRAY, TypedArrayConstructor;\n\t  if (!descriptors) return;\n\t  if (objectSetPrototypeOf) {\n\t    if (forced) for (ARRAY in TypedArrayConstructorsList) {\n\t      TypedArrayConstructor = global_1[ARRAY];\n\t      if (TypedArrayConstructor && has(TypedArrayConstructor, KEY)) {\n\t        delete TypedArrayConstructor[KEY];\n\t      }\n\t    }\n\t    if (!TypedArray[KEY] || forced) {\n\t      // V8 ~ Chrome 49-50 `%TypedArray%` methods are non-writable non-configurable\n\t      try {\n\t        return redefine(TypedArray, KEY, forced ? property : NATIVE_ARRAY_BUFFER_VIEWS && Int8Array$1[KEY] || property);\n\t      } catch (error) { /* empty */ }\n\t    } else return;\n\t  }\n\t  for (ARRAY in TypedArrayConstructorsList) {\n\t    TypedArrayConstructor = global_1[ARRAY];\n\t    if (TypedArrayConstructor && (!TypedArrayConstructor[KEY] || forced)) {\n\t      redefine(TypedArrayConstructor, KEY, property);\n\t    }\n\t  }\n\t};\n\n\tfor (NAME in TypedArrayConstructorsList) {\n\t  if (!global_1[NAME]) NATIVE_ARRAY_BUFFER_VIEWS = false;\n\t}\n\n\t// WebKit bug - typed arrays constructors prototype is Object.prototype\n\tif (!NATIVE_ARRAY_BUFFER_VIEWS || typeof TypedArray != 'function' || TypedArray === Function.prototype) {\n\t  // eslint-disable-next-line no-shadow\n\t  TypedArray = function TypedArray() {\n\t    throw TypeError('Incorrect invocation');\n\t  };\n\t  if (NATIVE_ARRAY_BUFFER_VIEWS) for (NAME in TypedArrayConstructorsList) {\n\t    if (global_1[NAME]) objectSetPrototypeOf(global_1[NAME], TypedArray);\n\t  }\n\t}\n\n\tif (!NATIVE_ARRAY_BUFFER_VIEWS || !TypedArrayPrototype || TypedArrayPrototype === ObjectPrototype$2) {\n\t  TypedArrayPrototype = TypedArray.prototype;\n\t  if (NATIVE_ARRAY_BUFFER_VIEWS) for (NAME in TypedArrayConstructorsList) {\n\t    if (global_1[NAME]) objectSetPrototypeOf(global_1[NAME].prototype, TypedArrayPrototype);\n\t  }\n\t}\n\n\t// WebKit bug - one more object in Uint8ClampedArray prototype chain\n\tif (NATIVE_ARRAY_BUFFER_VIEWS && objectGetPrototypeOf(Uint8ClampedArrayPrototype) !== TypedArrayPrototype) {\n\t  objectSetPrototypeOf(Uint8ClampedArrayPrototype, TypedArrayPrototype);\n\t}\n\n\tif (descriptors && !has(TypedArrayPrototype, TO_STRING_TAG$4)) {\n\t  TYPED_ARRAY_TAG_REQIRED = true;\n\t  defineProperty$2(TypedArrayPrototype, TO_STRING_TAG$4, { get: function () {\n\t    return isObject(this) ? this[TYPED_ARRAY_TAG] : undefined;\n\t  } });\n\t  for (NAME in TypedArrayConstructorsList) if (global_1[NAME]) {\n\t    hide(global_1[NAME], TYPED_ARRAY_TAG, NAME);\n\t  }\n\t}\n\n\t// WebKit bug - the same parent prototype for typed arrays and data view\n\tif (NATIVE_ARRAY_BUFFER && objectSetPrototypeOf && objectGetPrototypeOf(DataViewPrototype) !== ObjectPrototype$2) {\n\t  objectSetPrototypeOf(DataViewPrototype, ObjectPrototype$2);\n\t}\n\n\tvar arrayBufferViewCore = {\n\t  NATIVE_ARRAY_BUFFER: NATIVE_ARRAY_BUFFER,\n\t  NATIVE_ARRAY_BUFFER_VIEWS: NATIVE_ARRAY_BUFFER_VIEWS,\n\t  TYPED_ARRAY_TAG: TYPED_ARRAY_TAG_REQIRED && TYPED_ARRAY_TAG,\n\t  aTypedArray: aTypedArray,\n\t  aTypedArrayConstructor: aTypedArrayConstructor,\n\t  exportProto: exportProto,\n\t  exportStatic: exportStatic,\n\t  isView: isView,\n\t  isTypedArray: isTypedArray,\n\t  TypedArray: TypedArray,\n\t  TypedArrayPrototype: TypedArrayPrototype\n\t};\n\n\tvar $find$1 = arrayIteration.find;\n\n\tvar aTypedArray$1 = arrayBufferViewCore.aTypedArray;\n\n\t// `%TypedArray%.prototype.find` method\n\t// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.find\n\tarrayBufferViewCore.exportProto('find', function find(predicate /* , thisArg */) {\n\t  return $find$1(aTypedArray$1(this), predicate, arguments.length > 1 ? arguments[1] : undefined);\n\t});\n\n\tvar $findIndex = arrayIteration.findIndex;\n\n\n\tvar FIND_INDEX = 'findIndex';\n\tvar SKIPS_HOLES$1 = true;\n\n\t// Shouldn't skip holes\n\tif (FIND_INDEX in []) Array(1)[FIND_INDEX](function () { SKIPS_HOLES$1 = false; });\n\n\t// `Array.prototype.findIndex` method\n\t// https://tc39.github.io/ecma262/#sec-array.prototype.findindex\n\t_export({ target: 'Array', proto: true, forced: SKIPS_HOLES$1 }, {\n\t  findIndex: function findIndex(callbackfn /* , that = undefined */) {\n\t    return $findIndex(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);\n\t  }\n\t});\n\n\t// https://tc39.github.io/ecma262/#sec-array.prototype-@@unscopables\n\taddToUnscopables(FIND_INDEX);\n\n\tvar findIndex$1 = entryUnbind('Array', 'findIndex');\n\n\tvar $findIndex$1 = arrayIteration.findIndex;\n\n\tvar aTypedArray$2 = arrayBufferViewCore.aTypedArray;\n\n\t// `%TypedArray%.prototype.findIndex` method\n\t// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.findindex\n\tarrayBufferViewCore.exportProto('findIndex', function findIndex(predicate /* , thisArg */) {\n\t  return $findIndex$1(aTypedArray$2(this), predicate, arguments.length > 1 ? arguments[1] : undefined);\n\t});\n\n\t// `Array.prototype.fill` method implementation\n\t// https://tc39.github.io/ecma262/#sec-array.prototype.fill\n\tvar arrayFill = function fill(value /* , start = 0, end = @length */) {\n\t  var O = toObject(this);\n\t  var length = toLength(O.length);\n\t  var argumentsLength = arguments.length;\n\t  var index = toAbsoluteIndex(argumentsLength > 1 ? arguments[1] : undefined, length);\n\t  var end = argumentsLength > 2 ? arguments[2] : undefined;\n\t  var endPos = end === undefined ? length : toAbsoluteIndex(end, length);\n\t  while (endPos > index) O[index++] = value;\n\t  return O;\n\t};\n\n\t// `Array.prototype.fill` method\n\t// https://tc39.github.io/ecma262/#sec-array.prototype.fill\n\t_export({ target: 'Array', proto: true }, {\n\t  fill: arrayFill\n\t});\n\n\t// https://tc39.github.io/ecma262/#sec-array.prototype-@@unscopables\n\taddToUnscopables('fill');\n\n\tvar fill = entryUnbind('Array', 'fill');\n\n\tvar aTypedArray$3 = arrayBufferViewCore.aTypedArray;\n\n\t// `%TypedArray%.prototype.fill` method\n\t// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.fill\n\t// eslint-disable-next-line no-unused-vars\n\tarrayBufferViewCore.exportProto('fill', function fill(value /* , start, end */) {\n\t  return arrayFill.apply(aTypedArray$3(this), arguments);\n\t});\n\n\tvar min$2 = Math.min;\n\n\t// `Array.prototype.copyWithin` method implementation\n\t// https://tc39.github.io/ecma262/#sec-array.prototype.copywithin\n\tvar arrayCopyWithin = [].copyWithin || function copyWithin(target /* = 0 */, start /* = 0, end = @length */) {\n\t  var O = toObject(this);\n\t  var len = toLength(O.length);\n\t  var to = toAbsoluteIndex(target, len);\n\t  var from = toAbsoluteIndex(start, len);\n\t  var end = arguments.length > 2 ? arguments[2] : undefined;\n\t  var count = min$2((end === undefined ? len : toAbsoluteIndex(end, len)) - from, len - to);\n\t  var inc = 1;\n\t  if (from < to && to < from + count) {\n\t    inc = -1;\n\t    from += count - 1;\n\t    to += count - 1;\n\t  }\n\t  while (count-- > 0) {\n\t    if (from in O) O[to] = O[from];\n\t    else delete O[to];\n\t    to += inc;\n\t    from += inc;\n\t  } return O;\n\t};\n\n\t// `Array.prototype.copyWithin` method\n\t// https://tc39.github.io/ecma262/#sec-array.prototype.copywithin\n\t_export({ target: 'Array', proto: true }, {\n\t  copyWithin: arrayCopyWithin\n\t});\n\n\t// https://tc39.github.io/ecma262/#sec-array.prototype-@@unscopables\n\taddToUnscopables('copyWithin');\n\n\tvar copyWithin = entryUnbind('Array', 'copyWithin');\n\n\tvar aTypedArray$4 = arrayBufferViewCore.aTypedArray;\n\n\t// `%TypedArray%.prototype.copyWithin` method\n\t// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.copywithin\n\tarrayBufferViewCore.exportProto('copyWithin', function copyWithin(target, start /* , end */) {\n\t  return arrayCopyWithin.call(aTypedArray$4(this), target, start, arguments.length > 2 ? arguments[2] : undefined);\n\t});\n\n\tvar createProperty = function (object, key, value) {\n\t  var propertyKey = toPrimitive(key);\n\t  if (propertyKey in object) objectDefineProperty.f(object, propertyKey, createPropertyDescriptor(0, value));\n\t  else object[propertyKey] = value;\n\t};\n\n\t// `Array.from` method implementation\n\t// https://tc39.github.io/ecma262/#sec-array.from\n\tvar arrayFrom = function from(arrayLike /* , mapfn = undefined, thisArg = undefined */) {\n\t  var O = toObject(arrayLike);\n\t  var C = typeof this == 'function' ? this : Array;\n\t  var argumentsLength = arguments.length;\n\t  var mapfn = argumentsLength > 1 ? arguments[1] : undefined;\n\t  var mapping = mapfn !== undefined;\n\t  var index = 0;\n\t  var iteratorMethod = getIteratorMethod(O);\n\t  var length, result, step, iterator;\n\t  if (mapping) mapfn = bindContext(mapfn, argumentsLength > 2 ? arguments[2] : undefined, 2);\n\t  // if the target is not iterable or it's an array with the default iterator - use a simple case\n\t  if (iteratorMethod != undefined && !(C == Array && isArrayIteratorMethod(iteratorMethod))) {\n\t    iterator = iteratorMethod.call(O);\n\t    result = new C();\n\t    for (;!(step = iterator.next()).done; index++) {\n\t      createProperty(result, index, mapping\n\t        ? callWithSafeIterationClosing(iterator, mapfn, [step.value, index], true)\n\t        : step.value\n\t      );\n\t    }\n\t  } else {\n\t    length = toLength(O.length);\n\t    result = new C(length);\n\t    for (;length > index; index++) {\n\t      createProperty(result, index, mapping ? mapfn(O[index], index) : O[index]);\n\t    }\n\t  }\n\t  result.length = index;\n\t  return result;\n\t};\n\n\tvar INCORRECT_ITERATION = !checkCorrectnessOfIteration(function (iterable) {\n\t  Array.from(iterable);\n\t});\n\n\t// `Array.from` method\n\t// https://tc39.github.io/ecma262/#sec-array.from\n\t_export({ target: 'Array', stat: true, forced: INCORRECT_ITERATION }, {\n\t  from: arrayFrom\n\t});\n\n\tvar from_1 = path.Array.from;\n\n\t/* eslint-disable no-new */\n\n\n\n\tvar NATIVE_ARRAY_BUFFER_VIEWS$1 = arrayBufferViewCore.NATIVE_ARRAY_BUFFER_VIEWS;\n\n\tvar ArrayBuffer = global_1.ArrayBuffer;\n\tvar Int8Array$2 = global_1.Int8Array;\n\n\tvar typedArraysConstructorsRequiresWrappers = !NATIVE_ARRAY_BUFFER_VIEWS$1 || !fails(function () {\n\t  Int8Array$2(1);\n\t}) || !fails(function () {\n\t  new Int8Array$2(-1);\n\t}) || !checkCorrectnessOfIteration(function (iterable) {\n\t  new Int8Array$2();\n\t  new Int8Array$2(null);\n\t  new Int8Array$2(1.5);\n\t  new Int8Array$2(iterable);\n\t}, true) || fails(function () {\n\t  // Safari 11 bug\n\t  return new Int8Array$2(new ArrayBuffer(2), 1, undefined).length !== 1;\n\t});\n\n\tvar aTypedArrayConstructor$1 = arrayBufferViewCore.aTypedArrayConstructor;\n\n\tvar typedArrayFrom = function from(source /* , mapfn, thisArg */) {\n\t  var O = toObject(source);\n\t  var argumentsLength = arguments.length;\n\t  var mapfn = argumentsLength > 1 ? arguments[1] : undefined;\n\t  var mapping = mapfn !== undefined;\n\t  var iteratorMethod = getIteratorMethod(O);\n\t  var i, length, result, step, iterator;\n\t  if (iteratorMethod != undefined && !isArrayIteratorMethod(iteratorMethod)) {\n\t    iterator = iteratorMethod.call(O);\n\t    O = [];\n\t    while (!(step = iterator.next()).done) {\n\t      O.push(step.value);\n\t    }\n\t  }\n\t  if (mapping && argumentsLength > 2) {\n\t    mapfn = bindContext(mapfn, arguments[2], 2);\n\t  }\n\t  length = toLength(O.length);\n\t  result = new (aTypedArrayConstructor$1(this))(length);\n\t  for (i = 0; length > i; i++) {\n\t    result[i] = mapping ? mapfn(O[i], i) : O[i];\n\t  }\n\t  return result;\n\t};\n\n\t// `%TypedArray%.from` method\n\t// https://tc39.github.io/ecma262/#sec-%typedarray%.from\n\tarrayBufferViewCore.exportStatic('from', typedArrayFrom, typedArraysConstructorsRequiresWrappers);\n\n\tvar ISNT_GENERIC = fails(function () {\n\t  function F() { /* empty */ }\n\t  return !(Array.of.call(F) instanceof F);\n\t});\n\n\t// `Array.of` method\n\t// https://tc39.github.io/ecma262/#sec-array.of\n\t// WebKit Array.of isn't generic\n\t_export({ target: 'Array', stat: true, forced: ISNT_GENERIC }, {\n\t  of: function of(/* ...args */) {\n\t    var index = 0;\n\t    var argumentsLength = arguments.length;\n\t    var result = new (typeof this == 'function' ? this : Array)(argumentsLength);\n\t    while (argumentsLength > index) createProperty(result, index, arguments[index++]);\n\t    result.length = argumentsLength;\n\t    return result;\n\t  }\n\t});\n\n\tvar of = path.Array.of;\n\n\tvar aTypedArrayConstructor$2 = arrayBufferViewCore.aTypedArrayConstructor;\n\n\t// `%TypedArray%.of` method\n\t// https://tc39.github.io/ecma262/#sec-%typedarray%.of\n\tarrayBufferViewCore.exportStatic('of', function of(/* ...items */) {\n\t  var index = 0;\n\t  var length = arguments.length;\n\t  var result = new (aTypedArrayConstructor$2(this))(length);\n\t  while (length > index) result[index] = arguments[index++];\n\t  return result;\n\t}, typedArraysConstructorsRequiresWrappers);\n\n\tvar defineProperty$3 = objectDefineProperty.f;\n\n\tvar FunctionPrototype = Function.prototype;\n\tvar FunctionPrototypeToString = FunctionPrototype.toString;\n\tvar nameRE = /^\\s*function ([^ (]*)/;\n\tvar NAME$1 = 'name';\n\n\t// Function instances `.name` property\n\t// https://tc39.github.io/ecma262/#sec-function-instances-name\n\tif (descriptors && !(NAME$1 in FunctionPrototype)) {\n\t  defineProperty$3(FunctionPrototype, NAME$1, {\n\t    configurable: true,\n\t    get: function () {\n\t      try {\n\t        return FunctionPrototypeToString.call(this).match(nameRE)[1];\n\t      } catch (error) {\n\t        return '';\n\t      }\n\t    }\n\t  });\n\t}\n\n\tvar floor$1 = Math.floor;\n\tvar log = Math.log;\n\tvar LOG2E = Math.LOG2E;\n\n\t// `Math.clz32` method\n\t// https://tc39.github.io/ecma262/#sec-math.clz32\n\t_export({ target: 'Math', stat: true }, {\n\t  clz32: function clz32(x) {\n\t    return (x >>>= 0) ? 31 - floor$1(log(x + 0.5) * LOG2E) : 32;\n\t  }\n\t});\n\n\tvar clz32 = path.Math.clz32;\n\n\tvar nativeImul = Math.imul;\n\n\tvar FORCED = fails(function () {\n\t  return nativeImul(0xFFFFFFFF, 5) != -5 || nativeImul.length != 2;\n\t});\n\n\t// `Math.imul` method\n\t// https://tc39.github.io/ecma262/#sec-math.imul\n\t// some WebKit versions fails with big numbers, some has wrong arity\n\t_export({ target: 'Math', stat: true, forced: FORCED }, {\n\t  imul: function imul(x, y) {\n\t    var UINT16 = 0xFFFF;\n\t    var xn = +x;\n\t    var yn = +y;\n\t    var xl = UINT16 & xn;\n\t    var yl = UINT16 & yn;\n\t    return 0 | xl * yl + ((UINT16 & xn >>> 16) * yl + xl * (UINT16 & yn >>> 16) << 16 >>> 0);\n\t  }\n\t});\n\n\tvar imul = path.Math.imul;\n\n\t// `Math.sign` method implementation\n\t// https://tc39.github.io/ecma262/#sec-math.sign\n\tvar mathSign = Math.sign || function sign(x) {\n\t  // eslint-disable-next-line no-self-compare\n\t  return (x = +x) == 0 || x != x ? x : x < 0 ? -1 : 1;\n\t};\n\n\t// `Math.sign` method\n\t// https://tc39.github.io/ecma262/#sec-math.sign\n\t_export({ target: 'Math', stat: true }, {\n\t  sign: mathSign\n\t});\n\n\tvar sign = path.Math.sign;\n\n\tvar log$1 = Math.log;\n\tvar LOG10E = Math.LOG10E;\n\n\t// `Math.log10` method\n\t// https://tc39.github.io/ecma262/#sec-math.log10\n\t_export({ target: 'Math', stat: true }, {\n\t  log10: function log10(x) {\n\t    return log$1(x) * LOG10E;\n\t  }\n\t});\n\n\tvar log10 = path.Math.log10;\n\n\tvar log$2 = Math.log;\n\tvar LN2 = Math.LN2;\n\n\t// `Math.log2` method\n\t// https://tc39.github.io/ecma262/#sec-math.log2\n\t_export({ target: 'Math', stat: true }, {\n\t  log2: function log2(x) {\n\t    return log$2(x) / LN2;\n\t  }\n\t});\n\n\tvar log2 = path.Math.log2;\n\n\tvar log$3 = Math.log;\n\n\t// `Math.log1p` method implementation\n\t// https://tc39.github.io/ecma262/#sec-math.log1p\n\tvar mathLog1p = Math.log1p || function log1p(x) {\n\t  return (x = +x) > -1e-8 && x < 1e-8 ? x - x * x / 2 : log$3(1 + x);\n\t};\n\n\t// `Math.log1p` method\n\t// https://tc39.github.io/ecma262/#sec-math.log1p\n\t_export({ target: 'Math', stat: true }, { log1p: mathLog1p });\n\n\tvar log1p = path.Math.log1p;\n\n\tvar nativeExpm1 = Math.expm1;\n\tvar exp = Math.exp;\n\n\t// `Math.expm1` method implementation\n\t// https://tc39.github.io/ecma262/#sec-math.expm1\n\tvar mathExpm1 = (!nativeExpm1\n\t  // Old FF bug\n\t  || nativeExpm1(10) > 22025.465794806719 || nativeExpm1(10) < 22025.4657948067165168\n\t  // Tor Browser bug\n\t  || nativeExpm1(-2e-17) != -2e-17\n\t) ? function expm1(x) {\n\t  return (x = +x) == 0 ? x : x > -1e-6 && x < 1e-6 ? x + x * x / 2 : exp(x) - 1;\n\t} : nativeExpm1;\n\n\t// `Math.expm1` method\n\t// https://tc39.github.io/ecma262/#sec-math.expm1\n\t_export({ target: 'Math', stat: true, forced: mathExpm1 != Math.expm1 }, { expm1: mathExpm1 });\n\n\tvar expm1 = path.Math.expm1;\n\n\tvar nativeCosh = Math.cosh;\n\tvar abs = Math.abs;\n\tvar E = Math.E;\n\n\t// `Math.cosh` method\n\t// https://tc39.github.io/ecma262/#sec-math.cosh\n\t_export({ target: 'Math', stat: true, forced: !nativeCosh || nativeCosh(710) === Infinity }, {\n\t  cosh: function cosh(x) {\n\t    var t = mathExpm1(abs(x) - 1) + 1;\n\t    return (t + 1 / (t * E * E)) * (E / 2);\n\t  }\n\t});\n\n\tvar cosh = path.Math.cosh;\n\n\tvar abs$1 = Math.abs;\n\tvar exp$1 = Math.exp;\n\tvar E$1 = Math.E;\n\n\tvar FORCED$1 = fails(function () {\n\t  return Math.sinh(-2e-17) != -2e-17;\n\t});\n\n\t// `Math.sinh` method\n\t// https://tc39.github.io/ecma262/#sec-math.sinh\n\t// V8 near Chromium 38 has a problem with very small numbers\n\t_export({ target: 'Math', stat: true, forced: FORCED$1 }, {\n\t  sinh: function sinh(x) {\n\t    return abs$1(x = +x) < 1 ? (mathExpm1(x) - mathExpm1(-x)) / 2 : (exp$1(x - 1) - exp$1(-x - 1)) * (E$1 / 2);\n\t  }\n\t});\n\n\tvar sinh = path.Math.sinh;\n\n\tvar exp$2 = Math.exp;\n\n\t// `Math.tanh` method\n\t// https://tc39.github.io/ecma262/#sec-math.tanh\n\t_export({ target: 'Math', stat: true }, {\n\t  tanh: function tanh(x) {\n\t    var a = mathExpm1(x = +x);\n\t    var b = mathExpm1(-x);\n\t    return a == Infinity ? 1 : b == Infinity ? -1 : (a - b) / (exp$2(x) + exp$2(-x));\n\t  }\n\t});\n\n\tvar tanh = path.Math.tanh;\n\n\tvar nativeAcosh = Math.acosh;\n\tvar log$4 = Math.log;\n\tvar sqrt = Math.sqrt;\n\tvar LN2$1 = Math.LN2;\n\n\tvar FORCED$2 = !nativeAcosh\n\t  // V8 bug: https://code.google.com/p/v8/issues/detail?id=3509\n\t  || Math.floor(nativeAcosh(Number.MAX_VALUE)) != 710\n\t  // Tor Browser bug: Math.acosh(Infinity) -> NaN\n\t  || nativeAcosh(Infinity) != Infinity;\n\n\t// `Math.acosh` method\n\t// https://tc39.github.io/ecma262/#sec-math.acosh\n\t_export({ target: 'Math', stat: true, forced: FORCED$2 }, {\n\t  acosh: function acosh(x) {\n\t    return (x = +x) < 1 ? NaN : x > 94906265.62425156\n\t      ? log$4(x) + LN2$1\n\t      : mathLog1p(x - 1 + sqrt(x - 1) * sqrt(x + 1));\n\t  }\n\t});\n\n\tvar acosh = path.Math.acosh;\n\n\tvar nativeAsinh = Math.asinh;\n\tvar log$5 = Math.log;\n\tvar sqrt$1 = Math.sqrt;\n\n\tfunction asinh(x) {\n\t  return !isFinite(x = +x) || x == 0 ? x : x < 0 ? -asinh(-x) : log$5(x + sqrt$1(x * x + 1));\n\t}\n\n\t// `Math.asinh` method\n\t// https://tc39.github.io/ecma262/#sec-math.asinh\n\t// Tor Browser bug: Math.asinh(0) -> -0\n\t_export({ target: 'Math', stat: true, forced: !(nativeAsinh && 1 / nativeAsinh(0) > 0) }, {\n\t  asinh: asinh\n\t});\n\n\tvar asinh$1 = path.Math.asinh;\n\n\tvar nativeAtanh = Math.atanh;\n\tvar log$6 = Math.log;\n\n\t// `Math.atanh` method\n\t// https://tc39.github.io/ecma262/#sec-math.atanh\n\t// Tor Browser bug: Math.atanh(-0) -> 0\n\t_export({ target: 'Math', stat: true, forced: !(nativeAtanh && 1 / nativeAtanh(-0) < 0) }, {\n\t  atanh: function atanh(x) {\n\t    return (x = +x) == 0 ? x : log$6((1 + x) / (1 - x)) / 2;\n\t  }\n\t});\n\n\tvar atanh = path.Math.atanh;\n\n\tvar $hypot = Math.hypot;\n\tvar abs$2 = Math.abs;\n\tvar sqrt$2 = Math.sqrt;\n\n\t// Chrome 77 bug\n\t// https://bugs.chromium.org/p/v8/issues/detail?id=9546\n\tvar BUGGY = !!$hypot && $hypot(Infinity, NaN) !== Infinity;\n\n\t// `Math.hypot` method\n\t// https://tc39.github.io/ecma262/#sec-math.hypot\n\t_export({ target: 'Math', stat: true, forced: BUGGY }, {\n\t  hypot: function hypot(value1, value2) { // eslint-disable-line no-unused-vars\n\t    var sum = 0;\n\t    var i = 0;\n\t    var aLen = arguments.length;\n\t    var larg = 0;\n\t    var arg, div;\n\t    while (i < aLen) {\n\t      arg = abs$2(arguments[i++]);\n\t      if (larg < arg) {\n\t        div = larg / arg;\n\t        sum = sum * div * div + 1;\n\t        larg = arg;\n\t      } else if (arg > 0) {\n\t        div = arg / larg;\n\t        sum += div * div;\n\t      } else sum += arg;\n\t    }\n\t    return larg === Infinity ? Infinity : larg * sqrt$2(sum);\n\t  }\n\t});\n\n\tvar hypot = path.Math.hypot;\n\n\tvar ceil$1 = Math.ceil;\n\tvar floor$2 = Math.floor;\n\n\t// `Math.trunc` method\n\t// https://tc39.github.io/ecma262/#sec-math.trunc\n\t_export({ target: 'Math', stat: true }, {\n\t  trunc: function trunc(it) {\n\t    return (it > 0 ? floor$2 : ceil$1)(it);\n\t  }\n\t});\n\n\tvar trunc = path.Math.trunc;\n\n\tvar abs$3 = Math.abs;\n\tvar pow = Math.pow;\n\tvar EPSILON = pow(2, -52);\n\tvar EPSILON32 = pow(2, -23);\n\tvar MAX32 = pow(2, 127) * (2 - EPSILON32);\n\tvar MIN32 = pow(2, -126);\n\n\tvar roundTiesToEven = function (n) {\n\t  return n + 1 / EPSILON - 1 / EPSILON;\n\t};\n\n\t// `Math.fround` method implementation\n\t// https://tc39.github.io/ecma262/#sec-math.fround\n\tvar mathFround = Math.fround || function fround(x) {\n\t  var $abs = abs$3(x);\n\t  var $sign = mathSign(x);\n\t  var a, result;\n\t  if ($abs < MIN32) return $sign * roundTiesToEven($abs / MIN32 / EPSILON32) * MIN32 * EPSILON32;\n\t  a = (1 + EPSILON32 / EPSILON) * $abs;\n\t  result = a - (a - $abs);\n\t  // eslint-disable-next-line no-self-compare\n\t  if (result > MAX32 || result != result) return $sign * Infinity;\n\t  return $sign * result;\n\t};\n\n\t// `Math.fround` method\n\t// https://tc39.github.io/ecma262/#sec-math.fround\n\t_export({ target: 'Math', stat: true }, { fround: mathFround });\n\n\tvar fround = path.Math.fround;\n\n\tvar abs$4 = Math.abs;\n\tvar pow$1 = Math.pow;\n\n\t// `Math.cbrt` method\n\t// https://tc39.github.io/ecma262/#sec-math.cbrt\n\t_export({ target: 'Math', stat: true }, {\n\t  cbrt: function cbrt(x) {\n\t    return mathSign(x = +x) * pow$1(abs$4(x), 1 / 3);\n\t  }\n\t});\n\n\tvar cbrt = path.Math.cbrt;\n\n\t// `Number.EPSILON` constant\n\t// https://tc39.github.io/ecma262/#sec-number.epsilon\n\t_export({ target: 'Number', stat: true }, {\n\t  EPSILON: Math.pow(2, -52)\n\t});\n\n\tvar globalIsFinite = global_1.isFinite;\n\n\t// `Number.isFinite` method\n\t// https://tc39.github.io/ecma262/#sec-number.isfinite\n\tvar numberIsFinite = Number.isFinite || function isFinite(it) {\n\t  return typeof it == 'number' && globalIsFinite(it);\n\t};\n\n\t// `Number.isFinite` method\n\t// https://tc39.github.io/ecma262/#sec-number.isfinite\n\t_export({ target: 'Number', stat: true }, { isFinite: numberIsFinite });\n\n\tvar _isFinite = path.Number.isFinite;\n\n\tvar floor$3 = Math.floor;\n\n\t// `Number.isInteger` method implementation\n\t// https://tc39.github.io/ecma262/#sec-number.isinteger\n\tvar isInteger = function isInteger(it) {\n\t  return !isObject(it) && isFinite(it) && floor$3(it) === it;\n\t};\n\n\t// `Number.isInteger` method\n\t// https://tc39.github.io/ecma262/#sec-number.isinteger\n\t_export({ target: 'Number', stat: true }, {\n\t  isInteger: isInteger\n\t});\n\n\tvar isInteger$1 = path.Number.isInteger;\n\n\t// `Number.isNaN` method\n\t// https://tc39.github.io/ecma262/#sec-number.isnan\n\t_export({ target: 'Number', stat: true }, {\n\t  isNaN: function isNaN(number) {\n\t    // eslint-disable-next-line no-self-compare\n\t    return number != number;\n\t  }\n\t});\n\n\tvar isNan = path.Number.isNaN;\n\n\tvar abs$5 = Math.abs;\n\n\t// `Number.isSafeInteger` method\n\t// https://tc39.github.io/ecma262/#sec-number.issafeinteger\n\t_export({ target: 'Number', stat: true }, {\n\t  isSafeInteger: function isSafeInteger(number) {\n\t    return isInteger(number) && abs$5(number) <= 0x1FFFFFFFFFFFFF;\n\t  }\n\t});\n\n\tvar isSafeInteger = path.Number.isSafeInteger;\n\n\t// `Number.MAX_SAFE_INTEGER` constant\n\t// https://tc39.github.io/ecma262/#sec-number.max_safe_integer\n\t_export({ target: 'Number', stat: true }, {\n\t  MAX_SAFE_INTEGER: 0x1FFFFFFFFFFFFF\n\t});\n\n\t// `Number.MIN_SAFE_INTEGER` constant\n\t// https://tc39.github.io/ecma262/#sec-number.min_safe_integer\n\t_export({ target: 'Number', stat: true }, {\n\t  MIN_SAFE_INTEGER: -0x1FFFFFFFFFFFFF\n\t});\n\n\t// a string of all valid unicode whitespaces\n\t// eslint-disable-next-line max-len\n\tvar whitespaces = '\\u0009\\u000A\\u000B\\u000C\\u000D\\u0020\\u00A0\\u1680\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200A\\u202F\\u205F\\u3000\\u2028\\u2029\\uFEFF';\n\n\tvar whitespace = '[' + whitespaces + ']';\n\tvar ltrim = RegExp('^' + whitespace + whitespace + '*');\n\tvar rtrim = RegExp(whitespace + whitespace + '*$');\n\n\t// `String.prototype.{ trim, trimStart, trimEnd, trimLeft, trimRight }` methods implementation\n\tvar createMethod$3 = function (TYPE) {\n\t  return function ($this) {\n\t    var string = String(requireObjectCoercible($this));\n\t    if (TYPE & 1) string = string.replace(ltrim, '');\n\t    if (TYPE & 2) string = string.replace(rtrim, '');\n\t    return string;\n\t  };\n\t};\n\n\tvar stringTrim = {\n\t  // `String.prototype.{ trimLeft, trimStart }` methods\n\t  // https://tc39.github.io/ecma262/#sec-string.prototype.trimstart\n\t  start: createMethod$3(1),\n\t  // `String.prototype.{ trimRight, trimEnd }` methods\n\t  // https://tc39.github.io/ecma262/#sec-string.prototype.trimend\n\t  end: createMethod$3(2),\n\t  // `String.prototype.trim` method\n\t  // https://tc39.github.io/ecma262/#sec-string.prototype.trim\n\t  trim: createMethod$3(3)\n\t};\n\n\tvar trim = stringTrim.trim;\n\n\n\tvar nativeParseFloat = global_1.parseFloat;\n\tvar FORCED$3 = 1 / nativeParseFloat(whitespaces + '-0') !== -Infinity;\n\n\t// `parseFloat` method\n\t// https://tc39.github.io/ecma262/#sec-parsefloat-string\n\tvar _parseFloat = FORCED$3 ? function parseFloat(string) {\n\t  var trimmedString = trim(String(string));\n\t  var result = nativeParseFloat(trimmedString);\n\t  return result === 0 && trimmedString.charAt(0) == '-' ? -0 : result;\n\t} : nativeParseFloat;\n\n\t// `Number.parseFloat` method\n\t// https://tc39.github.io/ecma262/#sec-number.parseFloat\n\t_export({ target: 'Number', stat: true, forced: Number.parseFloat != _parseFloat }, {\n\t  parseFloat: _parseFloat\n\t});\n\n\tvar _parseFloat$1 = path.Number.parseFloat;\n\n\tvar trim$1 = stringTrim.trim;\n\n\n\tvar nativeParseInt = global_1.parseInt;\n\tvar hex = /^[+-]?0[Xx]/;\n\tvar FORCED$4 = nativeParseInt(whitespaces + '08') !== 8 || nativeParseInt(whitespaces + '0x16') !== 22;\n\n\t// `parseInt` method\n\t// https://tc39.github.io/ecma262/#sec-parseint-string-radix\n\tvar _parseInt = FORCED$4 ? function parseInt(string, radix) {\n\t  var S = trim$1(String(string));\n\t  return nativeParseInt(S, (radix >>> 0) || (hex.test(S) ? 16 : 10));\n\t} : nativeParseInt;\n\n\t// `Number.parseInt` method\n\t// https://tc39.github.io/ecma262/#sec-number.parseint\n\t_export({ target: 'Number', stat: true, forced: Number.parseInt != _parseInt }, {\n\t  parseInt: _parseInt\n\t});\n\n\tvar _parseInt$1 = path.Number.parseInt;\n\n\tvar nativeAssign = Object.assign;\n\n\t// `Object.assign` method\n\t// https://tc39.github.io/ecma262/#sec-object.assign\n\t// should work with symbols and should have deterministic property order (V8 bug)\n\tvar objectAssign = !nativeAssign || fails(function () {\n\t  var A = {};\n\t  var B = {};\n\t  // eslint-disable-next-line no-undef\n\t  var symbol = Symbol();\n\t  var alphabet = 'abcdefghijklmnopqrst';\n\t  A[symbol] = 7;\n\t  alphabet.split('').forEach(function (chr) { B[chr] = chr; });\n\t  return nativeAssign({}, A)[symbol] != 7 || objectKeys(nativeAssign({}, B)).join('') != alphabet;\n\t}) ? function assign(target, source) { // eslint-disable-line no-unused-vars\n\t  var T = toObject(target);\n\t  var argumentsLength = arguments.length;\n\t  var index = 1;\n\t  var getOwnPropertySymbols = objectGetOwnPropertySymbols.f;\n\t  var propertyIsEnumerable = objectPropertyIsEnumerable.f;\n\t  while (argumentsLength > index) {\n\t    var S = indexedObject(arguments[index++]);\n\t    var keys = getOwnPropertySymbols ? objectKeys(S).concat(getOwnPropertySymbols(S)) : objectKeys(S);\n\t    var length = keys.length;\n\t    var j = 0;\n\t    var key;\n\t    while (length > j) {\n\t      key = keys[j++];\n\t      if (!descriptors || propertyIsEnumerable.call(S, key)) T[key] = S[key];\n\t    }\n\t  } return T;\n\t} : nativeAssign;\n\n\t// `Object.assign` method\n\t// https://tc39.github.io/ecma262/#sec-object.assign\n\t_export({ target: 'Object', stat: true, forced: Object.assign !== objectAssign }, {\n\t  assign: objectAssign\n\t});\n\n\tvar assign = path.Object.assign;\n\n\tvar nativeGetOwnPropertyNames = objectGetOwnPropertyNames.f;\n\n\tvar toString$1 = {}.toString;\n\n\tvar windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames\n\t  ? Object.getOwnPropertyNames(window) : [];\n\n\tvar getWindowNames = function (it) {\n\t  try {\n\t    return nativeGetOwnPropertyNames(it);\n\t  } catch (error) {\n\t    return windowNames.slice();\n\t  }\n\t};\n\n\t// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window\n\tvar f$5 = function getOwnPropertyNames(it) {\n\t  return windowNames && toString$1.call(it) == '[object Window]'\n\t    ? getWindowNames(it)\n\t    : nativeGetOwnPropertyNames(toIndexedObject(it));\n\t};\n\n\tvar objectGetOwnPropertyNamesExternal = {\n\t\tf: f$5\n\t};\n\n\tvar f$6 = wellKnownSymbol;\n\n\tvar wrappedWellKnownSymbol = {\n\t\tf: f$6\n\t};\n\n\tvar defineProperty$4 = objectDefineProperty.f;\n\n\tvar defineWellKnownSymbol = function (NAME) {\n\t  var Symbol = path.Symbol || (path.Symbol = {});\n\t  if (!has(Symbol, NAME)) defineProperty$4(Symbol, NAME, {\n\t    value: wrappedWellKnownSymbol.f(NAME)\n\t  });\n\t};\n\n\tvar $forEach = arrayIteration.forEach;\n\n\tvar HIDDEN = sharedKey('hidden');\n\tvar SYMBOL = 'Symbol';\n\tvar PROTOTYPE$1 = 'prototype';\n\tvar TO_PRIMITIVE = wellKnownSymbol('toPrimitive');\n\tvar setInternalState$4 = internalState.set;\n\tvar getInternalState$2 = internalState.getterFor(SYMBOL);\n\tvar ObjectPrototype$3 = Object[PROTOTYPE$1];\n\tvar $Symbol = global_1.Symbol;\n\tvar JSON = global_1.JSON;\n\tvar nativeJSONStringify = JSON && JSON.stringify;\n\tvar nativeGetOwnPropertyDescriptor$1 = objectGetOwnPropertyDescriptor.f;\n\tvar nativeDefineProperty$1 = objectDefineProperty.f;\n\tvar nativeGetOwnPropertyNames$1 = objectGetOwnPropertyNamesExternal.f;\n\tvar nativePropertyIsEnumerable$1 = objectPropertyIsEnumerable.f;\n\tvar AllSymbols = shared('symbols');\n\tvar ObjectPrototypeSymbols = shared('op-symbols');\n\tvar StringToSymbolRegistry = shared('string-to-symbol-registry');\n\tvar SymbolToStringRegistry = shared('symbol-to-string-registry');\n\tvar WellKnownSymbolsStore = shared('wks');\n\tvar QObject = global_1.QObject;\n\t// Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173\n\tvar USE_SETTER = !QObject || !QObject[PROTOTYPE$1] || !QObject[PROTOTYPE$1].findChild;\n\n\t// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687\n\tvar setSymbolDescriptor = descriptors && fails(function () {\n\t  return objectCreate(nativeDefineProperty$1({}, 'a', {\n\t    get: function () { return nativeDefineProperty$1(this, 'a', { value: 7 }).a; }\n\t  })).a != 7;\n\t}) ? function (O, P, Attributes) {\n\t  var ObjectPrototypeDescriptor = nativeGetOwnPropertyDescriptor$1(ObjectPrototype$3, P);\n\t  if (ObjectPrototypeDescriptor) delete ObjectPrototype$3[P];\n\t  nativeDefineProperty$1(O, P, Attributes);\n\t  if (ObjectPrototypeDescriptor && O !== ObjectPrototype$3) {\n\t    nativeDefineProperty$1(ObjectPrototype$3, P, ObjectPrototypeDescriptor);\n\t  }\n\t} : nativeDefineProperty$1;\n\n\tvar wrap = function (tag, description) {\n\t  var symbol = AllSymbols[tag] = objectCreate($Symbol[PROTOTYPE$1]);\n\t  setInternalState$4(symbol, {\n\t    type: SYMBOL,\n\t    tag: tag,\n\t    description: description\n\t  });\n\t  if (!descriptors) symbol.description = description;\n\t  return symbol;\n\t};\n\n\tvar isSymbol = nativeSymbol && typeof $Symbol.iterator == 'symbol' ? function (it) {\n\t  return typeof it == 'symbol';\n\t} : function (it) {\n\t  return Object(it) instanceof $Symbol;\n\t};\n\n\tvar $defineProperty = function defineProperty(O, P, Attributes) {\n\t  if (O === ObjectPrototype$3) $defineProperty(ObjectPrototypeSymbols, P, Attributes);\n\t  anObject(O);\n\t  var key = toPrimitive(P, true);\n\t  anObject(Attributes);\n\t  if (has(AllSymbols, key)) {\n\t    if (!Attributes.enumerable) {\n\t      if (!has(O, HIDDEN)) nativeDefineProperty$1(O, HIDDEN, createPropertyDescriptor(1, {}));\n\t      O[HIDDEN][key] = true;\n\t    } else {\n\t      if (has(O, HIDDEN) && O[HIDDEN][key]) O[HIDDEN][key] = false;\n\t      Attributes = objectCreate(Attributes, { enumerable: createPropertyDescriptor(0, false) });\n\t    } return setSymbolDescriptor(O, key, Attributes);\n\t  } return nativeDefineProperty$1(O, key, Attributes);\n\t};\n\n\tvar $defineProperties = function defineProperties(O, Properties) {\n\t  anObject(O);\n\t  var properties = toIndexedObject(Properties);\n\t  var keys = objectKeys(properties).concat($getOwnPropertySymbols(properties));\n\t  $forEach(keys, function (key) {\n\t    if (!descriptors || $propertyIsEnumerable.call(properties, key)) $defineProperty(O, key, properties[key]);\n\t  });\n\t  return O;\n\t};\n\n\tvar $create = function create(O, Properties) {\n\t  return Properties === undefined ? objectCreate(O) : $defineProperties(objectCreate(O), Properties);\n\t};\n\n\tvar $propertyIsEnumerable = function propertyIsEnumerable(V) {\n\t  var P = toPrimitive(V, true);\n\t  var enumerable = nativePropertyIsEnumerable$1.call(this, P);\n\t  if (this === ObjectPrototype$3 && has(AllSymbols, P) && !has(ObjectPrototypeSymbols, P)) return false;\n\t  return enumerable || !has(this, P) || !has(AllSymbols, P) || has(this, HIDDEN) && this[HIDDEN][P] ? enumerable : true;\n\t};\n\n\tvar $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(O, P) {\n\t  var it = toIndexedObject(O);\n\t  var key = toPrimitive(P, true);\n\t  if (it === ObjectPrototype$3 && has(AllSymbols, key) && !has(ObjectPrototypeSymbols, key)) return;\n\t  var descriptor = nativeGetOwnPropertyDescriptor$1(it, key);\n\t  if (descriptor && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key])) {\n\t    descriptor.enumerable = true;\n\t  }\n\t  return descriptor;\n\t};\n\n\tvar $getOwnPropertyNames = function getOwnPropertyNames(O) {\n\t  var names = nativeGetOwnPropertyNames$1(toIndexedObject(O));\n\t  var result = [];\n\t  $forEach(names, function (key) {\n\t    if (!has(AllSymbols, key) && !has(hiddenKeys, key)) result.push(key);\n\t  });\n\t  return result;\n\t};\n\n\tvar $getOwnPropertySymbols = function getOwnPropertySymbols(O) {\n\t  var IS_OBJECT_PROTOTYPE = O === ObjectPrototype$3;\n\t  var names = nativeGetOwnPropertyNames$1(IS_OBJECT_PROTOTYPE ? ObjectPrototypeSymbols : toIndexedObject(O));\n\t  var result = [];\n\t  $forEach(names, function (key) {\n\t    if (has(AllSymbols, key) && (!IS_OBJECT_PROTOTYPE || has(ObjectPrototype$3, key))) {\n\t      result.push(AllSymbols[key]);\n\t    }\n\t  });\n\t  return result;\n\t};\n\n\t// `Symbol` constructor\n\t// https://tc39.github.io/ecma262/#sec-symbol-constructor\n\tif (!nativeSymbol) {\n\t  $Symbol = function Symbol() {\n\t    if (this instanceof $Symbol) throw TypeError('Symbol is not a constructor');\n\t    var description = !arguments.length || arguments[0] === undefined ? undefined : String(arguments[0]);\n\t    var tag = uid(description);\n\t    var setter = function (value) {\n\t      if (this === ObjectPrototype$3) setter.call(ObjectPrototypeSymbols, value);\n\t      if (has(this, HIDDEN) && has(this[HIDDEN], tag)) this[HIDDEN][tag] = false;\n\t      setSymbolDescriptor(this, tag, createPropertyDescriptor(1, value));\n\t    };\n\t    if (descriptors && USE_SETTER) setSymbolDescriptor(ObjectPrototype$3, tag, { configurable: true, set: setter });\n\t    return wrap(tag, description);\n\t  };\n\n\t  redefine($Symbol[PROTOTYPE$1], 'toString', function toString() {\n\t    return getInternalState$2(this).tag;\n\t  });\n\n\t  objectPropertyIsEnumerable.f = $propertyIsEnumerable;\n\t  objectDefineProperty.f = $defineProperty;\n\t  objectGetOwnPropertyDescriptor.f = $getOwnPropertyDescriptor;\n\t  objectGetOwnPropertyNames.f = objectGetOwnPropertyNamesExternal.f = $getOwnPropertyNames;\n\t  objectGetOwnPropertySymbols.f = $getOwnPropertySymbols;\n\n\t  if (descriptors) {\n\t    // https://github.com/tc39/proposal-Symbol-description\n\t    nativeDefineProperty$1($Symbol[PROTOTYPE$1], 'description', {\n\t      configurable: true,\n\t      get: function description() {\n\t        return getInternalState$2(this).description;\n\t      }\n\t    });\n\t    {\n\t      redefine(ObjectPrototype$3, 'propertyIsEnumerable', $propertyIsEnumerable, { unsafe: true });\n\t    }\n\t  }\n\n\t  wrappedWellKnownSymbol.f = function (name) {\n\t    return wrap(wellKnownSymbol(name), name);\n\t  };\n\t}\n\n\t_export({ global: true, wrap: true, forced: !nativeSymbol, sham: !nativeSymbol }, {\n\t  Symbol: $Symbol\n\t});\n\n\t$forEach(objectKeys(WellKnownSymbolsStore), function (name) {\n\t  defineWellKnownSymbol(name);\n\t});\n\n\t_export({ target: SYMBOL, stat: true, forced: !nativeSymbol }, {\n\t  // `Symbol.for` method\n\t  // https://tc39.github.io/ecma262/#sec-symbol.for\n\t  'for': function (key) {\n\t    var string = String(key);\n\t    if (has(StringToSymbolRegistry, string)) return StringToSymbolRegistry[string];\n\t    var symbol = $Symbol(string);\n\t    StringToSymbolRegistry[string] = symbol;\n\t    SymbolToStringRegistry[symbol] = string;\n\t    return symbol;\n\t  },\n\t  // `Symbol.keyFor` method\n\t  // https://tc39.github.io/ecma262/#sec-symbol.keyfor\n\t  keyFor: function keyFor(sym) {\n\t    if (!isSymbol(sym)) throw TypeError(sym + ' is not a symbol');\n\t    if (has(SymbolToStringRegistry, sym)) return SymbolToStringRegistry[sym];\n\t  },\n\t  useSetter: function () { USE_SETTER = true; },\n\t  useSimple: function () { USE_SETTER = false; }\n\t});\n\n\t_export({ target: 'Object', stat: true, forced: !nativeSymbol, sham: !descriptors }, {\n\t  // `Object.create` method\n\t  // https://tc39.github.io/ecma262/#sec-object.create\n\t  create: $create,\n\t  // `Object.defineProperty` method\n\t  // https://tc39.github.io/ecma262/#sec-object.defineproperty\n\t  defineProperty: $defineProperty,\n\t  // `Object.defineProperties` method\n\t  // https://tc39.github.io/ecma262/#sec-object.defineproperties\n\t  defineProperties: $defineProperties,\n\t  // `Object.getOwnPropertyDescriptor` method\n\t  // https://tc39.github.io/ecma262/#sec-object.getownpropertydescriptors\n\t  getOwnPropertyDescriptor: $getOwnPropertyDescriptor\n\t});\n\n\t_export({ target: 'Object', stat: true, forced: !nativeSymbol }, {\n\t  // `Object.getOwnPropertyNames` method\n\t  // https://tc39.github.io/ecma262/#sec-object.getownpropertynames\n\t  getOwnPropertyNames: $getOwnPropertyNames,\n\t  // `Object.getOwnPropertySymbols` method\n\t  // https://tc39.github.io/ecma262/#sec-object.getownpropertysymbols\n\t  getOwnPropertySymbols: $getOwnPropertySymbols\n\t});\n\n\t// Chrome 38 and 39 `Object.getOwnPropertySymbols` fails on primitives\n\t// https://bugs.chromium.org/p/v8/issues/detail?id=3443\n\t_export({ target: 'Object', stat: true, forced: fails(function () { objectGetOwnPropertySymbols.f(1); }) }, {\n\t  getOwnPropertySymbols: function getOwnPropertySymbols(it) {\n\t    return objectGetOwnPropertySymbols.f(toObject(it));\n\t  }\n\t});\n\n\t// `JSON.stringify` method behavior with symbols\n\t// https://tc39.github.io/ecma262/#sec-json.stringify\n\tJSON && _export({ target: 'JSON', stat: true, forced: !nativeSymbol || fails(function () {\n\t  var symbol = $Symbol();\n\t  // MS Edge converts symbol values to JSON as {}\n\t  return nativeJSONStringify([symbol]) != '[null]'\n\t    // WebKit converts symbol values to JSON as null\n\t    || nativeJSONStringify({ a: symbol }) != '{}'\n\t    // V8 throws on boxed symbols\n\t    || nativeJSONStringify(Object(symbol)) != '{}';\n\t}) }, {\n\t  stringify: function stringify(it) {\n\t    var args = [it];\n\t    var index = 1;\n\t    var replacer, $replacer;\n\t    while (arguments.length > index) args.push(arguments[index++]);\n\t    $replacer = replacer = args[1];\n\t    if (!isObject(replacer) && it === undefined || isSymbol(it)) return; // IE8 returns string on undefined\n\t    if (!isArray(replacer)) replacer = function (key, value) {\n\t      if (typeof $replacer == 'function') value = $replacer.call(this, key, value);\n\t      if (!isSymbol(value)) return value;\n\t    };\n\t    args[1] = replacer;\n\t    return nativeJSONStringify.apply(JSON, args);\n\t  }\n\t});\n\n\t// `Symbol.prototype[@@toPrimitive]` method\n\t// https://tc39.github.io/ecma262/#sec-symbol.prototype-@@toprimitive\n\tif (!$Symbol[PROTOTYPE$1][TO_PRIMITIVE]) hide($Symbol[PROTOTYPE$1], TO_PRIMITIVE, $Symbol[PROTOTYPE$1].valueOf);\n\t// `Symbol.prototype[@@toStringTag]` property\n\t// https://tc39.github.io/ecma262/#sec-symbol.prototype-@@tostringtag\n\tsetToStringTag($Symbol, SYMBOL);\n\n\thiddenKeys[HIDDEN] = true;\n\n\tvar getOwnPropertySymbols = path.Object.getOwnPropertySymbols;\n\n\t// `SameValue` abstract operation\n\t// https://tc39.github.io/ecma262/#sec-samevalue\n\tvar sameValue = Object.is || function is(x, y) {\n\t  // eslint-disable-next-line no-self-compare\n\t  return x === y ? x !== 0 || 1 / x === 1 / y : x != x && y != y;\n\t};\n\n\t// `Object.is` method\n\t// https://tc39.github.io/ecma262/#sec-object.is\n\t_export({ target: 'Object', stat: true }, {\n\t  is: sameValue\n\t});\n\n\tvar is = path.Object.is;\n\n\t// `Object.setPrototypeOf` method\n\t// https://tc39.github.io/ecma262/#sec-object.setprototypeof\n\t_export({ target: 'Object', stat: true }, {\n\t  setPrototypeOf: objectSetPrototypeOf\n\t});\n\n\tvar setPrototypeOf = path.Object.setPrototypeOf;\n\n\t// `RegExp.prototype.flags` getter implementation\n\t// https://tc39.github.io/ecma262/#sec-get-regexp.prototype.flags\n\tvar regexpFlags = function () {\n\t  var that = anObject(this);\n\t  var result = '';\n\t  if (that.global) result += 'g';\n\t  if (that.ignoreCase) result += 'i';\n\t  if (that.multiline) result += 'm';\n\t  if (that.dotAll) result += 's';\n\t  if (that.unicode) result += 'u';\n\t  if (that.sticky) result += 'y';\n\t  return result;\n\t};\n\n\t// `RegExp.prototype.flags` getter\n\t// https://tc39.github.io/ecma262/#sec-get-regexp.prototype.flags\n\tif (descriptors && /./g.flags != 'g') {\n\t  objectDefineProperty.f(RegExp.prototype, 'flags', {\n\t    configurable: true,\n\t    get: regexpFlags\n\t  });\n\t}\n\n\tvar MATCH = wellKnownSymbol('match');\n\n\t// `IsRegExp` abstract operation\n\t// https://tc39.github.io/ecma262/#sec-isregexp\n\tvar isRegexp = function (it) {\n\t  var isRegExp;\n\t  return isObject(it) && ((isRegExp = it[MATCH]) !== undefined ? !!isRegExp : classofRaw(it) == 'RegExp');\n\t};\n\n\tvar defineProperty$5 = objectDefineProperty.f;\n\tvar getOwnPropertyNames = objectGetOwnPropertyNames.f;\n\n\n\n\n\n\n\n\tvar MATCH$1 = wellKnownSymbol('match');\n\tvar NativeRegExp = global_1.RegExp;\n\tvar RegExpPrototype = NativeRegExp.prototype;\n\tvar re1 = /a/g;\n\tvar re2 = /a/g;\n\n\t// \"new\" should create a new object, old webkit bug\n\tvar CORRECT_NEW = new NativeRegExp(re1) !== re1;\n\n\tvar FORCED$5 = descriptors && isForced_1('RegExp', (!CORRECT_NEW || fails(function () {\n\t  re2[MATCH$1] = false;\n\t  // RegExp constructor can alter flags and IsRegExp works correct with @@match\n\t  return NativeRegExp(re1) != re1 || NativeRegExp(re2) == re2 || NativeRegExp(re1, 'i') != '/a/i';\n\t})));\n\n\t// `RegExp` constructor\n\t// https://tc39.github.io/ecma262/#sec-regexp-constructor\n\tif (FORCED$5) {\n\t  var RegExpWrapper = function RegExp(pattern, flags) {\n\t    var thisIsRegExp = this instanceof RegExpWrapper;\n\t    var patternIsRegExp = isRegexp(pattern);\n\t    var flagsAreUndefined = flags === undefined;\n\t    return !thisIsRegExp && patternIsRegExp && pattern.constructor === RegExpWrapper && flagsAreUndefined ? pattern\n\t      : inheritIfRequired(CORRECT_NEW\n\t        ? new NativeRegExp(patternIsRegExp && !flagsAreUndefined ? pattern.source : pattern, flags)\n\t        : NativeRegExp((patternIsRegExp = pattern instanceof RegExpWrapper)\n\t          ? pattern.source\n\t          : pattern, patternIsRegExp && flagsAreUndefined ? regexpFlags.call(pattern) : flags)\n\t      , thisIsRegExp ? this : RegExpPrototype, RegExpWrapper);\n\t  };\n\t  var proxy = function (key) {\n\t    key in RegExpWrapper || defineProperty$5(RegExpWrapper, key, {\n\t      configurable: true,\n\t      get: function () { return NativeRegExp[key]; },\n\t      set: function (it) { NativeRegExp[key] = it; }\n\t    });\n\t  };\n\t  var keys$1 = getOwnPropertyNames(NativeRegExp);\n\t  var index = 0;\n\t  while (keys$1.length > index) proxy(keys$1[index++]);\n\t  RegExpPrototype.constructor = RegExpWrapper;\n\t  RegExpWrapper.prototype = RegExpPrototype;\n\t  redefine(global_1, 'RegExp', RegExpWrapper);\n\t}\n\n\t// https://tc39.github.io/ecma262/#sec-get-regexp-@@species\n\tsetSpecies('RegExp');\n\n\tvar codeAt = stringMultibyte.codeAt;\n\n\t// `String.prototype.codePointAt` method\n\t// https://tc39.github.io/ecma262/#sec-string.prototype.codepointat\n\t_export({ target: 'String', proto: true }, {\n\t  codePointAt: function codePointAt(pos) {\n\t    return codeAt(this, pos);\n\t  }\n\t});\n\n\tvar codePointAt = entryUnbind('String', 'codePointAt');\n\n\tvar notARegexp = function (it) {\n\t  if (isRegexp(it)) {\n\t    throw TypeError(\"The method doesn't accept regular expressions\");\n\t  } return it;\n\t};\n\n\tvar MATCH$2 = wellKnownSymbol('match');\n\n\tvar correctIsRegexpLogic = function (METHOD_NAME) {\n\t  var regexp = /./;\n\t  try {\n\t    '/./'[METHOD_NAME](regexp);\n\t  } catch (e) {\n\t    try {\n\t      regexp[MATCH$2] = false;\n\t      return '/./'[METHOD_NAME](regexp);\n\t    } catch (f) { /* empty */ }\n\t  } return false;\n\t};\n\n\t// `String.prototype.includes` method\n\t// https://tc39.github.io/ecma262/#sec-string.prototype.includes\n\t_export({ target: 'String', proto: true, forced: !correctIsRegexpLogic('includes') }, {\n\t  includes: function includes(searchString /* , position = 0 */) {\n\t    return !!~String(requireObjectCoercible(this))\n\t      .indexOf(notARegexp(searchString), arguments.length > 1 ? arguments[1] : undefined);\n\t  }\n\t});\n\n\tvar includes = entryUnbind('String', 'includes');\n\n\tvar nativeEndsWith = ''.endsWith;\n\tvar min$3 = Math.min;\n\n\t// `String.prototype.endsWith` method\n\t// https://tc39.github.io/ecma262/#sec-string.prototype.endswith\n\t_export({ target: 'String', proto: true, forced: !correctIsRegexpLogic('endsWith') }, {\n\t  endsWith: function endsWith(searchString /* , endPosition = @length */) {\n\t    var that = String(requireObjectCoercible(this));\n\t    notARegexp(searchString);\n\t    var endPosition = arguments.length > 1 ? arguments[1] : undefined;\n\t    var len = toLength(that.length);\n\t    var end = endPosition === undefined ? len : min$3(toLength(endPosition), len);\n\t    var search = String(searchString);\n\t    return nativeEndsWith\n\t      ? nativeEndsWith.call(that, search, end)\n\t      : that.slice(end - search.length, end) === search;\n\t  }\n\t});\n\n\tvar endsWith = entryUnbind('String', 'endsWith');\n\n\t// `String.prototype.repeat` method implementation\n\t// https://tc39.github.io/ecma262/#sec-string.prototype.repeat\n\tvar stringRepeat = ''.repeat || function repeat(count) {\n\t  var str = String(requireObjectCoercible(this));\n\t  var result = '';\n\t  var n = toInteger(count);\n\t  if (n < 0 || n == Infinity) throw RangeError('Wrong number of repetitions');\n\t  for (;n > 0; (n >>>= 1) && (str += str)) if (n & 1) result += str;\n\t  return result;\n\t};\n\n\t// `String.prototype.repeat` method\n\t// https://tc39.github.io/ecma262/#sec-string.prototype.repeat\n\t_export({ target: 'String', proto: true }, {\n\t  repeat: stringRepeat\n\t});\n\n\tvar repeat = entryUnbind('String', 'repeat');\n\n\tvar nativeStartsWith = ''.startsWith;\n\tvar min$4 = Math.min;\n\n\t// `String.prototype.startsWith` method\n\t// https://tc39.github.io/ecma262/#sec-string.prototype.startswith\n\t_export({ target: 'String', proto: true, forced: !correctIsRegexpLogic('startsWith') }, {\n\t  startsWith: function startsWith(searchString /* , position = 0 */) {\n\t    var that = String(requireObjectCoercible(this));\n\t    notARegexp(searchString);\n\t    var index = toLength(min$4(arguments.length > 1 ? arguments[1] : undefined, that.length));\n\t    var search = String(searchString);\n\t    return nativeStartsWith\n\t      ? nativeStartsWith.call(that, search, index)\n\t      : that.slice(index, index + search.length) === search;\n\t  }\n\t});\n\n\tvar startsWith = entryUnbind('String', 'startsWith');\n\n\tvar quot = /\"/g;\n\n\t// B.2.3.2.1 CreateHTML(string, tag, attribute, value)\n\t// https://tc39.github.io/ecma262/#sec-createhtml\n\tvar createHtml = function (string, tag, attribute, value) {\n\t  var S = String(requireObjectCoercible(string));\n\t  var p1 = '<' + tag;\n\t  if (attribute !== '') p1 += ' ' + attribute + '=\"' + String(value).replace(quot, '&quot;') + '\"';\n\t  return p1 + '>' + S + '</' + tag + '>';\n\t};\n\n\t// check the existence of a method, lowercase\n\t// of a tag and escaping quotes in arguments\n\tvar forcedStringHtmlMethod = function (METHOD_NAME) {\n\t  return fails(function () {\n\t    var test = ''[METHOD_NAME]('\"');\n\t    return test !== test.toLowerCase() || test.split('\"').length > 3;\n\t  });\n\t};\n\n\t// `String.prototype.anchor` method\n\t// https://tc39.github.io/ecma262/#sec-string.prototype.anchor\n\t_export({ target: 'String', proto: true, forced: forcedStringHtmlMethod('anchor') }, {\n\t  anchor: function anchor(name) {\n\t    return createHtml(this, 'a', 'name', name);\n\t  }\n\t});\n\n\tvar anchor = entryUnbind('String', 'anchor');\n\n\t// `String.prototype.blink` method\n\t// https://tc39.github.io/ecma262/#sec-string.prototype.blink\n\t_export({ target: 'String', proto: true, forced: forcedStringHtmlMethod('blink') }, {\n\t  blink: function blink() {\n\t    return createHtml(this, 'blink', '', '');\n\t  }\n\t});\n\n\tvar blink = entryUnbind('String', 'blink');\n\n\t// `String.prototype.bold` method\n\t// https://tc39.github.io/ecma262/#sec-string.prototype.bold\n\t_export({ target: 'String', proto: true, forced: forcedStringHtmlMethod('bold') }, {\n\t  bold: function bold() {\n\t    return createHtml(this, 'b', '', '');\n\t  }\n\t});\n\n\tvar bold = entryUnbind('String', 'bold');\n\n\t// `String.prototype.fixed` method\n\t// https://tc39.github.io/ecma262/#sec-string.prototype.fixed\n\t_export({ target: 'String', proto: true, forced: forcedStringHtmlMethod('fixed') }, {\n\t  fixed: function fixed() {\n\t    return createHtml(this, 'tt', '', '');\n\t  }\n\t});\n\n\tvar fixed = entryUnbind('String', 'fixed');\n\n\t// `String.prototype.fontcolor` method\n\t// https://tc39.github.io/ecma262/#sec-string.prototype.fontcolor\n\t_export({ target: 'String', proto: true, forced: forcedStringHtmlMethod('fontcolor') }, {\n\t  fontcolor: function fontcolor(color) {\n\t    return createHtml(this, 'font', 'color', color);\n\t  }\n\t});\n\n\tvar fontcolor = entryUnbind('String', 'fontcolor');\n\n\t// `String.prototype.fontsize` method\n\t// https://tc39.github.io/ecma262/#sec-string.prototype.fontsize\n\t_export({ target: 'String', proto: true, forced: forcedStringHtmlMethod('fontsize') }, {\n\t  fontsize: function fontsize(size) {\n\t    return createHtml(this, 'font', 'size', size);\n\t  }\n\t});\n\n\tvar fontsize = entryUnbind('String', 'fontsize');\n\n\t// `String.prototype.italics` method\n\t// https://tc39.github.io/ecma262/#sec-string.prototype.italics\n\t_export({ target: 'String', proto: true, forced: forcedStringHtmlMethod('italics') }, {\n\t  italics: function italics() {\n\t    return createHtml(this, 'i', '', '');\n\t  }\n\t});\n\n\tvar italics = entryUnbind('String', 'italics');\n\n\t// `String.prototype.link` method\n\t// https://tc39.github.io/ecma262/#sec-string.prototype.link\n\t_export({ target: 'String', proto: true, forced: forcedStringHtmlMethod('link') }, {\n\t  link: function link(url) {\n\t    return createHtml(this, 'a', 'href', url);\n\t  }\n\t});\n\n\tvar link = entryUnbind('String', 'link');\n\n\t// `String.prototype.small` method\n\t// https://tc39.github.io/ecma262/#sec-string.prototype.small\n\t_export({ target: 'String', proto: true, forced: forcedStringHtmlMethod('small') }, {\n\t  small: function small() {\n\t    return createHtml(this, 'small', '', '');\n\t  }\n\t});\n\n\tvar small = entryUnbind('String', 'small');\n\n\t// `String.prototype.strike` method\n\t// https://tc39.github.io/ecma262/#sec-string.prototype.strike\n\t_export({ target: 'String', proto: true, forced: forcedStringHtmlMethod('strike') }, {\n\t  strike: function strike() {\n\t    return createHtml(this, 'strike', '', '');\n\t  }\n\t});\n\n\tvar strike = entryUnbind('String', 'strike');\n\n\t// `String.prototype.sub` method\n\t// https://tc39.github.io/ecma262/#sec-string.prototype.sub\n\t_export({ target: 'String', proto: true, forced: forcedStringHtmlMethod('sub') }, {\n\t  sub: function sub() {\n\t    return createHtml(this, 'sub', '', '');\n\t  }\n\t});\n\n\tvar sub = entryUnbind('String', 'sub');\n\n\t// `String.prototype.sup` method\n\t// https://tc39.github.io/ecma262/#sec-string.prototype.sup\n\t_export({ target: 'String', proto: true, forced: forcedStringHtmlMethod('sup') }, {\n\t  sup: function sup() {\n\t    return createHtml(this, 'sup', '', '');\n\t  }\n\t});\n\n\tvar sup = entryUnbind('String', 'sup');\n\n\tvar fromCharCode = String.fromCharCode;\n\tvar nativeFromCodePoint = String.fromCodePoint;\n\n\t// length should be 1, old FF problem\n\tvar INCORRECT_LENGTH = !!nativeFromCodePoint && nativeFromCodePoint.length != 1;\n\n\t// `String.fromCodePoint` method\n\t// https://tc39.github.io/ecma262/#sec-string.fromcodepoint\n\t_export({ target: 'String', stat: true, forced: INCORRECT_LENGTH }, {\n\t  fromCodePoint: function fromCodePoint(x) { // eslint-disable-line no-unused-vars\n\t    var elements = [];\n\t    var length = arguments.length;\n\t    var i = 0;\n\t    var code;\n\t    while (length > i) {\n\t      code = +arguments[i++];\n\t      if (toAbsoluteIndex(code, 0x10FFFF) !== code) throw RangeError(code + ' is not a valid code point');\n\t      elements.push(code < 0x10000\n\t        ? fromCharCode(code)\n\t        : fromCharCode(((code -= 0x10000) >> 10) + 0xD800, code % 0x400 + 0xDC00)\n\t      );\n\t    } return elements.join('');\n\t  }\n\t});\n\n\tvar fromCodePoint = path.String.fromCodePoint;\n\n\t// `String.raw` method\n\t// https://tc39.github.io/ecma262/#sec-string.raw\n\t_export({ target: 'String', stat: true }, {\n\t  raw: function raw(template) {\n\t    var rawTemplate = toIndexedObject(template.raw);\n\t    var literalSegments = toLength(rawTemplate.length);\n\t    var argumentsLength = arguments.length;\n\t    var elements = [];\n\t    var i = 0;\n\t    while (literalSegments > i) {\n\t      elements.push(String(rawTemplate[i++]));\n\t      if (i < argumentsLength) elements.push(String(arguments[i]));\n\t    } return elements.join('');\n\t  }\n\t});\n\n\tvar raw = path.String.raw;\n\n\tvar es2015Core = createCommonjsModule(function (module, exports) {\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\t});\n\n\tunwrapExports(es2015Core);\n\n\t// `Symbol.iterator` well-known symbol\n\t// https://tc39.github.io/ecma262/#sec-symbol.iterator\n\tdefineWellKnownSymbol('iterator');\n\n\tvar iterator = wrappedWellKnownSymbol.f('iterator');\n\n\tvar iterator$1 = entryUnbind('Array', 'values');\n\n\tvar entries = entryUnbind('Array', 'entries');\n\n\tvar keys$2 = entryUnbind('Array', 'keys');\n\n\tvar values = entryUnbind('Array', 'values');\n\n\tvar ITERATOR$6 = wellKnownSymbol('iterator');\n\tvar Uint8Array = global_1.Uint8Array;\n\tvar arrayValues = es_array_iterator.values;\n\tvar arrayKeys = es_array_iterator.keys;\n\tvar arrayEntries = es_array_iterator.entries;\n\tvar aTypedArray$5 = arrayBufferViewCore.aTypedArray;\n\tvar exportProto$1 = arrayBufferViewCore.exportProto;\n\tvar nativeTypedArrayIterator = Uint8Array && Uint8Array.prototype[ITERATOR$6];\n\n\tvar CORRECT_ITER_NAME = !!nativeTypedArrayIterator\n\t  && (nativeTypedArrayIterator.name == 'values' || nativeTypedArrayIterator.name == undefined);\n\n\tvar typedArrayValues = function values() {\n\t  return arrayValues.call(aTypedArray$5(this));\n\t};\n\n\t// `%TypedArray%.prototype.entries` method\n\t// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.entries\n\texportProto$1('entries', function entries() {\n\t  return arrayEntries.call(aTypedArray$5(this));\n\t});\n\t// `%TypedArray%.prototype.keys` method\n\t// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.keys\n\texportProto$1('keys', function keys() {\n\t  return arrayKeys.call(aTypedArray$5(this));\n\t});\n\t// `%TypedArray%.prototype.values` method\n\t// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.values\n\texportProto$1('values', typedArrayValues, !CORRECT_ITER_NAME);\n\t// `%TypedArray%.prototype[@@iterator]` method\n\t// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype-@@iterator\n\texportProto$1(ITERATOR$6, typedArrayValues, !CORRECT_ITER_NAME);\n\n\tvar es2015Iterable = createCommonjsModule(function (module, exports) {\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\t});\n\n\tunwrapExports(es2015Iterable);\n\n\tvar nativePromiseConstructor = global_1.Promise;\n\n\tvar SPECIES$2 = wellKnownSymbol('species');\n\n\t// `SpeciesConstructor` abstract operation\n\t// https://tc39.github.io/ecma262/#sec-speciesconstructor\n\tvar speciesConstructor = function (O, defaultConstructor) {\n\t  var C = anObject(O).constructor;\n\t  var S;\n\t  return C === undefined || (S = anObject(C)[SPECIES$2]) == undefined ? defaultConstructor : aFunction$1(S);\n\t};\n\n\tvar location = global_1.location;\n\tvar set$2 = global_1.setImmediate;\n\tvar clear = global_1.clearImmediate;\n\tvar process = global_1.process;\n\tvar MessageChannel = global_1.MessageChannel;\n\tvar Dispatch = global_1.Dispatch;\n\tvar counter = 0;\n\tvar queue = {};\n\tvar ONREADYSTATECHANGE = 'onreadystatechange';\n\tvar defer, channel, port;\n\n\tvar run = function (id) {\n\t  // eslint-disable-next-line no-prototype-builtins\n\t  if (queue.hasOwnProperty(id)) {\n\t    var fn = queue[id];\n\t    delete queue[id];\n\t    fn();\n\t  }\n\t};\n\n\tvar runner = function (id) {\n\t  return function () {\n\t    run(id);\n\t  };\n\t};\n\n\tvar listener = function (event) {\n\t  run(event.data);\n\t};\n\n\tvar post = function (id) {\n\t  // old engines have not location.origin\n\t  global_1.postMessage(id + '', location.protocol + '//' + location.host);\n\t};\n\n\t// Node.js 0.9+ & IE10+ has setImmediate, otherwise:\n\tif (!set$2 || !clear) {\n\t  set$2 = function setImmediate(fn) {\n\t    var args = [];\n\t    var i = 1;\n\t    while (arguments.length > i) args.push(arguments[i++]);\n\t    queue[++counter] = function () {\n\t      // eslint-disable-next-line no-new-func\n\t      (typeof fn == 'function' ? fn : Function(fn)).apply(undefined, args);\n\t    };\n\t    defer(counter);\n\t    return counter;\n\t  };\n\t  clear = function clearImmediate(id) {\n\t    delete queue[id];\n\t  };\n\t  // Node.js 0.8-\n\t  if (classofRaw(process) == 'process') {\n\t    defer = function (id) {\n\t      process.nextTick(runner(id));\n\t    };\n\t  // Sphere (JS game engine) Dispatch API\n\t  } else if (Dispatch && Dispatch.now) {\n\t    defer = function (id) {\n\t      Dispatch.now(runner(id));\n\t    };\n\t  // Browsers with MessageChannel, includes WebWorkers\n\t  } else if (MessageChannel) {\n\t    channel = new MessageChannel();\n\t    port = channel.port2;\n\t    channel.port1.onmessage = listener;\n\t    defer = bindContext(port.postMessage, port, 1);\n\t  // Browsers with postMessage, skip WebWorkers\n\t  // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'\n\t  } else if (global_1.addEventListener && typeof postMessage == 'function' && !global_1.importScripts && !fails(post)) {\n\t    defer = post;\n\t    global_1.addEventListener('message', listener, false);\n\t  // IE8-\n\t  } else if (ONREADYSTATECHANGE in documentCreateElement('script')) {\n\t    defer = function (id) {\n\t      html.appendChild(documentCreateElement('script'))[ONREADYSTATECHANGE] = function () {\n\t        html.removeChild(this);\n\t        run(id);\n\t      };\n\t    };\n\t  // Rest old browsers\n\t  } else {\n\t    defer = function (id) {\n\t      setTimeout(runner(id), 0);\n\t    };\n\t  }\n\t}\n\n\tvar task = {\n\t  set: set$2,\n\t  clear: clear\n\t};\n\n\tvar userAgent = getBuiltIn('navigator', 'userAgent') || '';\n\n\tvar getOwnPropertyDescriptor$2 = objectGetOwnPropertyDescriptor.f;\n\n\tvar macrotask = task.set;\n\n\n\tvar MutationObserver = global_1.MutationObserver || global_1.WebKitMutationObserver;\n\tvar process$1 = global_1.process;\n\tvar Promise = global_1.Promise;\n\tvar IS_NODE = classofRaw(process$1) == 'process';\n\t// Node.js 11 shows ExperimentalWarning on getting `queueMicrotask`\n\tvar queueMicrotaskDescriptor = getOwnPropertyDescriptor$2(global_1, 'queueMicrotask');\n\tvar queueMicrotask = queueMicrotaskDescriptor && queueMicrotaskDescriptor.value;\n\n\tvar flush, head, last, notify, toggle, node, promise, then;\n\n\t// modern engines have queueMicrotask method\n\tif (!queueMicrotask) {\n\t  flush = function () {\n\t    var parent, fn;\n\t    if (IS_NODE && (parent = process$1.domain)) parent.exit();\n\t    while (head) {\n\t      fn = head.fn;\n\t      head = head.next;\n\t      try {\n\t        fn();\n\t      } catch (error) {\n\t        if (head) notify();\n\t        else last = undefined;\n\t        throw error;\n\t      }\n\t    } last = undefined;\n\t    if (parent) parent.enter();\n\t  };\n\n\t  // Node.js\n\t  if (IS_NODE) {\n\t    notify = function () {\n\t      process$1.nextTick(flush);\n\t    };\n\t  // browsers with MutationObserver, except iOS - https://github.com/zloirock/core-js/issues/339\n\t  } else if (MutationObserver && !/(iphone|ipod|ipad).*applewebkit/i.test(userAgent)) {\n\t    toggle = true;\n\t    node = document.createTextNode('');\n\t    new MutationObserver(flush).observe(node, { characterData: true }); // eslint-disable-line no-new\n\t    notify = function () {\n\t      node.data = toggle = !toggle;\n\t    };\n\t  // environments with maybe non-completely correct, but existent Promise\n\t  } else if (Promise && Promise.resolve) {\n\t    // Promise.resolve without an argument throws an error in LG WebOS 2\n\t    promise = Promise.resolve(undefined);\n\t    then = promise.then;\n\t    notify = function () {\n\t      then.call(promise, flush);\n\t    };\n\t  // for other environments - macrotask based on:\n\t  // - setImmediate\n\t  // - MessageChannel\n\t  // - window.postMessag\n\t  // - onreadystatechange\n\t  // - setTimeout\n\t  } else {\n\t    notify = function () {\n\t      // strange IE + webpack dev server bug - use .call(global)\n\t      macrotask.call(global_1, flush);\n\t    };\n\t  }\n\t}\n\n\tvar microtask = queueMicrotask || function (fn) {\n\t  var task = { fn: fn, next: undefined };\n\t  if (last) last.next = task;\n\t  if (!head) {\n\t    head = task;\n\t    notify();\n\t  } last = task;\n\t};\n\n\tvar PromiseCapability = function (C) {\n\t  var resolve, reject;\n\t  this.promise = new C(function ($$resolve, $$reject) {\n\t    if (resolve !== undefined || reject !== undefined) throw TypeError('Bad Promise constructor');\n\t    resolve = $$resolve;\n\t    reject = $$reject;\n\t  });\n\t  this.resolve = aFunction$1(resolve);\n\t  this.reject = aFunction$1(reject);\n\t};\n\n\t// 25.4.1.5 NewPromiseCapability(C)\n\tvar f$7 = function (C) {\n\t  return new PromiseCapability(C);\n\t};\n\n\tvar newPromiseCapability = {\n\t\tf: f$7\n\t};\n\n\tvar promiseResolve = function (C, x) {\n\t  anObject(C);\n\t  if (isObject(x) && x.constructor === C) return x;\n\t  var promiseCapability = newPromiseCapability.f(C);\n\t  var resolve = promiseCapability.resolve;\n\t  resolve(x);\n\t  return promiseCapability.promise;\n\t};\n\n\tvar hostReportErrors = function (a, b) {\n\t  var console = global_1.console;\n\t  if (console && console.error) {\n\t    arguments.length === 1 ? console.error(a) : console.error(a, b);\n\t  }\n\t};\n\n\tvar perform = function (exec) {\n\t  try {\n\t    return { error: false, value: exec() };\n\t  } catch (error) {\n\t    return { error: true, value: error };\n\t  }\n\t};\n\n\tvar task$1 = task.set;\n\n\n\n\n\n\n\n\n\n\n\tvar SPECIES$3 = wellKnownSymbol('species');\n\tvar PROMISE = 'Promise';\n\tvar getInternalState$3 = internalState.get;\n\tvar setInternalState$5 = internalState.set;\n\tvar getInternalPromiseState = internalState.getterFor(PROMISE);\n\tvar PromiseConstructor = nativePromiseConstructor;\n\tvar TypeError$1 = global_1.TypeError;\n\tvar document$2 = global_1.document;\n\tvar process$2 = global_1.process;\n\tvar $fetch = global_1.fetch;\n\tvar versions = process$2 && process$2.versions;\n\tvar v8 = versions && versions.v8 || '';\n\tvar newPromiseCapability$1 = newPromiseCapability.f;\n\tvar newGenericPromiseCapability = newPromiseCapability$1;\n\tvar IS_NODE$1 = classofRaw(process$2) == 'process';\n\tvar DISPATCH_EVENT = !!(document$2 && document$2.createEvent && global_1.dispatchEvent);\n\tvar UNHANDLED_REJECTION = 'unhandledrejection';\n\tvar REJECTION_HANDLED = 'rejectionhandled';\n\tvar PENDING = 0;\n\tvar FULFILLED = 1;\n\tvar REJECTED = 2;\n\tvar HANDLED = 1;\n\tvar UNHANDLED = 2;\n\tvar Internal, OwnPromiseCapability, PromiseWrapper, nativeThen;\n\n\tvar FORCED$6 = isForced_1(PROMISE, function () {\n\t  // correct subclassing with @@species support\n\t  var promise = PromiseConstructor.resolve(1);\n\t  var empty = function () { /* empty */ };\n\t  var FakePromise = (promise.constructor = {})[SPECIES$3] = function (exec) {\n\t    exec(empty, empty);\n\t  };\n\t  // unhandled rejections tracking support, NodeJS Promise without it fails @@species test\n\t  return !((IS_NODE$1 || typeof PromiseRejectionEvent == 'function')\n\t    && (!isPure || promise['finally'])\n\t    && promise.then(empty) instanceof FakePromise\n\t    // v8 6.6 (Node 10 and Chrome 66) have a bug with resolving custom thenables\n\t    // https://bugs.chromium.org/p/chromium/issues/detail?id=830565\n\t    // we can't detect it synchronously, so just check versions\n\t    && v8.indexOf('6.6') !== 0\n\t    && userAgent.indexOf('Chrome/66') === -1);\n\t});\n\n\tvar INCORRECT_ITERATION$1 = FORCED$6 || !checkCorrectnessOfIteration(function (iterable) {\n\t  PromiseConstructor.all(iterable)['catch'](function () { /* empty */ });\n\t});\n\n\t// helpers\n\tvar isThenable = function (it) {\n\t  var then;\n\t  return isObject(it) && typeof (then = it.then) == 'function' ? then : false;\n\t};\n\n\tvar notify$1 = function (promise, state, isReject) {\n\t  if (state.notified) return;\n\t  state.notified = true;\n\t  var chain = state.reactions;\n\t  microtask(function () {\n\t    var value = state.value;\n\t    var ok = state.state == FULFILLED;\n\t    var index = 0;\n\t    // variable length - can't use forEach\n\t    while (chain.length > index) {\n\t      var reaction = chain[index++];\n\t      var handler = ok ? reaction.ok : reaction.fail;\n\t      var resolve = reaction.resolve;\n\t      var reject = reaction.reject;\n\t      var domain = reaction.domain;\n\t      var result, then, exited;\n\t      try {\n\t        if (handler) {\n\t          if (!ok) {\n\t            if (state.rejection === UNHANDLED) onHandleUnhandled(promise, state);\n\t            state.rejection = HANDLED;\n\t          }\n\t          if (handler === true) result = value;\n\t          else {\n\t            if (domain) domain.enter();\n\t            result = handler(value); // can throw\n\t            if (domain) {\n\t              domain.exit();\n\t              exited = true;\n\t            }\n\t          }\n\t          if (result === reaction.promise) {\n\t            reject(TypeError$1('Promise-chain cycle'));\n\t          } else if (then = isThenable(result)) {\n\t            then.call(result, resolve, reject);\n\t          } else resolve(result);\n\t        } else reject(value);\n\t      } catch (error) {\n\t        if (domain && !exited) domain.exit();\n\t        reject(error);\n\t      }\n\t    }\n\t    state.reactions = [];\n\t    state.notified = false;\n\t    if (isReject && !state.rejection) onUnhandled(promise, state);\n\t  });\n\t};\n\n\tvar dispatchEvent = function (name, promise, reason) {\n\t  var event, handler;\n\t  if (DISPATCH_EVENT) {\n\t    event = document$2.createEvent('Event');\n\t    event.promise = promise;\n\t    event.reason = reason;\n\t    event.initEvent(name, false, true);\n\t    global_1.dispatchEvent(event);\n\t  } else event = { promise: promise, reason: reason };\n\t  if (handler = global_1['on' + name]) handler(event);\n\t  else if (name === UNHANDLED_REJECTION) hostReportErrors('Unhandled promise rejection', reason);\n\t};\n\n\tvar onUnhandled = function (promise, state) {\n\t  task$1.call(global_1, function () {\n\t    var value = state.value;\n\t    var IS_UNHANDLED = isUnhandled(state);\n\t    var result;\n\t    if (IS_UNHANDLED) {\n\t      result = perform(function () {\n\t        if (IS_NODE$1) {\n\t          process$2.emit('unhandledRejection', value, promise);\n\t        } else dispatchEvent(UNHANDLED_REJECTION, promise, value);\n\t      });\n\t      // Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should\n\t      state.rejection = IS_NODE$1 || isUnhandled(state) ? UNHANDLED : HANDLED;\n\t      if (result.error) throw result.value;\n\t    }\n\t  });\n\t};\n\n\tvar isUnhandled = function (state) {\n\t  return state.rejection !== HANDLED && !state.parent;\n\t};\n\n\tvar onHandleUnhandled = function (promise, state) {\n\t  task$1.call(global_1, function () {\n\t    if (IS_NODE$1) {\n\t      process$2.emit('rejectionHandled', promise);\n\t    } else dispatchEvent(REJECTION_HANDLED, promise, state.value);\n\t  });\n\t};\n\n\tvar bind = function (fn, promise, state, unwrap) {\n\t  return function (value) {\n\t    fn(promise, state, value, unwrap);\n\t  };\n\t};\n\n\tvar internalReject = function (promise, state, value, unwrap) {\n\t  if (state.done) return;\n\t  state.done = true;\n\t  if (unwrap) state = unwrap;\n\t  state.value = value;\n\t  state.state = REJECTED;\n\t  notify$1(promise, state, true);\n\t};\n\n\tvar internalResolve = function (promise, state, value, unwrap) {\n\t  if (state.done) return;\n\t  state.done = true;\n\t  if (unwrap) state = unwrap;\n\t  try {\n\t    if (promise === value) throw TypeError$1(\"Promise can't be resolved itself\");\n\t    var then = isThenable(value);\n\t    if (then) {\n\t      microtask(function () {\n\t        var wrapper = { done: false };\n\t        try {\n\t          then.call(value,\n\t            bind(internalResolve, promise, wrapper, state),\n\t            bind(internalReject, promise, wrapper, state)\n\t          );\n\t        } catch (error) {\n\t          internalReject(promise, wrapper, error, state);\n\t        }\n\t      });\n\t    } else {\n\t      state.value = value;\n\t      state.state = FULFILLED;\n\t      notify$1(promise, state, false);\n\t    }\n\t  } catch (error) {\n\t    internalReject(promise, { done: false }, error, state);\n\t  }\n\t};\n\n\t// constructor polyfill\n\tif (FORCED$6) {\n\t  // 25.4.3.1 Promise(executor)\n\t  PromiseConstructor = function Promise(executor) {\n\t    anInstance(this, PromiseConstructor, PROMISE);\n\t    aFunction$1(executor);\n\t    Internal.call(this);\n\t    var state = getInternalState$3(this);\n\t    try {\n\t      executor(bind(internalResolve, this, state), bind(internalReject, this, state));\n\t    } catch (error) {\n\t      internalReject(this, state, error);\n\t    }\n\t  };\n\t  // eslint-disable-next-line no-unused-vars\n\t  Internal = function Promise(executor) {\n\t    setInternalState$5(this, {\n\t      type: PROMISE,\n\t      done: false,\n\t      notified: false,\n\t      parent: false,\n\t      reactions: [],\n\t      rejection: false,\n\t      state: PENDING,\n\t      value: undefined\n\t    });\n\t  };\n\t  Internal.prototype = redefineAll(PromiseConstructor.prototype, {\n\t    // `Promise.prototype.then` method\n\t    // https://tc39.github.io/ecma262/#sec-promise.prototype.then\n\t    then: function then(onFulfilled, onRejected) {\n\t      var state = getInternalPromiseState(this);\n\t      var reaction = newPromiseCapability$1(speciesConstructor(this, PromiseConstructor));\n\t      reaction.ok = typeof onFulfilled == 'function' ? onFulfilled : true;\n\t      reaction.fail = typeof onRejected == 'function' && onRejected;\n\t      reaction.domain = IS_NODE$1 ? process$2.domain : undefined;\n\t      state.parent = true;\n\t      state.reactions.push(reaction);\n\t      if (state.state != PENDING) notify$1(this, state, false);\n\t      return reaction.promise;\n\t    },\n\t    // `Promise.prototype.catch` method\n\t    // https://tc39.github.io/ecma262/#sec-promise.prototype.catch\n\t    'catch': function (onRejected) {\n\t      return this.then(undefined, onRejected);\n\t    }\n\t  });\n\t  OwnPromiseCapability = function () {\n\t    var promise = new Internal();\n\t    var state = getInternalState$3(promise);\n\t    this.promise = promise;\n\t    this.resolve = bind(internalResolve, promise, state);\n\t    this.reject = bind(internalReject, promise, state);\n\t  };\n\t  newPromiseCapability.f = newPromiseCapability$1 = function (C) {\n\t    return C === PromiseConstructor || C === PromiseWrapper\n\t      ? new OwnPromiseCapability(C)\n\t      : newGenericPromiseCapability(C);\n\t  };\n\n\t  if ( typeof nativePromiseConstructor == 'function') {\n\t    nativeThen = nativePromiseConstructor.prototype.then;\n\n\t    // wrap native Promise#then for native async functions\n\t    redefine(nativePromiseConstructor.prototype, 'then', function then(onFulfilled, onRejected) {\n\t      var that = this;\n\t      return new PromiseConstructor(function (resolve, reject) {\n\t        nativeThen.call(that, resolve, reject);\n\t      }).then(onFulfilled, onRejected);\n\t    });\n\n\t    // wrap fetch result\n\t    if (typeof $fetch == 'function') _export({ global: true, enumerable: true, forced: true }, {\n\t      // eslint-disable-next-line no-unused-vars\n\t      fetch: function fetch(input) {\n\t        return promiseResolve(PromiseConstructor, $fetch.apply(global_1, arguments));\n\t      }\n\t    });\n\t  }\n\t}\n\n\t_export({ global: true, wrap: true, forced: FORCED$6 }, {\n\t  Promise: PromiseConstructor\n\t});\n\n\tsetToStringTag(PromiseConstructor, PROMISE, false);\n\tsetSpecies(PROMISE);\n\n\tPromiseWrapper = path[PROMISE];\n\n\t// statics\n\t_export({ target: PROMISE, stat: true, forced: FORCED$6 }, {\n\t  // `Promise.reject` method\n\t  // https://tc39.github.io/ecma262/#sec-promise.reject\n\t  reject: function reject(r) {\n\t    var capability = newPromiseCapability$1(this);\n\t    capability.reject.call(undefined, r);\n\t    return capability.promise;\n\t  }\n\t});\n\n\t_export({ target: PROMISE, stat: true, forced:  FORCED$6 }, {\n\t  // `Promise.resolve` method\n\t  // https://tc39.github.io/ecma262/#sec-promise.resolve\n\t  resolve: function resolve(x) {\n\t    return promiseResolve( this, x);\n\t  }\n\t});\n\n\t_export({ target: PROMISE, stat: true, forced: INCORRECT_ITERATION$1 }, {\n\t  // `Promise.all` method\n\t  // https://tc39.github.io/ecma262/#sec-promise.all\n\t  all: function all(iterable) {\n\t    var C = this;\n\t    var capability = newPromiseCapability$1(C);\n\t    var resolve = capability.resolve;\n\t    var reject = capability.reject;\n\t    var result = perform(function () {\n\t      var $promiseResolve = aFunction$1(C.resolve);\n\t      var values = [];\n\t      var counter = 0;\n\t      var remaining = 1;\n\t      iterate_1(iterable, function (promise) {\n\t        var index = counter++;\n\t        var alreadyCalled = false;\n\t        values.push(undefined);\n\t        remaining++;\n\t        $promiseResolve.call(C, promise).then(function (value) {\n\t          if (alreadyCalled) return;\n\t          alreadyCalled = true;\n\t          values[index] = value;\n\t          --remaining || resolve(values);\n\t        }, reject);\n\t      });\n\t      --remaining || resolve(values);\n\t    });\n\t    if (result.error) reject(result.value);\n\t    return capability.promise;\n\t  },\n\t  // `Promise.race` method\n\t  // https://tc39.github.io/ecma262/#sec-promise.race\n\t  race: function race(iterable) {\n\t    var C = this;\n\t    var capability = newPromiseCapability$1(C);\n\t    var reject = capability.reject;\n\t    var result = perform(function () {\n\t      var $promiseResolve = aFunction$1(C.resolve);\n\t      iterate_1(iterable, function (promise) {\n\t        $promiseResolve.call(C, promise).then(capability.resolve, reject);\n\t      });\n\t    });\n\t    if (result.error) reject(result.value);\n\t    return capability.promise;\n\t  }\n\t});\n\n\t// `Promise.allSettled` method\n\t// https://github.com/tc39/proposal-promise-allSettled\n\t_export({ target: 'Promise', stat: true }, {\n\t  allSettled: function allSettled(iterable) {\n\t    var C = this;\n\t    var capability = newPromiseCapability.f(C);\n\t    var resolve = capability.resolve;\n\t    var reject = capability.reject;\n\t    var result = perform(function () {\n\t      var promiseResolve = aFunction$1(C.resolve);\n\t      var values = [];\n\t      var counter = 0;\n\t      var remaining = 1;\n\t      iterate_1(iterable, function (promise) {\n\t        var index = counter++;\n\t        var alreadyCalled = false;\n\t        values.push(undefined);\n\t        remaining++;\n\t        promiseResolve.call(C, promise).then(function (value) {\n\t          if (alreadyCalled) return;\n\t          alreadyCalled = true;\n\t          values[index] = { status: 'fulfilled', value: value };\n\t          --remaining || resolve(values);\n\t        }, function (e) {\n\t          if (alreadyCalled) return;\n\t          alreadyCalled = true;\n\t          values[index] = { status: 'rejected', reason: e };\n\t          --remaining || resolve(values);\n\t        });\n\t      });\n\t      --remaining || resolve(values);\n\t    });\n\t    if (result.error) reject(result.value);\n\t    return capability.promise;\n\t  }\n\t});\n\n\t// `Promise.prototype.finally` method\n\t// https://tc39.github.io/ecma262/#sec-promise.prototype.finally\n\t_export({ target: 'Promise', proto: true, real: true }, {\n\t  'finally': function (onFinally) {\n\t    var C = speciesConstructor(this, getBuiltIn('Promise'));\n\t    var isFunction = typeof onFinally == 'function';\n\t    return this.then(\n\t      isFunction ? function (x) {\n\t        return promiseResolve(C, onFinally()).then(function () { return x; });\n\t      } : onFinally,\n\t      isFunction ? function (e) {\n\t        return promiseResolve(C, onFinally()).then(function () { throw e; });\n\t      } : onFinally\n\t    );\n\t  }\n\t});\n\n\t// patch native Promise.prototype for native async functions\n\tif ( typeof nativePromiseConstructor == 'function' && !nativePromiseConstructor.prototype['finally']) {\n\t  redefine(nativePromiseConstructor.prototype, 'finally', getBuiltIn('Promise').prototype['finally']);\n\t}\n\n\tvar promise$1 = path.Promise;\n\n\tvar es2015Promise = createCommonjsModule(function (module, exports) {\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\t});\n\n\tunwrapExports(es2015Promise);\n\n\tvar nativeApply = getBuiltIn('Reflect', 'apply');\n\tvar functionApply = Function.apply;\n\n\t// MS Edge argumentsList argument is optional\n\tvar OPTIONAL_ARGUMENTS_LIST = !fails(function () {\n\t  nativeApply(function () { /* empty */ });\n\t});\n\n\t// `Reflect.apply` method\n\t// https://tc39.github.io/ecma262/#sec-reflect.apply\n\t_export({ target: 'Reflect', stat: true, forced: OPTIONAL_ARGUMENTS_LIST }, {\n\t  apply: function apply(target, thisArgument, argumentsList) {\n\t    aFunction$1(target);\n\t    anObject(argumentsList);\n\t    return nativeApply\n\t      ? nativeApply(target, thisArgument, argumentsList)\n\t      : functionApply.call(target, thisArgument, argumentsList);\n\t  }\n\t});\n\n\tvar apply = path.Reflect.apply;\n\n\tvar slice = [].slice;\n\tvar factories = {};\n\n\tvar construct = function (C, argsLength, args) {\n\t  if (!(argsLength in factories)) {\n\t    for (var list = [], i = 0; i < argsLength; i++) list[i] = 'a[' + i + ']';\n\t    // eslint-disable-next-line no-new-func\n\t    factories[argsLength] = Function('C,a', 'return new C(' + list.join(',') + ')');\n\t  } return factories[argsLength](C, args);\n\t};\n\n\t// `Function.prototype.bind` method implementation\n\t// https://tc39.github.io/ecma262/#sec-function.prototype.bind\n\tvar functionBind = Function.bind || function bind(that /* , ...args */) {\n\t  var fn = aFunction$1(this);\n\t  var partArgs = slice.call(arguments, 1);\n\t  var boundFunction = function bound(/* args... */) {\n\t    var args = partArgs.concat(slice.call(arguments));\n\t    return this instanceof boundFunction ? construct(fn, args.length, args) : fn.apply(that, args);\n\t  };\n\t  if (isObject(fn.prototype)) boundFunction.prototype = fn.prototype;\n\t  return boundFunction;\n\t};\n\n\tvar nativeConstruct = getBuiltIn('Reflect', 'construct');\n\n\t// `Reflect.construct` method\n\t// https://tc39.github.io/ecma262/#sec-reflect.construct\n\t// MS Edge supports only 2 arguments and argumentsList argument is optional\n\t// FF Nightly sets third argument as `new.target`, but does not create `this` from it\n\tvar NEW_TARGET_BUG = fails(function () {\n\t  function F() { /* empty */ }\n\t  return !(nativeConstruct(function () { /* empty */ }, [], F) instanceof F);\n\t});\n\tvar ARGS_BUG = !fails(function () {\n\t  nativeConstruct(function () { /* empty */ });\n\t});\n\tvar FORCED$7 = NEW_TARGET_BUG || ARGS_BUG;\n\n\t_export({ target: 'Reflect', stat: true, forced: FORCED$7, sham: FORCED$7 }, {\n\t  construct: function construct(Target, args /* , newTarget */) {\n\t    aFunction$1(Target);\n\t    anObject(args);\n\t    var newTarget = arguments.length < 3 ? Target : aFunction$1(arguments[2]);\n\t    if (ARGS_BUG && !NEW_TARGET_BUG) return nativeConstruct(Target, args, newTarget);\n\t    if (Target == newTarget) {\n\t      // w/o altered newTarget, optimization for 0-4 arguments\n\t      switch (args.length) {\n\t        case 0: return new Target();\n\t        case 1: return new Target(args[0]);\n\t        case 2: return new Target(args[0], args[1]);\n\t        case 3: return new Target(args[0], args[1], args[2]);\n\t        case 4: return new Target(args[0], args[1], args[2], args[3]);\n\t      }\n\t      // w/o altered newTarget, lot of arguments case\n\t      var $args = [null];\n\t      $args.push.apply($args, args);\n\t      return new (functionBind.apply(Target, $args))();\n\t    }\n\t    // with altered newTarget, not support built-in constructors\n\t    var proto = newTarget.prototype;\n\t    var instance = objectCreate(isObject(proto) ? proto : Object.prototype);\n\t    var result = Function.apply.call(Target, instance, args);\n\t    return isObject(result) ? result : instance;\n\t  }\n\t});\n\n\tvar construct$1 = path.Reflect.construct;\n\n\t// MS Edge has broken Reflect.defineProperty - throwing instead of returning false\n\tvar ERROR_INSTEAD_OF_FALSE = fails(function () {\n\t  // eslint-disable-next-line no-undef\n\t  Reflect.defineProperty(objectDefineProperty.f({}, 1, { value: 1 }), 1, { value: 2 });\n\t});\n\n\t// `Reflect.defineProperty` method\n\t// https://tc39.github.io/ecma262/#sec-reflect.defineproperty\n\t_export({ target: 'Reflect', stat: true, forced: ERROR_INSTEAD_OF_FALSE, sham: !descriptors }, {\n\t  defineProperty: function defineProperty(target, propertyKey, attributes) {\n\t    anObject(target);\n\t    var key = toPrimitive(propertyKey, true);\n\t    anObject(attributes);\n\t    try {\n\t      objectDefineProperty.f(target, key, attributes);\n\t      return true;\n\t    } catch (error) {\n\t      return false;\n\t    }\n\t  }\n\t});\n\n\tvar defineProperty$6 = path.Reflect.defineProperty;\n\n\tvar getOwnPropertyDescriptor$3 = objectGetOwnPropertyDescriptor.f;\n\n\t// `Reflect.deleteProperty` method\n\t// https://tc39.github.io/ecma262/#sec-reflect.deleteproperty\n\t_export({ target: 'Reflect', stat: true }, {\n\t  deleteProperty: function deleteProperty(target, propertyKey) {\n\t    var descriptor = getOwnPropertyDescriptor$3(anObject(target), propertyKey);\n\t    return descriptor && !descriptor.configurable ? false : delete target[propertyKey];\n\t  }\n\t});\n\n\tvar deleteProperty = path.Reflect.deleteProperty;\n\n\t// `Reflect.get` method\n\t// https://tc39.github.io/ecma262/#sec-reflect.get\n\tfunction get$1(target, propertyKey /* , receiver */) {\n\t  var receiver = arguments.length < 3 ? target : arguments[2];\n\t  var descriptor, prototype;\n\t  if (anObject(target) === receiver) return target[propertyKey];\n\t  if (descriptor = objectGetOwnPropertyDescriptor.f(target, propertyKey)) return has(descriptor, 'value')\n\t    ? descriptor.value\n\t    : descriptor.get === undefined\n\t      ? undefined\n\t      : descriptor.get.call(receiver);\n\t  if (isObject(prototype = objectGetPrototypeOf(target))) return get$1(prototype, propertyKey, receiver);\n\t}\n\n\t_export({ target: 'Reflect', stat: true }, {\n\t  get: get$1\n\t});\n\n\tvar get$2 = path.Reflect.get;\n\n\t// `Reflect.getOwnPropertyDescriptor` method\n\t// https://tc39.github.io/ecma262/#sec-reflect.getownpropertydescriptor\n\t_export({ target: 'Reflect', stat: true, sham: !descriptors }, {\n\t  getOwnPropertyDescriptor: function getOwnPropertyDescriptor(target, propertyKey) {\n\t    return objectGetOwnPropertyDescriptor.f(anObject(target), propertyKey);\n\t  }\n\t});\n\n\tvar getOwnPropertyDescriptor$4 = path.Reflect.getOwnPropertyDescriptor;\n\n\t// `Reflect.getPrototypeOf` method\n\t// https://tc39.github.io/ecma262/#sec-reflect.getprototypeof\n\t_export({ target: 'Reflect', stat: true, sham: !correctPrototypeGetter }, {\n\t  getPrototypeOf: function getPrototypeOf(target) {\n\t    return objectGetPrototypeOf(anObject(target));\n\t  }\n\t});\n\n\tvar getPrototypeOf = path.Reflect.getPrototypeOf;\n\n\t// `Reflect.has` method\n\t// https://tc39.github.io/ecma262/#sec-reflect.has\n\t_export({ target: 'Reflect', stat: true }, {\n\t  has: function has(target, propertyKey) {\n\t    return propertyKey in target;\n\t  }\n\t});\n\n\tvar has$2 = path.Reflect.has;\n\n\tvar objectIsExtensible = Object.isExtensible;\n\n\t// `Reflect.isExtensible` method\n\t// https://tc39.github.io/ecma262/#sec-reflect.isextensible\n\t_export({ target: 'Reflect', stat: true }, {\n\t  isExtensible: function isExtensible(target) {\n\t    anObject(target);\n\t    return objectIsExtensible ? objectIsExtensible(target) : true;\n\t  }\n\t});\n\n\tvar isExtensible = path.Reflect.isExtensible;\n\n\t// `Reflect.ownKeys` method\n\t// https://tc39.github.io/ecma262/#sec-reflect.ownkeys\n\t_export({ target: 'Reflect', stat: true }, {\n\t  ownKeys: ownKeys\n\t});\n\n\tvar ownKeys$1 = path.Reflect.ownKeys;\n\n\t// `Reflect.preventExtensions` method\n\t// https://tc39.github.io/ecma262/#sec-reflect.preventextensions\n\t_export({ target: 'Reflect', stat: true, sham: !freezing }, {\n\t  preventExtensions: function preventExtensions(target) {\n\t    anObject(target);\n\t    try {\n\t      var objectPreventExtensions = getBuiltIn('Object', 'preventExtensions');\n\t      if (objectPreventExtensions) objectPreventExtensions(target);\n\t      return true;\n\t    } catch (error) {\n\t      return false;\n\t    }\n\t  }\n\t});\n\n\tvar preventExtensions = path.Reflect.preventExtensions;\n\n\t// `Reflect.set` method\n\t// https://tc39.github.io/ecma262/#sec-reflect.set\n\tfunction set$3(target, propertyKey, V /* , receiver */) {\n\t  var receiver = arguments.length < 4 ? target : arguments[3];\n\t  var ownDescriptor = objectGetOwnPropertyDescriptor.f(anObject(target), propertyKey);\n\t  var existingDescriptor, prototype;\n\t  if (!ownDescriptor) {\n\t    if (isObject(prototype = objectGetPrototypeOf(target))) {\n\t      return set$3(prototype, propertyKey, V, receiver);\n\t    }\n\t    ownDescriptor = createPropertyDescriptor(0);\n\t  }\n\t  if (has(ownDescriptor, 'value')) {\n\t    if (ownDescriptor.writable === false || !isObject(receiver)) return false;\n\t    if (existingDescriptor = objectGetOwnPropertyDescriptor.f(receiver, propertyKey)) {\n\t      if (existingDescriptor.get || existingDescriptor.set || existingDescriptor.writable === false) return false;\n\t      existingDescriptor.value = V;\n\t      objectDefineProperty.f(receiver, propertyKey, existingDescriptor);\n\t    } else objectDefineProperty.f(receiver, propertyKey, createPropertyDescriptor(0, V));\n\t    return true;\n\t  }\n\t  return ownDescriptor.set === undefined ? false : (ownDescriptor.set.call(receiver, V), true);\n\t}\n\n\t_export({ target: 'Reflect', stat: true }, {\n\t  set: set$3\n\t});\n\n\tvar set$4 = path.Reflect.set;\n\n\t// `Reflect.setPrototypeOf` method\n\t// https://tc39.github.io/ecma262/#sec-reflect.setprototypeof\n\tif (objectSetPrototypeOf) _export({ target: 'Reflect', stat: true }, {\n\t  setPrototypeOf: function setPrototypeOf(target, proto) {\n\t    anObject(target);\n\t    aPossiblePrototype(proto);\n\t    try {\n\t      objectSetPrototypeOf(target, proto);\n\t      return true;\n\t    } catch (error) {\n\t      return false;\n\t    }\n\t  }\n\t});\n\n\tvar setPrototypeOf$1 = path.Reflect.setPrototypeOf;\n\n\tvar es2015Reflect = createCommonjsModule(function (module, exports) {\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\t});\n\n\tunwrapExports(es2015Reflect);\n\n\tvar $includes = arrayIncludes.includes;\n\n\n\t// `Array.prototype.includes` method\n\t// https://tc39.github.io/ecma262/#sec-array.prototype.includes\n\t_export({ target: 'Array', proto: true }, {\n\t  includes: function includes(el /* , fromIndex = 0 */) {\n\t    return $includes(this, el, arguments.length > 1 ? arguments[1] : undefined);\n\t  }\n\t});\n\n\t// https://tc39.github.io/ecma262/#sec-array.prototype-@@unscopables\n\taddToUnscopables('includes');\n\n\tvar includes$1 = entryUnbind('Array', 'includes');\n\n\tvar $includes$1 = arrayIncludes.includes;\n\n\tvar aTypedArray$6 = arrayBufferViewCore.aTypedArray;\n\n\t// `%TypedArray%.prototype.includes` method\n\t// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.includes\n\tarrayBufferViewCore.exportProto('includes', function includes(searchElement /* , fromIndex */) {\n\t  return $includes$1(aTypedArray$6(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);\n\t});\n\n\tvar es2016ArrayInclude = createCommonjsModule(function (module, exports) {\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\t});\n\n\tunwrapExports(es2016ArrayInclude);\n\n\tvar propertyIsEnumerable = objectPropertyIsEnumerable.f;\n\n\t// `Object.{ entries, values }` methods implementation\n\tvar createMethod$4 = function (TO_ENTRIES) {\n\t  return function (it) {\n\t    var O = toIndexedObject(it);\n\t    var keys = objectKeys(O);\n\t    var length = keys.length;\n\t    var i = 0;\n\t    var result = [];\n\t    var key;\n\t    while (length > i) {\n\t      key = keys[i++];\n\t      if (!descriptors || propertyIsEnumerable.call(O, key)) {\n\t        result.push(TO_ENTRIES ? [key, O[key]] : O[key]);\n\t      }\n\t    }\n\t    return result;\n\t  };\n\t};\n\n\tvar objectToArray = {\n\t  // `Object.entries` method\n\t  // https://tc39.github.io/ecma262/#sec-object.entries\n\t  entries: createMethod$4(true),\n\t  // `Object.values` method\n\t  // https://tc39.github.io/ecma262/#sec-object.values\n\t  values: createMethod$4(false)\n\t};\n\n\tvar $values = objectToArray.values;\n\n\t// `Object.values` method\n\t// https://tc39.github.io/ecma262/#sec-object.values\n\t_export({ target: 'Object', stat: true }, {\n\t  values: function values(O) {\n\t    return $values(O);\n\t  }\n\t});\n\n\tvar values$1 = path.Object.values;\n\n\tvar $entries = objectToArray.entries;\n\n\t// `Object.entries` method\n\t// https://tc39.github.io/ecma262/#sec-object.entries\n\t_export({ target: 'Object', stat: true }, {\n\t  entries: function entries(O) {\n\t    return $entries(O);\n\t  }\n\t});\n\n\tvar entries$1 = path.Object.entries;\n\n\t// `Object.getOwnPropertyDescriptors` method\n\t// https://tc39.github.io/ecma262/#sec-object.getownpropertydescriptors\n\t_export({ target: 'Object', stat: true, sham: !descriptors }, {\n\t  getOwnPropertyDescriptors: function getOwnPropertyDescriptors(object) {\n\t    var O = toIndexedObject(object);\n\t    var getOwnPropertyDescriptor = objectGetOwnPropertyDescriptor.f;\n\t    var keys = ownKeys(O);\n\t    var result = {};\n\t    var index = 0;\n\t    var key, descriptor;\n\t    while (keys.length > index) {\n\t      descriptor = getOwnPropertyDescriptor(O, key = keys[index++]);\n\t      if (descriptor !== undefined) createProperty(result, key, descriptor);\n\t    }\n\t    return result;\n\t  }\n\t});\n\n\tvar getOwnPropertyDescriptors = path.Object.getOwnPropertyDescriptors;\n\n\tvar es2017Object = createCommonjsModule(function (module, exports) {\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\t});\n\n\tunwrapExports(es2017Object);\n\n\t// https://github.com/tc39/proposal-string-pad-start-end\n\n\n\n\n\tvar ceil$2 = Math.ceil;\n\n\t// `String.prototype.{ padStart, padEnd }` methods implementation\n\tvar createMethod$5 = function (IS_END) {\n\t  return function ($this, maxLength, fillString) {\n\t    var S = String(requireObjectCoercible($this));\n\t    var stringLength = S.length;\n\t    var fillStr = fillString === undefined ? ' ' : String(fillString);\n\t    var intMaxLength = toLength(maxLength);\n\t    var fillLen, stringFiller;\n\t    if (intMaxLength <= stringLength || fillStr == '') return S;\n\t    fillLen = intMaxLength - stringLength;\n\t    stringFiller = stringRepeat.call(fillStr, ceil$2(fillLen / fillStr.length));\n\t    if (stringFiller.length > fillLen) stringFiller = stringFiller.slice(0, fillLen);\n\t    return IS_END ? S + stringFiller : stringFiller + S;\n\t  };\n\t};\n\n\tvar stringPad = {\n\t  // `String.prototype.padStart` method\n\t  // https://tc39.github.io/ecma262/#sec-string.prototype.padstart\n\t  start: createMethod$5(false),\n\t  // `String.prototype.padEnd` method\n\t  // https://tc39.github.io/ecma262/#sec-string.prototype.padend\n\t  end: createMethod$5(true)\n\t};\n\n\t// https://github.com/zloirock/core-js/issues/280\n\n\n\t// eslint-disable-next-line unicorn/no-unsafe-regex\n\tvar webkitStringPadBug = /Version\\/10\\.\\d+(\\.\\d+)?( Mobile\\/\\w+)? Safari\\//.test(userAgent);\n\n\tvar $padStart = stringPad.start;\n\n\n\t// `String.prototype.padStart` method\n\t// https://tc39.github.io/ecma262/#sec-string.prototype.padstart\n\t_export({ target: 'String', proto: true, forced: webkitStringPadBug }, {\n\t  padStart: function padStart(maxLength /* , fillString = ' ' */) {\n\t    return $padStart(this, maxLength, arguments.length > 1 ? arguments[1] : undefined);\n\t  }\n\t});\n\n\tvar padStart = entryUnbind('String', 'padStart');\n\n\tvar $padEnd = stringPad.end;\n\n\n\t// `String.prototype.padEnd` method\n\t// https://tc39.github.io/ecma262/#sec-string.prototype.padend\n\t_export({ target: 'String', proto: true, forced: webkitStringPadBug }, {\n\t  padEnd: function padEnd(maxLength /* , fillString = ' ' */) {\n\t    return $padEnd(this, maxLength, arguments.length > 1 ? arguments[1] : undefined);\n\t  }\n\t});\n\n\tvar padEnd = entryUnbind('String', 'padEnd');\n\n\tvar es2017String = createCommonjsModule(function (module, exports) {\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\t});\n\n\tunwrapExports(es2017String);\n\n\t// `ToIndex` abstract operation\n\t// https://tc39.github.io/ecma262/#sec-toindex\n\tvar toIndex = function (it) {\n\t  if (it === undefined) return 0;\n\t  var number = toInteger(it);\n\t  var length = toLength(number);\n\t  if (number !== length) throw RangeError('Wrong length or index');\n\t  return length;\n\t};\n\n\tvar arrayBuffer = createCommonjsModule(function (module, exports) {\n\n\n\tvar NATIVE_ARRAY_BUFFER = arrayBufferViewCore.NATIVE_ARRAY_BUFFER;\n\n\n\n\n\n\n\n\tvar getOwnPropertyNames = objectGetOwnPropertyNames.f;\n\tvar defineProperty = objectDefineProperty.f;\n\n\n\n\n\tvar getInternalState = internalState.get;\n\tvar setInternalState = internalState.set;\n\tvar ARRAY_BUFFER = 'ArrayBuffer';\n\tvar DATA_VIEW = 'DataView';\n\tvar PROTOTYPE = 'prototype';\n\tvar WRONG_LENGTH = 'Wrong length';\n\tvar WRONG_INDEX = 'Wrong index';\n\tvar NativeArrayBuffer = global_1[ARRAY_BUFFER];\n\tvar $ArrayBuffer = NativeArrayBuffer;\n\tvar $DataView = global_1[DATA_VIEW];\n\tvar Math = global_1.Math;\n\tvar RangeError = global_1.RangeError;\n\t// eslint-disable-next-line no-shadow-restricted-names\n\tvar Infinity = 1 / 0;\n\tvar abs = Math.abs;\n\tvar pow = Math.pow;\n\tvar floor = Math.floor;\n\tvar log = Math.log;\n\tvar LN2 = Math.LN2;\n\n\t// IEEE754 conversions based on https://github.com/feross/ieee754\n\tvar packIEEE754 = function (number, mantissaLength, bytes) {\n\t  var buffer = new Array(bytes);\n\t  var exponentLength = bytes * 8 - mantissaLength - 1;\n\t  var eMax = (1 << exponentLength) - 1;\n\t  var eBias = eMax >> 1;\n\t  var rt = mantissaLength === 23 ? pow(2, -24) - pow(2, -77) : 0;\n\t  var sign = number < 0 || number === 0 && 1 / number < 0 ? 1 : 0;\n\t  var index = 0;\n\t  var exponent, mantissa, c;\n\t  number = abs(number);\n\t  // eslint-disable-next-line no-self-compare\n\t  if (number != number || number === Infinity) {\n\t    // eslint-disable-next-line no-self-compare\n\t    mantissa = number != number ? 1 : 0;\n\t    exponent = eMax;\n\t  } else {\n\t    exponent = floor(log(number) / LN2);\n\t    if (number * (c = pow(2, -exponent)) < 1) {\n\t      exponent--;\n\t      c *= 2;\n\t    }\n\t    if (exponent + eBias >= 1) {\n\t      number += rt / c;\n\t    } else {\n\t      number += rt * pow(2, 1 - eBias);\n\t    }\n\t    if (number * c >= 2) {\n\t      exponent++;\n\t      c /= 2;\n\t    }\n\t    if (exponent + eBias >= eMax) {\n\t      mantissa = 0;\n\t      exponent = eMax;\n\t    } else if (exponent + eBias >= 1) {\n\t      mantissa = (number * c - 1) * pow(2, mantissaLength);\n\t      exponent = exponent + eBias;\n\t    } else {\n\t      mantissa = number * pow(2, eBias - 1) * pow(2, mantissaLength);\n\t      exponent = 0;\n\t    }\n\t  }\n\t  for (; mantissaLength >= 8; buffer[index++] = mantissa & 255, mantissa /= 256, mantissaLength -= 8);\n\t  exponent = exponent << mantissaLength | mantissa;\n\t  exponentLength += mantissaLength;\n\t  for (; exponentLength > 0; buffer[index++] = exponent & 255, exponent /= 256, exponentLength -= 8);\n\t  buffer[--index] |= sign * 128;\n\t  return buffer;\n\t};\n\n\tvar unpackIEEE754 = function (buffer, mantissaLength) {\n\t  var bytes = buffer.length;\n\t  var exponentLength = bytes * 8 - mantissaLength - 1;\n\t  var eMax = (1 << exponentLength) - 1;\n\t  var eBias = eMax >> 1;\n\t  var nBits = exponentLength - 7;\n\t  var index = bytes - 1;\n\t  var sign = buffer[index--];\n\t  var exponent = sign & 127;\n\t  var mantissa;\n\t  sign >>= 7;\n\t  for (; nBits > 0; exponent = exponent * 256 + buffer[index], index--, nBits -= 8);\n\t  mantissa = exponent & (1 << -nBits) - 1;\n\t  exponent >>= -nBits;\n\t  nBits += mantissaLength;\n\t  for (; nBits > 0; mantissa = mantissa * 256 + buffer[index], index--, nBits -= 8);\n\t  if (exponent === 0) {\n\t    exponent = 1 - eBias;\n\t  } else if (exponent === eMax) {\n\t    return mantissa ? NaN : sign ? -Infinity : Infinity;\n\t  } else {\n\t    mantissa = mantissa + pow(2, mantissaLength);\n\t    exponent = exponent - eBias;\n\t  } return (sign ? -1 : 1) * mantissa * pow(2, exponent - mantissaLength);\n\t};\n\n\tvar unpackInt32 = function (buffer) {\n\t  return buffer[3] << 24 | buffer[2] << 16 | buffer[1] << 8 | buffer[0];\n\t};\n\n\tvar packInt8 = function (number) {\n\t  return [number & 0xFF];\n\t};\n\n\tvar packInt16 = function (number) {\n\t  return [number & 0xFF, number >> 8 & 0xFF];\n\t};\n\n\tvar packInt32 = function (number) {\n\t  return [number & 0xFF, number >> 8 & 0xFF, number >> 16 & 0xFF, number >> 24 & 0xFF];\n\t};\n\n\tvar packFloat32 = function (number) {\n\t  return packIEEE754(number, 23, 4);\n\t};\n\n\tvar packFloat64 = function (number) {\n\t  return packIEEE754(number, 52, 8);\n\t};\n\n\tvar addGetter = function (Constructor, key) {\n\t  defineProperty(Constructor[PROTOTYPE], key, { get: function () { return getInternalState(this)[key]; } });\n\t};\n\n\tvar get = function (view, count, index, isLittleEndian) {\n\t  var numIndex = +index;\n\t  var intIndex = toIndex(numIndex);\n\t  var store = getInternalState(view);\n\t  if (intIndex + count > store.byteLength) throw RangeError(WRONG_INDEX);\n\t  var bytes = getInternalState(store.buffer).bytes;\n\t  var start = intIndex + store.byteOffset;\n\t  var pack = bytes.slice(start, start + count);\n\t  return isLittleEndian ? pack : pack.reverse();\n\t};\n\n\tvar set = function (view, count, index, conversion, value, isLittleEndian) {\n\t  var numIndex = +index;\n\t  var intIndex = toIndex(numIndex);\n\t  var store = getInternalState(view);\n\t  if (intIndex + count > store.byteLength) throw RangeError(WRONG_INDEX);\n\t  var bytes = getInternalState(store.buffer).bytes;\n\t  var start = intIndex + store.byteOffset;\n\t  var pack = conversion(+value);\n\t  for (var i = 0; i < count; i++) bytes[start + i] = pack[isLittleEndian ? i : count - i - 1];\n\t};\n\n\tif (!NATIVE_ARRAY_BUFFER) {\n\t  $ArrayBuffer = function ArrayBuffer(length) {\n\t    anInstance(this, $ArrayBuffer, ARRAY_BUFFER);\n\t    var byteLength = toIndex(length);\n\t    setInternalState(this, {\n\t      bytes: arrayFill.call(new Array(byteLength), 0),\n\t      byteLength: byteLength\n\t    });\n\t    if (!descriptors) this.byteLength = byteLength;\n\t  };\n\n\t  $DataView = function DataView(buffer, byteOffset, byteLength) {\n\t    anInstance(this, $DataView, DATA_VIEW);\n\t    anInstance(buffer, $ArrayBuffer, DATA_VIEW);\n\t    var bufferLength = getInternalState(buffer).byteLength;\n\t    var offset = toInteger(byteOffset);\n\t    if (offset < 0 || offset > bufferLength) throw RangeError('Wrong offset');\n\t    byteLength = byteLength === undefined ? bufferLength - offset : toLength(byteLength);\n\t    if (offset + byteLength > bufferLength) throw RangeError(WRONG_LENGTH);\n\t    setInternalState(this, {\n\t      buffer: buffer,\n\t      byteLength: byteLength,\n\t      byteOffset: offset\n\t    });\n\t    if (!descriptors) {\n\t      this.buffer = buffer;\n\t      this.byteLength = byteLength;\n\t      this.byteOffset = offset;\n\t    }\n\t  };\n\n\t  if (descriptors) {\n\t    addGetter($ArrayBuffer, 'byteLength');\n\t    addGetter($DataView, 'buffer');\n\t    addGetter($DataView, 'byteLength');\n\t    addGetter($DataView, 'byteOffset');\n\t  }\n\n\t  redefineAll($DataView[PROTOTYPE], {\n\t    getInt8: function getInt8(byteOffset) {\n\t      return get(this, 1, byteOffset)[0] << 24 >> 24;\n\t    },\n\t    getUint8: function getUint8(byteOffset) {\n\t      return get(this, 1, byteOffset)[0];\n\t    },\n\t    getInt16: function getInt16(byteOffset /* , littleEndian */) {\n\t      var bytes = get(this, 2, byteOffset, arguments.length > 1 ? arguments[1] : undefined);\n\t      return (bytes[1] << 8 | bytes[0]) << 16 >> 16;\n\t    },\n\t    getUint16: function getUint16(byteOffset /* , littleEndian */) {\n\t      var bytes = get(this, 2, byteOffset, arguments.length > 1 ? arguments[1] : undefined);\n\t      return bytes[1] << 8 | bytes[0];\n\t    },\n\t    getInt32: function getInt32(byteOffset /* , littleEndian */) {\n\t      return unpackInt32(get(this, 4, byteOffset, arguments.length > 1 ? arguments[1] : undefined));\n\t    },\n\t    getUint32: function getUint32(byteOffset /* , littleEndian */) {\n\t      return unpackInt32(get(this, 4, byteOffset, arguments.length > 1 ? arguments[1] : undefined)) >>> 0;\n\t    },\n\t    getFloat32: function getFloat32(byteOffset /* , littleEndian */) {\n\t      return unpackIEEE754(get(this, 4, byteOffset, arguments.length > 1 ? arguments[1] : undefined), 23);\n\t    },\n\t    getFloat64: function getFloat64(byteOffset /* , littleEndian */) {\n\t      return unpackIEEE754(get(this, 8, byteOffset, arguments.length > 1 ? arguments[1] : undefined), 52);\n\t    },\n\t    setInt8: function setInt8(byteOffset, value) {\n\t      set(this, 1, byteOffset, packInt8, value);\n\t    },\n\t    setUint8: function setUint8(byteOffset, value) {\n\t      set(this, 1, byteOffset, packInt8, value);\n\t    },\n\t    setInt16: function setInt16(byteOffset, value /* , littleEndian */) {\n\t      set(this, 2, byteOffset, packInt16, value, arguments.length > 2 ? arguments[2] : undefined);\n\t    },\n\t    setUint16: function setUint16(byteOffset, value /* , littleEndian */) {\n\t      set(this, 2, byteOffset, packInt16, value, arguments.length > 2 ? arguments[2] : undefined);\n\t    },\n\t    setInt32: function setInt32(byteOffset, value /* , littleEndian */) {\n\t      set(this, 4, byteOffset, packInt32, value, arguments.length > 2 ? arguments[2] : undefined);\n\t    },\n\t    setUint32: function setUint32(byteOffset, value /* , littleEndian */) {\n\t      set(this, 4, byteOffset, packInt32, value, arguments.length > 2 ? arguments[2] : undefined);\n\t    },\n\t    setFloat32: function setFloat32(byteOffset, value /* , littleEndian */) {\n\t      set(this, 4, byteOffset, packFloat32, value, arguments.length > 2 ? arguments[2] : undefined);\n\t    },\n\t    setFloat64: function setFloat64(byteOffset, value /* , littleEndian */) {\n\t      set(this, 8, byteOffset, packFloat64, value, arguments.length > 2 ? arguments[2] : undefined);\n\t    }\n\t  });\n\t} else {\n\t  if (!fails(function () {\n\t    NativeArrayBuffer(1);\n\t  }) || !fails(function () {\n\t    new NativeArrayBuffer(-1); // eslint-disable-line no-new\n\t  }) || fails(function () {\n\t    new NativeArrayBuffer(); // eslint-disable-line no-new\n\t    new NativeArrayBuffer(1.5); // eslint-disable-line no-new\n\t    new NativeArrayBuffer(NaN); // eslint-disable-line no-new\n\t    return NativeArrayBuffer.name != ARRAY_BUFFER;\n\t  })) {\n\t    $ArrayBuffer = function ArrayBuffer(length) {\n\t      anInstance(this, $ArrayBuffer);\n\t      return new NativeArrayBuffer(toIndex(length));\n\t    };\n\t    var ArrayBufferPrototype = $ArrayBuffer[PROTOTYPE] = NativeArrayBuffer[PROTOTYPE];\n\t    for (var keys = getOwnPropertyNames(NativeArrayBuffer), j = 0, key; keys.length > j;) {\n\t      if (!((key = keys[j++]) in $ArrayBuffer)) hide($ArrayBuffer, key, NativeArrayBuffer[key]);\n\t    }\n\t    ArrayBufferPrototype.constructor = $ArrayBuffer;\n\t  }\n\t  // iOS Safari 7.x bug\n\t  var testView = new $DataView(new $ArrayBuffer(2));\n\t  var nativeSetInt8 = $DataView[PROTOTYPE].setInt8;\n\t  testView.setInt8(0, 2147483648);\n\t  testView.setInt8(1, 2147483649);\n\t  if (testView.getInt8(0) || !testView.getInt8(1)) redefineAll($DataView[PROTOTYPE], {\n\t    setInt8: function setInt8(byteOffset, value) {\n\t      nativeSetInt8.call(this, byteOffset, value << 24 >> 24);\n\t    },\n\t    setUint8: function setUint8(byteOffset, value) {\n\t      nativeSetInt8.call(this, byteOffset, value << 24 >> 24);\n\t    }\n\t  }, { unsafe: true });\n\t}\n\n\tsetToStringTag($ArrayBuffer, ARRAY_BUFFER);\n\tsetToStringTag($DataView, DATA_VIEW);\n\texports[ARRAY_BUFFER] = $ArrayBuffer;\n\texports[DATA_VIEW] = $DataView;\n\t});\n\n\tvar toOffset = function (it, BYTES) {\n\t  var offset = toInteger(it);\n\t  if (offset < 0 || offset % BYTES) throw RangeError('Wrong offset');\n\t  return offset;\n\t};\n\n\tvar typedArrayConstructor = createCommonjsModule(function (module) {\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\tvar getOwnPropertyNames = objectGetOwnPropertyNames.f;\n\n\tvar forEach = arrayIteration.forEach;\n\n\n\n\n\n\tvar getInternalState = internalState.get;\n\tvar setInternalState = internalState.set;\n\tvar nativeDefineProperty = objectDefineProperty.f;\n\tvar nativeGetOwnPropertyDescriptor = objectGetOwnPropertyDescriptor.f;\n\tvar round = Math.round;\n\tvar RangeError = global_1.RangeError;\n\tvar ArrayBuffer = arrayBuffer.ArrayBuffer;\n\tvar DataView = arrayBuffer.DataView;\n\tvar NATIVE_ARRAY_BUFFER_VIEWS = arrayBufferViewCore.NATIVE_ARRAY_BUFFER_VIEWS;\n\tvar TYPED_ARRAY_TAG = arrayBufferViewCore.TYPED_ARRAY_TAG;\n\tvar TypedArray = arrayBufferViewCore.TypedArray;\n\tvar TypedArrayPrototype = arrayBufferViewCore.TypedArrayPrototype;\n\tvar aTypedArrayConstructor = arrayBufferViewCore.aTypedArrayConstructor;\n\tvar isTypedArray = arrayBufferViewCore.isTypedArray;\n\tvar BYTES_PER_ELEMENT = 'BYTES_PER_ELEMENT';\n\tvar WRONG_LENGTH = 'Wrong length';\n\n\tvar fromList = function (C, list) {\n\t  var index = 0;\n\t  var length = list.length;\n\t  var result = new (aTypedArrayConstructor(C))(length);\n\t  while (length > index) result[index] = list[index++];\n\t  return result;\n\t};\n\n\tvar addGetter = function (it, key) {\n\t  nativeDefineProperty(it, key, { get: function () {\n\t    return getInternalState(this)[key];\n\t  } });\n\t};\n\n\tvar isArrayBuffer = function (it) {\n\t  var klass;\n\t  return it instanceof ArrayBuffer || (klass = classof(it)) == 'ArrayBuffer' || klass == 'SharedArrayBuffer';\n\t};\n\n\tvar isTypedArrayIndex = function (target, key) {\n\t  return isTypedArray(target)\n\t    && typeof key != 'symbol'\n\t    && key in target\n\t    && String(+key) == String(key);\n\t};\n\n\tvar wrappedGetOwnPropertyDescriptor = function getOwnPropertyDescriptor(target, key) {\n\t  return isTypedArrayIndex(target, key = toPrimitive(key, true))\n\t    ? createPropertyDescriptor(2, target[key])\n\t    : nativeGetOwnPropertyDescriptor(target, key);\n\t};\n\n\tvar wrappedDefineProperty = function defineProperty(target, key, descriptor) {\n\t  if (isTypedArrayIndex(target, key = toPrimitive(key, true))\n\t    && isObject(descriptor)\n\t    && has(descriptor, 'value')\n\t    && !has(descriptor, 'get')\n\t    && !has(descriptor, 'set')\n\t    // TODO: add validation descriptor w/o calling accessors\n\t    && !descriptor.configurable\n\t    && (!has(descriptor, 'writable') || descriptor.writable)\n\t    && (!has(descriptor, 'enumerable') || descriptor.enumerable)\n\t  ) {\n\t    target[key] = descriptor.value;\n\t    return target;\n\t  } return nativeDefineProperty(target, key, descriptor);\n\t};\n\n\tif (descriptors) {\n\t  if (!NATIVE_ARRAY_BUFFER_VIEWS) {\n\t    objectGetOwnPropertyDescriptor.f = wrappedGetOwnPropertyDescriptor;\n\t    objectDefineProperty.f = wrappedDefineProperty;\n\t    addGetter(TypedArrayPrototype, 'buffer');\n\t    addGetter(TypedArrayPrototype, 'byteOffset');\n\t    addGetter(TypedArrayPrototype, 'byteLength');\n\t    addGetter(TypedArrayPrototype, 'length');\n\t  }\n\n\t  _export({ target: 'Object', stat: true, forced: !NATIVE_ARRAY_BUFFER_VIEWS }, {\n\t    getOwnPropertyDescriptor: wrappedGetOwnPropertyDescriptor,\n\t    defineProperty: wrappedDefineProperty\n\t  });\n\n\t  // eslint-disable-next-line max-statements\n\t  module.exports = function (TYPE, BYTES, wrapper, CLAMPED) {\n\t    var CONSTRUCTOR_NAME = TYPE + (CLAMPED ? 'Clamped' : '') + 'Array';\n\t    var GETTER = 'get' + TYPE;\n\t    var SETTER = 'set' + TYPE;\n\t    var NativeTypedArrayConstructor = global_1[CONSTRUCTOR_NAME];\n\t    var TypedArrayConstructor = NativeTypedArrayConstructor;\n\t    var TypedArrayConstructorPrototype = TypedArrayConstructor && TypedArrayConstructor.prototype;\n\t    var exported = {};\n\n\t    var getter = function (that, index) {\n\t      var data = getInternalState(that);\n\t      return data.view[GETTER](index * BYTES + data.byteOffset, true);\n\t    };\n\n\t    var setter = function (that, index, value) {\n\t      var data = getInternalState(that);\n\t      if (CLAMPED) value = (value = round(value)) < 0 ? 0 : value > 0xFF ? 0xFF : value & 0xFF;\n\t      data.view[SETTER](index * BYTES + data.byteOffset, value, true);\n\t    };\n\n\t    var addElement = function (that, index) {\n\t      nativeDefineProperty(that, index, {\n\t        get: function () {\n\t          return getter(this, index);\n\t        },\n\t        set: function (value) {\n\t          return setter(this, index, value);\n\t        },\n\t        enumerable: true\n\t      });\n\t    };\n\n\t    if (!NATIVE_ARRAY_BUFFER_VIEWS) {\n\t      TypedArrayConstructor = wrapper(function (that, data, offset, $length) {\n\t        anInstance(that, TypedArrayConstructor, CONSTRUCTOR_NAME);\n\t        var index = 0;\n\t        var byteOffset = 0;\n\t        var buffer, byteLength, length;\n\t        if (!isObject(data)) {\n\t          length = toIndex(data);\n\t          byteLength = length * BYTES;\n\t          buffer = new ArrayBuffer(byteLength);\n\t        } else if (isArrayBuffer(data)) {\n\t          buffer = data;\n\t          byteOffset = toOffset(offset, BYTES);\n\t          var $len = data.byteLength;\n\t          if ($length === undefined) {\n\t            if ($len % BYTES) throw RangeError(WRONG_LENGTH);\n\t            byteLength = $len - byteOffset;\n\t            if (byteLength < 0) throw RangeError(WRONG_LENGTH);\n\t          } else {\n\t            byteLength = toLength($length) * BYTES;\n\t            if (byteLength + byteOffset > $len) throw RangeError(WRONG_LENGTH);\n\t          }\n\t          length = byteLength / BYTES;\n\t        } else if (isTypedArray(data)) {\n\t          return fromList(TypedArrayConstructor, data);\n\t        } else {\n\t          return typedArrayFrom.call(TypedArrayConstructor, data);\n\t        }\n\t        setInternalState(that, {\n\t          buffer: buffer,\n\t          byteOffset: byteOffset,\n\t          byteLength: byteLength,\n\t          length: length,\n\t          view: new DataView(buffer)\n\t        });\n\t        while (index < length) addElement(that, index++);\n\t      });\n\n\t      if (objectSetPrototypeOf) objectSetPrototypeOf(TypedArrayConstructor, TypedArray);\n\t      TypedArrayConstructorPrototype = TypedArrayConstructor.prototype = objectCreate(TypedArrayPrototype);\n\t    } else if (typedArraysConstructorsRequiresWrappers) {\n\t      TypedArrayConstructor = wrapper(function (dummy, data, typedArrayOffset, $length) {\n\t        anInstance(dummy, TypedArrayConstructor, CONSTRUCTOR_NAME);\n\t        if (!isObject(data)) return new NativeTypedArrayConstructor(toIndex(data));\n\t        if (isArrayBuffer(data)) return $length !== undefined\n\t          ? new NativeTypedArrayConstructor(data, toOffset(typedArrayOffset, BYTES), $length)\n\t          : typedArrayOffset !== undefined\n\t            ? new NativeTypedArrayConstructor(data, toOffset(typedArrayOffset, BYTES))\n\t            : new NativeTypedArrayConstructor(data);\n\t        if (isTypedArray(data)) return fromList(TypedArrayConstructor, data);\n\t        return typedArrayFrom.call(TypedArrayConstructor, data);\n\t      });\n\n\t      if (objectSetPrototypeOf) objectSetPrototypeOf(TypedArrayConstructor, TypedArray);\n\t      forEach(getOwnPropertyNames(NativeTypedArrayConstructor), function (key) {\n\t        if (!(key in TypedArrayConstructor)) hide(TypedArrayConstructor, key, NativeTypedArrayConstructor[key]);\n\t      });\n\t      TypedArrayConstructor.prototype = TypedArrayConstructorPrototype;\n\t    }\n\n\t    if (TypedArrayConstructorPrototype.constructor !== TypedArrayConstructor) {\n\t      hide(TypedArrayConstructorPrototype, 'constructor', TypedArrayConstructor);\n\t    }\n\n\t    if (TYPED_ARRAY_TAG) hide(TypedArrayConstructorPrototype, TYPED_ARRAY_TAG, CONSTRUCTOR_NAME);\n\n\t    exported[CONSTRUCTOR_NAME] = TypedArrayConstructor;\n\n\t    _export({\n\t      global: true, forced: TypedArrayConstructor != NativeTypedArrayConstructor, sham: !NATIVE_ARRAY_BUFFER_VIEWS\n\t    }, exported);\n\n\t    if (!(BYTES_PER_ELEMENT in TypedArrayConstructor)) {\n\t      hide(TypedArrayConstructor, BYTES_PER_ELEMENT, BYTES);\n\t    }\n\n\t    if (!(BYTES_PER_ELEMENT in TypedArrayConstructorPrototype)) {\n\t      hide(TypedArrayConstructorPrototype, BYTES_PER_ELEMENT, BYTES);\n\t    }\n\n\t    setSpecies(CONSTRUCTOR_NAME);\n\t  };\n\t} else module.exports = function () { /* empty */ };\n\t});\n\n\t// `Int8Array` constructor\n\t// https://tc39.github.io/ecma262/#sec-typedarray-objects\n\ttypedArrayConstructor('Int8', 1, function (init) {\n\t  return function Int8Array(data, byteOffset, length) {\n\t    return init(this, data, byteOffset, length);\n\t  };\n\t});\n\n\tvar $every = arrayIteration.every;\n\n\tvar aTypedArray$7 = arrayBufferViewCore.aTypedArray;\n\n\t// `%TypedArray%.prototype.every` method\n\t// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.every\n\tarrayBufferViewCore.exportProto('every', function every(callbackfn /* , thisArg */) {\n\t  return $every(aTypedArray$7(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);\n\t});\n\n\tvar $filter = arrayIteration.filter;\n\n\n\tvar aTypedArray$8 = arrayBufferViewCore.aTypedArray;\n\tvar aTypedArrayConstructor$3 = arrayBufferViewCore.aTypedArrayConstructor;\n\n\t// `%TypedArray%.prototype.filter` method\n\t// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.filter\n\tarrayBufferViewCore.exportProto('filter', function filter(callbackfn /* , thisArg */) {\n\t  var list = $filter(aTypedArray$8(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);\n\t  var C = speciesConstructor(this, this.constructor);\n\t  var index = 0;\n\t  var length = list.length;\n\t  var result = new (aTypedArrayConstructor$3(C))(length);\n\t  while (length > index) result[index] = list[index++];\n\t  return result;\n\t});\n\n\tvar $forEach$1 = arrayIteration.forEach;\n\n\tvar aTypedArray$9 = arrayBufferViewCore.aTypedArray;\n\n\t// `%TypedArray%.prototype.forEach` method\n\t// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.foreach\n\tarrayBufferViewCore.exportProto('forEach', function forEach(callbackfn /* , thisArg */) {\n\t  $forEach$1(aTypedArray$9(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);\n\t});\n\n\tvar $indexOf = arrayIncludes.indexOf;\n\n\tvar aTypedArray$a = arrayBufferViewCore.aTypedArray;\n\n\t// `%TypedArray%.prototype.indexOf` method\n\t// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.indexof\n\tarrayBufferViewCore.exportProto('indexOf', function indexOf(searchElement /* , fromIndex */) {\n\t  return $indexOf(aTypedArray$a(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);\n\t});\n\n\tvar aTypedArray$b = arrayBufferViewCore.aTypedArray;\n\tvar $join = [].join;\n\n\t// `%TypedArray%.prototype.join` method\n\t// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.join\n\t// eslint-disable-next-line no-unused-vars\n\tarrayBufferViewCore.exportProto('join', function join(separator) {\n\t  return $join.apply(aTypedArray$b(this), arguments);\n\t});\n\n\tvar sloppyArrayMethod = function (METHOD_NAME, argument) {\n\t  var method = [][METHOD_NAME];\n\t  return !method || !fails(function () {\n\t    // eslint-disable-next-line no-useless-call,no-throw-literal\n\t    method.call(null, argument || function () { throw 1; }, 1);\n\t  });\n\t};\n\n\tvar min$5 = Math.min;\n\tvar nativeLastIndexOf = [].lastIndexOf;\n\tvar NEGATIVE_ZERO = !!nativeLastIndexOf && 1 / [1].lastIndexOf(1, -0) < 0;\n\tvar SLOPPY_METHOD = sloppyArrayMethod('lastIndexOf');\n\n\t// `Array.prototype.lastIndexOf` method implementation\n\t// https://tc39.github.io/ecma262/#sec-array.prototype.lastindexof\n\tvar arrayLastIndexOf = (NEGATIVE_ZERO || SLOPPY_METHOD) ? function lastIndexOf(searchElement /* , fromIndex = @[*-1] */) {\n\t  // convert -0 to +0\n\t  if (NEGATIVE_ZERO) return nativeLastIndexOf.apply(this, arguments) || 0;\n\t  var O = toIndexedObject(this);\n\t  var length = toLength(O.length);\n\t  var index = length - 1;\n\t  if (arguments.length > 1) index = min$5(index, toInteger(arguments[1]));\n\t  if (index < 0) index = length + index;\n\t  for (;index >= 0; index--) if (index in O && O[index] === searchElement) return index || 0;\n\t  return -1;\n\t} : nativeLastIndexOf;\n\n\tvar aTypedArray$c = arrayBufferViewCore.aTypedArray;\n\n\t// `%TypedArray%.prototype.lastIndexOf` method\n\t// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.lastindexof\n\t// eslint-disable-next-line no-unused-vars\n\tarrayBufferViewCore.exportProto('lastIndexOf', function lastIndexOf(searchElement /* , fromIndex */) {\n\t  return arrayLastIndexOf.apply(aTypedArray$c(this), arguments);\n\t});\n\n\tvar $map = arrayIteration.map;\n\n\n\tvar aTypedArray$d = arrayBufferViewCore.aTypedArray;\n\tvar aTypedArrayConstructor$4 = arrayBufferViewCore.aTypedArrayConstructor;\n\n\t// `%TypedArray%.prototype.map` method\n\t// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.map\n\tarrayBufferViewCore.exportProto('map', function map(mapfn /* , thisArg */) {\n\t  return $map(aTypedArray$d(this), mapfn, arguments.length > 1 ? arguments[1] : undefined, function (O, length) {\n\t    return new (aTypedArrayConstructor$4(speciesConstructor(O, O.constructor)))(length);\n\t  });\n\t});\n\n\t// `Array.prototype.{ reduce, reduceRight }` methods implementation\n\tvar createMethod$6 = function (IS_RIGHT) {\n\t  return function (that, callbackfn, argumentsLength, memo) {\n\t    aFunction$1(callbackfn);\n\t    var O = toObject(that);\n\t    var self = indexedObject(O);\n\t    var length = toLength(O.length);\n\t    var index = IS_RIGHT ? length - 1 : 0;\n\t    var i = IS_RIGHT ? -1 : 1;\n\t    if (argumentsLength < 2) while (true) {\n\t      if (index in self) {\n\t        memo = self[index];\n\t        index += i;\n\t        break;\n\t      }\n\t      index += i;\n\t      if (IS_RIGHT ? index < 0 : length <= index) {\n\t        throw TypeError('Reduce of empty array with no initial value');\n\t      }\n\t    }\n\t    for (;IS_RIGHT ? index >= 0 : length > index; index += i) if (index in self) {\n\t      memo = callbackfn(memo, self[index], index, O);\n\t    }\n\t    return memo;\n\t  };\n\t};\n\n\tvar arrayReduce = {\n\t  // `Array.prototype.reduce` method\n\t  // https://tc39.github.io/ecma262/#sec-array.prototype.reduce\n\t  left: createMethod$6(false),\n\t  // `Array.prototype.reduceRight` method\n\t  // https://tc39.github.io/ecma262/#sec-array.prototype.reduceright\n\t  right: createMethod$6(true)\n\t};\n\n\tvar $reduce = arrayReduce.left;\n\n\tvar aTypedArray$e = arrayBufferViewCore.aTypedArray;\n\n\t// `%TypedArray%.prototype.reduce` method\n\t// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.reduce\n\tarrayBufferViewCore.exportProto('reduce', function reduce(callbackfn /* , initialValue */) {\n\t  return $reduce(aTypedArray$e(this), callbackfn, arguments.length, arguments.length > 1 ? arguments[1] : undefined);\n\t});\n\n\tvar $reduceRight = arrayReduce.right;\n\n\tvar aTypedArray$f = arrayBufferViewCore.aTypedArray;\n\n\t// `%TypedArray%.prototype.reduceRicht` method\n\t// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.reduceright\n\tarrayBufferViewCore.exportProto('reduceRight', function reduceRight(callbackfn /* , initialValue */) {\n\t  return $reduceRight(aTypedArray$f(this), callbackfn, arguments.length, arguments.length > 1 ? arguments[1] : undefined);\n\t});\n\n\tvar aTypedArray$g = arrayBufferViewCore.aTypedArray;\n\tvar floor$4 = Math.floor;\n\n\t// `%TypedArray%.prototype.reverse` method\n\t// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.reverse\n\tarrayBufferViewCore.exportProto('reverse', function reverse() {\n\t  var that = this;\n\t  var length = aTypedArray$g(that).length;\n\t  var middle = floor$4(length / 2);\n\t  var index = 0;\n\t  var value;\n\t  while (index < middle) {\n\t    value = that[index];\n\t    that[index++] = that[--length];\n\t    that[length] = value;\n\t  } return that;\n\t});\n\n\tvar aTypedArray$h = arrayBufferViewCore.aTypedArray;\n\n\tvar FORCED$8 = fails(function () {\n\t  // eslint-disable-next-line no-undef\n\t  new Int8Array(1).set({});\n\t});\n\n\t// `%TypedArray%.prototype.set` method\n\t// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.set\n\tarrayBufferViewCore.exportProto('set', function set(arrayLike /* , offset */) {\n\t  aTypedArray$h(this);\n\t  var offset = toOffset(arguments.length > 1 ? arguments[1] : undefined, 1);\n\t  var length = this.length;\n\t  var src = toObject(arrayLike);\n\t  var len = toLength(src.length);\n\t  var index = 0;\n\t  if (len + offset > length) throw RangeError('Wrong length');\n\t  while (index < len) this[offset + index] = src[index++];\n\t}, FORCED$8);\n\n\tvar aTypedArray$i = arrayBufferViewCore.aTypedArray;\n\tvar aTypedArrayConstructor$5 = arrayBufferViewCore.aTypedArrayConstructor;\n\tvar $slice = [].slice;\n\n\tvar FORCED$9 = fails(function () {\n\t  // eslint-disable-next-line no-undef\n\t  new Int8Array(1).slice();\n\t});\n\n\t// `%TypedArray%.prototype.slice` method\n\t// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.slice\n\tarrayBufferViewCore.exportProto('slice', function slice(start, end) {\n\t  var list = $slice.call(aTypedArray$i(this), start, end);\n\t  var C = speciesConstructor(this, this.constructor);\n\t  var index = 0;\n\t  var length = list.length;\n\t  var result = new (aTypedArrayConstructor$5(C))(length);\n\t  while (length > index) result[index] = list[index++];\n\t  return result;\n\t}, FORCED$9);\n\n\tvar $some = arrayIteration.some;\n\n\tvar aTypedArray$j = arrayBufferViewCore.aTypedArray;\n\n\t// `%TypedArray%.prototype.some` method\n\t// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.some\n\tarrayBufferViewCore.exportProto('some', function some(callbackfn /* , thisArg */) {\n\t  return $some(aTypedArray$j(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);\n\t});\n\n\tvar aTypedArray$k = arrayBufferViewCore.aTypedArray;\n\tvar $sort = [].sort;\n\n\t// `%TypedArray%.prototype.sort` method\n\t// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.sort\n\tarrayBufferViewCore.exportProto('sort', function sort(comparefn) {\n\t  return $sort.call(aTypedArray$k(this), comparefn);\n\t});\n\n\tvar aTypedArray$l = arrayBufferViewCore.aTypedArray;\n\n\t// `%TypedArray%.prototype.subarray` method\n\t// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.subarray\n\tarrayBufferViewCore.exportProto('subarray', function subarray(begin, end) {\n\t  var O = aTypedArray$l(this);\n\t  var length = O.length;\n\t  var beginIndex = toAbsoluteIndex(begin, length);\n\t  return new (speciesConstructor(O, O.constructor))(\n\t    O.buffer,\n\t    O.byteOffset + beginIndex * O.BYTES_PER_ELEMENT,\n\t    toLength((end === undefined ? length : toAbsoluteIndex(end, length)) - beginIndex)\n\t  );\n\t});\n\n\tvar Int8Array$3 = global_1.Int8Array;\n\tvar aTypedArray$m = arrayBufferViewCore.aTypedArray;\n\tvar $toLocaleString = [].toLocaleString;\n\tvar $slice$1 = [].slice;\n\n\t// iOS Safari 6.x fails here\n\tvar TO_LOCALE_STRING_BUG = !!Int8Array$3 && fails(function () {\n\t  $toLocaleString.call(new Int8Array$3(1));\n\t});\n\n\tvar FORCED$a = fails(function () {\n\t  return [1, 2].toLocaleString() != new Int8Array$3([1, 2]).toLocaleString();\n\t}) || !fails(function () {\n\t  Int8Array$3.prototype.toLocaleString.call([1, 2]);\n\t});\n\n\t// `%TypedArray%.prototype.toLocaleString` method\n\t// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.tolocalestring\n\tarrayBufferViewCore.exportProto('toLocaleString', function toLocaleString() {\n\t  return $toLocaleString.apply(TO_LOCALE_STRING_BUG ? $slice$1.call(aTypedArray$m(this)) : aTypedArray$m(this), arguments);\n\t}, FORCED$a);\n\n\tvar Uint8Array$1 = global_1.Uint8Array;\n\tvar Uint8ArrayPrototype = Uint8Array$1 && Uint8Array$1.prototype;\n\tvar arrayToString = [].toString;\n\tvar arrayJoin = [].join;\n\n\tif (fails(function () { arrayToString.call({}); })) {\n\t  arrayToString = function toString() {\n\t    return arrayJoin.call(this);\n\t  };\n\t}\n\n\t// `%TypedArray%.prototype.toString` method\n\t// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.tostring\n\tarrayBufferViewCore.exportProto('toString', arrayToString, (Uint8ArrayPrototype || {}).toString != arrayToString);\n\n\tvar int8Array = global_1.Int8Array;\n\n\t// `Uint8Array` constructor\n\t// https://tc39.github.io/ecma262/#sec-typedarray-objects\n\ttypedArrayConstructor('Uint8', 1, function (init) {\n\t  return function Uint8Array(data, byteOffset, length) {\n\t    return init(this, data, byteOffset, length);\n\t  };\n\t});\n\n\tvar uint8Array = global_1.Uint8Array;\n\n\t// `Uint8ClampedArray` constructor\n\t// https://tc39.github.io/ecma262/#sec-typedarray-objects\n\ttypedArrayConstructor('Uint8', 1, function (init) {\n\t  return function Uint8ClampedArray(data, byteOffset, length) {\n\t    return init(this, data, byteOffset, length);\n\t  };\n\t}, true);\n\n\tvar uint8ClampedArray = global_1.Uint8ClampedArray;\n\n\t// `Int16Array` constructor\n\t// https://tc39.github.io/ecma262/#sec-typedarray-objects\n\ttypedArrayConstructor('Int16', 2, function (init) {\n\t  return function Int16Array(data, byteOffset, length) {\n\t    return init(this, data, byteOffset, length);\n\t  };\n\t});\n\n\tvar int16Array = global_1.Int16Array;\n\n\t// `Uint16Array` constructor\n\t// https://tc39.github.io/ecma262/#sec-typedarray-objects\n\ttypedArrayConstructor('Uint16', 2, function (init) {\n\t  return function Uint16Array(data, byteOffset, length) {\n\t    return init(this, data, byteOffset, length);\n\t  };\n\t});\n\n\tvar uint16Array = global_1.Uint16Array;\n\n\t// `Int32Array` constructor\n\t// https://tc39.github.io/ecma262/#sec-typedarray-objects\n\ttypedArrayConstructor('Int32', 4, function (init) {\n\t  return function Int32Array(data, byteOffset, length) {\n\t    return init(this, data, byteOffset, length);\n\t  };\n\t});\n\n\tvar int32Array = global_1.Int32Array;\n\n\t// `Uint32Array` constructor\n\t// https://tc39.github.io/ecma262/#sec-typedarray-objects\n\ttypedArrayConstructor('Uint32', 4, function (init) {\n\t  return function Uint32Array(data, byteOffset, length) {\n\t    return init(this, data, byteOffset, length);\n\t  };\n\t});\n\n\tvar uint32Array = global_1.Uint32Array;\n\n\t// `Float32Array` constructor\n\t// https://tc39.github.io/ecma262/#sec-typedarray-objects\n\ttypedArrayConstructor('Float32', 4, function (init) {\n\t  return function Float32Array(data, byteOffset, length) {\n\t    return init(this, data, byteOffset, length);\n\t  };\n\t});\n\n\tvar float32Array = global_1.Float32Array;\n\n\t// `Float64Array` constructor\n\t// https://tc39.github.io/ecma262/#sec-typedarray-objects\n\ttypedArrayConstructor('Float64', 8, function (init) {\n\t  return function Float64Array(data, byteOffset, length) {\n\t    return init(this, data, byteOffset, length);\n\t  };\n\t});\n\n\tvar float64Array = global_1.Float64Array;\n\n\tvar es2017TypedArrays = createCommonjsModule(function (module, exports) {\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\t});\n\n\tunwrapExports(es2017TypedArrays);\n\n\tvar _finally = entryUnbind('Promise', 'finally');\n\n\tvar es2018Promise = createCommonjsModule(function (module, exports) {\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\t});\n\n\tunwrapExports(es2018Promise);\n\n\t// `FlattenIntoArray` abstract operation\n\t// https://tc39.github.io/proposal-flatMap/#sec-FlattenIntoArray\n\tvar flattenIntoArray = function (target, original, source, sourceLen, start, depth, mapper, thisArg) {\n\t  var targetIndex = start;\n\t  var sourceIndex = 0;\n\t  var mapFn = mapper ? bindContext(mapper, thisArg, 3) : false;\n\t  var element;\n\n\t  while (sourceIndex < sourceLen) {\n\t    if (sourceIndex in source) {\n\t      element = mapFn ? mapFn(source[sourceIndex], sourceIndex, original) : source[sourceIndex];\n\n\t      if (depth > 0 && isArray(element)) {\n\t        targetIndex = flattenIntoArray(target, original, element, toLength(element.length), targetIndex, depth - 1) - 1;\n\t      } else {\n\t        if (targetIndex >= 0x1FFFFFFFFFFFFF) throw TypeError('Exceed the acceptable array length');\n\t        target[targetIndex] = element;\n\t      }\n\n\t      targetIndex++;\n\t    }\n\t    sourceIndex++;\n\t  }\n\t  return targetIndex;\n\t};\n\n\tvar flattenIntoArray_1 = flattenIntoArray;\n\n\t// `Array.prototype.flatMap` method\n\t// https://github.com/tc39/proposal-flatMap\n\t_export({ target: 'Array', proto: true }, {\n\t  flatMap: function flatMap(callbackfn /* , thisArg */) {\n\t    var O = toObject(this);\n\t    var sourceLen = toLength(O.length);\n\t    var A;\n\t    aFunction$1(callbackfn);\n\t    A = arraySpeciesCreate(O, 0);\n\t    A.length = flattenIntoArray_1(A, O, O, sourceLen, 0, 1, callbackfn, arguments.length > 1 ? arguments[1] : undefined);\n\t    return A;\n\t  }\n\t});\n\n\t// this method was added to unscopables after implementation\n\t// in popular engines, so it's moved to a separate module\n\n\n\taddToUnscopables('flatMap');\n\n\tvar flatMap = entryUnbind('Array', 'flatMap');\n\n\t// `Array.prototype.flat` method\n\t// https://github.com/tc39/proposal-flatMap\n\t_export({ target: 'Array', proto: true }, {\n\t  flat: function flat(/* depthArg = 1 */) {\n\t    var depthArg = arguments.length ? arguments[0] : undefined;\n\t    var O = toObject(this);\n\t    var sourceLen = toLength(O.length);\n\t    var A = arraySpeciesCreate(O, 0);\n\t    A.length = flattenIntoArray_1(A, O, O, sourceLen, 0, depthArg === undefined ? 1 : toInteger(depthArg));\n\t    return A;\n\t  }\n\t});\n\n\t// this method was added to unscopables after implementation\n\t// in popular engines, so it's moved to a separate module\n\n\n\taddToUnscopables('flat');\n\n\tvar flat = entryUnbind('Array', 'flat');\n\n\tvar es2019Array = createCommonjsModule(function (module, exports) {\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\t});\n\n\tunwrapExports(es2019Array);\n\n\tvar non = '\\u200B\\u0085\\u180E';\n\n\t// check that a method works with the correct list\n\t// of whitespaces and has a correct name\n\tvar forcedStringTrimMethod = function (METHOD_NAME) {\n\t  return fails(function () {\n\t    return !!whitespaces[METHOD_NAME]() || non[METHOD_NAME]() != non || whitespaces[METHOD_NAME].name !== METHOD_NAME;\n\t  });\n\t};\n\n\tvar $trimEnd = stringTrim.end;\n\n\n\tvar FORCED$b = forcedStringTrimMethod('trimEnd');\n\n\tvar trimEnd = FORCED$b ? function trimEnd() {\n\t  return $trimEnd(this);\n\t} : ''.trimEnd;\n\n\t// `String.prototype.{ trimEnd, trimRight }` methods\n\t// https://github.com/tc39/ecmascript-string-left-right-trim\n\t_export({ target: 'String', proto: true, forced: FORCED$b }, {\n\t  trimEnd: trimEnd,\n\t  trimRight: trimEnd\n\t});\n\n\tvar trimEnd$1 = entryUnbind('String', 'trimRight');\n\n\tvar $trimStart = stringTrim.start;\n\n\n\tvar FORCED$c = forcedStringTrimMethod('trimStart');\n\n\tvar trimStart = FORCED$c ? function trimStart() {\n\t  return $trimStart(this);\n\t} : ''.trimStart;\n\n\t// `String.prototype.{ trimStart, trimLeft }` methods\n\t// https://github.com/tc39/ecmascript-string-left-right-trim\n\t_export({ target: 'String', proto: true, forced: FORCED$c }, {\n\t  trimStart: trimStart,\n\t  trimLeft: trimStart\n\t});\n\n\tvar trimStart$1 = entryUnbind('String', 'trimLeft');\n\n\tvar trimLeft = entryUnbind('String', 'trimLeft');\n\n\tvar trimRight = entryUnbind('String', 'trimRight');\n\n\tvar es2019String = createCommonjsModule(function (module, exports) {\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\t});\n\n\tunwrapExports(es2019String);\n\n\t// `Object.fromEntries` method\n\t// https://github.com/tc39/proposal-object-from-entries\n\t_export({ target: 'Object', stat: true }, {\n\t  fromEntries: function fromEntries(iterable) {\n\t    var obj = {};\n\t    iterate_1(iterable, function (k, v) {\n\t      createProperty(obj, k, v);\n\t    }, undefined, true);\n\t    return obj;\n\t  }\n\t});\n\n\tvar fromEntries = path.Object.fromEntries;\n\n\tvar es2019Object = createCommonjsModule(function (module, exports) {\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\t});\n\n\tunwrapExports(es2019Object);\n\n\tvar charAt$1 = stringMultibyte.charAt;\n\n\t// `AdvanceStringIndex` abstract operation\n\t// https://tc39.github.io/ecma262/#sec-advancestringindex\n\tvar advanceStringIndex = function (S, index, unicode) {\n\t  return index + (unicode ? charAt$1(S, index).length : 1);\n\t};\n\n\tvar MATCH_ALL = wellKnownSymbol('matchAll');\n\tvar REGEXP_STRING = 'RegExp String';\n\tvar REGEXP_STRING_ITERATOR = REGEXP_STRING + ' Iterator';\n\tvar setInternalState$6 = internalState.set;\n\tvar getInternalState$4 = internalState.getterFor(REGEXP_STRING_ITERATOR);\n\tvar RegExpPrototype$1 = RegExp.prototype;\n\tvar regExpBuiltinExec = RegExpPrototype$1.exec;\n\n\tvar regExpExec = function (R, S) {\n\t  var exec = R.exec;\n\t  var result;\n\t  if (typeof exec == 'function') {\n\t    result = exec.call(R, S);\n\t    if (typeof result != 'object') throw TypeError('Incorrect exec result');\n\t    return result;\n\t  } return regExpBuiltinExec.call(R, S);\n\t};\n\n\t// eslint-disable-next-line max-len\n\tvar $RegExpStringIterator = createIteratorConstructor(function RegExpStringIterator(regexp, string, global, fullUnicode) {\n\t  setInternalState$6(this, {\n\t    type: REGEXP_STRING_ITERATOR,\n\t    regexp: regexp,\n\t    string: string,\n\t    global: global,\n\t    unicode: fullUnicode,\n\t    done: false\n\t  });\n\t}, REGEXP_STRING, function next() {\n\t  var state = getInternalState$4(this);\n\t  if (state.done) return { value: undefined, done: true };\n\t  var R = state.regexp;\n\t  var S = state.string;\n\t  var match = regExpExec(R, S);\n\t  if (match === null) return { value: undefined, done: state.done = true };\n\t  if (state.global) {\n\t    if (String(match[0]) == '') R.lastIndex = advanceStringIndex(S, toLength(R.lastIndex), state.unicode);\n\t    return { value: match, done: false };\n\t  }\n\t  state.done = true;\n\t  return { value: match, done: false };\n\t});\n\n\tvar $matchAll = function (string) {\n\t  var R = anObject(this);\n\t  var S = String(string);\n\t  var C, flagsValue, flags, matcher, global, fullUnicode;\n\t  C = speciesConstructor(R, RegExp);\n\t  flagsValue = R.flags;\n\t  if (flagsValue === undefined && R instanceof RegExp && !('flags' in RegExpPrototype$1)) {\n\t    flagsValue = regexpFlags.call(R);\n\t  }\n\t  flags = flagsValue === undefined ? '' : String(flagsValue);\n\t  matcher = new C(C === RegExp ? R.source : R, flags);\n\t  global = !!~flags.indexOf('g');\n\t  fullUnicode = !!~flags.indexOf('u');\n\t  matcher.lastIndex = toLength(R.lastIndex);\n\t  return new $RegExpStringIterator(matcher, S, global, fullUnicode);\n\t};\n\n\t// `String.prototype.matchAll` method\n\t// https://github.com/tc39/proposal-string-matchall\n\t_export({ target: 'String', proto: true }, {\n\t  matchAll: function matchAll(regexp) {\n\t    var O = requireObjectCoercible(this);\n\t    var S, matcher, rx;\n\t    if (regexp != null) {\n\t      matcher = regexp[MATCH_ALL];\n\t      if (matcher === undefined && isPure && classof(regexp) == 'RegExp') matcher = $matchAll;\n\t      if (matcher != null) return aFunction$1(matcher).call(regexp, O);\n\t    }\n\t    S = String(O);\n\t    rx = new RegExp(regexp, 'g');\n\t    return  rx[MATCH_ALL](S);\n\t  }\n\t});\n\n\t MATCH_ALL in RegExpPrototype$1 || hide(RegExpPrototype$1, MATCH_ALL, $matchAll);\n\n\tvar matchAll = entryUnbind('String', 'matchAll');\n\n\tvar es2020String = createCommonjsModule(function (module, exports) {\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\t});\n\n\tunwrapExports(es2020String);\n\n\tvar lib = createCommonjsModule(function (module, exports) {\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\t});\n\n\tvar index$1 = unwrapExports(lib);\n\n\treturn index$1;\n\n}());\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdHMtcG9seWZpbGwvZGlzdC90cy1wb2x5ZmlsbC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90cy1wb2x5ZmlsbC9kaXN0L3RzLXBvbHlmaWxsLmpzP2Y1YTAiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIHRzUG9seWZpbGwgPSAoZnVuY3Rpb24gKCkge1xuXHQndXNlIHN0cmljdCc7XG5cblx0dmFyIGNvbW1vbmpzR2xvYmFsID0gdHlwZW9mIGdsb2JhbFRoaXMgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsVGhpcyA6IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93IDogdHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcgPyBzZWxmIDoge307XG5cblx0ZnVuY3Rpb24gdW53cmFwRXhwb3J0cyAoeCkge1xuXHRcdHJldHVybiB4ICYmIHguX19lc01vZHVsZSAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoeCwgJ2RlZmF1bHQnKSA/IHhbJ2RlZmF1bHQnXSA6IHg7XG5cdH1cblxuXHRmdW5jdGlvbiBjcmVhdGVDb21tb25qc01vZHVsZShmbiwgbW9kdWxlKSB7XG5cdFx0cmV0dXJuIG1vZHVsZSA9IHsgZXhwb3J0czoge30gfSwgZm4obW9kdWxlLCBtb2R1bGUuZXhwb3J0cyksIG1vZHVsZS5leHBvcnRzO1xuXHR9XG5cblx0dmFyIE8gPSAnb2JqZWN0Jztcblx0dmFyIGNoZWNrID0gZnVuY3Rpb24gKGl0KSB7XG5cdCAgcmV0dXJuIGl0ICYmIGl0Lk1hdGggPT0gTWF0aCAmJiBpdDtcblx0fTtcblxuXHQvLyBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9pc3N1ZXMvODYjaXNzdWVjb21tZW50LTExNTc1OTAyOFxuXHR2YXIgZ2xvYmFsXzEgPVxuXHQgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlZlxuXHQgIGNoZWNrKHR5cGVvZiBnbG9iYWxUaGlzID09IE8gJiYgZ2xvYmFsVGhpcykgfHxcblx0ICBjaGVjayh0eXBlb2Ygd2luZG93ID09IE8gJiYgd2luZG93KSB8fFxuXHQgIGNoZWNrKHR5cGVvZiBzZWxmID09IE8gJiYgc2VsZikgfHxcblx0ICBjaGVjayh0eXBlb2YgY29tbW9uanNHbG9iYWwgPT0gTyAmJiBjb21tb25qc0dsb2JhbCkgfHxcblx0ICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbmV3LWZ1bmNcblx0ICBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuXG5cdHZhciBmYWlscyA9IGZ1bmN0aW9uIChleGVjKSB7XG5cdCAgdHJ5IHtcblx0ICAgIHJldHVybiAhIWV4ZWMoKTtcblx0ICB9IGNhdGNoIChlcnJvcikge1xuXHQgICAgcmV0dXJuIHRydWU7XG5cdCAgfVxuXHR9O1xuXG5cdC8vIFRoYW5rJ3MgSUU4IGZvciBoaXMgZnVubnkgZGVmaW5lUHJvcGVydHlcblx0dmFyIGRlc2NyaXB0b3JzID0gIWZhaWxzKGZ1bmN0aW9uICgpIHtcblx0ICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LCAnYScsIHsgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiA3OyB9IH0pLmEgIT0gNztcblx0fSk7XG5cblx0dmFyIG5hdGl2ZVByb3BlcnR5SXNFbnVtZXJhYmxlID0ge30ucHJvcGVydHlJc0VudW1lcmFibGU7XG5cdHZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xuXG5cdC8vIE5hc2hvcm4gfiBKREs4IGJ1Z1xuXHR2YXIgTkFTSE9STl9CVUcgPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgJiYgIW5hdGl2ZVByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwoeyAxOiAyIH0sIDEpO1xuXG5cdC8vIGBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlYCBtZXRob2QgaW1wbGVtZW50YXRpb25cblx0Ly8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtb2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eWlzZW51bWVyYWJsZVxuXHR2YXIgZiA9IE5BU0hPUk5fQlVHID8gZnVuY3Rpb24gcHJvcGVydHlJc0VudW1lcmFibGUoVikge1xuXHQgIHZhciBkZXNjcmlwdG9yID0gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRoaXMsIFYpO1xuXHQgIHJldHVybiAhIWRlc2NyaXB0b3IgJiYgZGVzY3JpcHRvci5lbnVtZXJhYmxlO1xuXHR9IDogbmF0aXZlUHJvcGVydHlJc0VudW1lcmFibGU7XG5cblx0dmFyIG9iamVjdFByb3BlcnR5SXNFbnVtZXJhYmxlID0ge1xuXHRcdGY6IGZcblx0fTtcblxuXHR2YXIgY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yID0gZnVuY3Rpb24gKGJpdG1hcCwgdmFsdWUpIHtcblx0ICByZXR1cm4ge1xuXHQgICAgZW51bWVyYWJsZTogIShiaXRtYXAgJiAxKSxcblx0ICAgIGNvbmZpZ3VyYWJsZTogIShiaXRtYXAgJiAyKSxcblx0ICAgIHdyaXRhYmxlOiAhKGJpdG1hcCAmIDQpLFxuXHQgICAgdmFsdWU6IHZhbHVlXG5cdCAgfTtcblx0fTtcblxuXHR2YXIgdG9TdHJpbmcgPSB7fS50b1N0cmluZztcblxuXHR2YXIgY2xhc3NvZlJhdyA9IGZ1bmN0aW9uIChpdCkge1xuXHQgIHJldHVybiB0b1N0cmluZy5jYWxsKGl0KS5zbGljZSg4LCAtMSk7XG5cdH07XG5cblx0dmFyIHNwbGl0ID0gJycuc3BsaXQ7XG5cblx0Ly8gZmFsbGJhY2sgZm9yIG5vbi1hcnJheS1saWtlIEVTMyBhbmQgbm9uLWVudW1lcmFibGUgb2xkIFY4IHN0cmluZ3Ncblx0dmFyIGluZGV4ZWRPYmplY3QgPSBmYWlscyhmdW5jdGlvbiAoKSB7XG5cdCAgLy8gdGhyb3dzIGFuIGVycm9yIGluIHJoaW5vLCBzZWUgaHR0cHM6Ly9naXRodWIuY29tL21vemlsbGEvcmhpbm8vaXNzdWVzLzM0NlxuXHQgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wcm90b3R5cGUtYnVpbHRpbnNcblx0ICByZXR1cm4gIU9iamVjdCgneicpLnByb3BlcnR5SXNFbnVtZXJhYmxlKDApO1xuXHR9KSA/IGZ1bmN0aW9uIChpdCkge1xuXHQgIHJldHVybiBjbGFzc29mUmF3KGl0KSA9PSAnU3RyaW5nJyA/IHNwbGl0LmNhbGwoaXQsICcnKSA6IE9iamVjdChpdCk7XG5cdH0gOiBPYmplY3Q7XG5cblx0Ly8gYFJlcXVpcmVPYmplY3RDb2VyY2libGVgIGFic3RyYWN0IG9wZXJhdGlvblxuXHQvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1yZXF1aXJlb2JqZWN0Y29lcmNpYmxlXG5cdHZhciByZXF1aXJlT2JqZWN0Q29lcmNpYmxlID0gZnVuY3Rpb24gKGl0KSB7XG5cdCAgaWYgKGl0ID09IHVuZGVmaW5lZCkgdGhyb3cgVHlwZUVycm9yKFwiQ2FuJ3QgY2FsbCBtZXRob2Qgb24gXCIgKyBpdCk7XG5cdCAgcmV0dXJuIGl0O1xuXHR9O1xuXG5cdC8vIHRvT2JqZWN0IHdpdGggZmFsbGJhY2sgZm9yIG5vbi1hcnJheS1saWtlIEVTMyBzdHJpbmdzXG5cblxuXG5cdHZhciB0b0luZGV4ZWRPYmplY3QgPSBmdW5jdGlvbiAoaXQpIHtcblx0ICByZXR1cm4gaW5kZXhlZE9iamVjdChyZXF1aXJlT2JqZWN0Q29lcmNpYmxlKGl0KSk7XG5cdH07XG5cblx0dmFyIGlzT2JqZWN0ID0gZnVuY3Rpb24gKGl0KSB7XG5cdCAgcmV0dXJuIHR5cGVvZiBpdCA9PT0gJ29iamVjdCcgPyBpdCAhPT0gbnVsbCA6IHR5cGVvZiBpdCA9PT0gJ2Z1bmN0aW9uJztcblx0fTtcblxuXHQvLyBgVG9QcmltaXRpdmVgIGFic3RyYWN0IG9wZXJhdGlvblxuXHQvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy10b3ByaW1pdGl2ZVxuXHQvLyBpbnN0ZWFkIG9mIHRoZSBFUzYgc3BlYyB2ZXJzaW9uLCB3ZSBkaWRuJ3QgaW1wbGVtZW50IEBAdG9QcmltaXRpdmUgY2FzZVxuXHQvLyBhbmQgdGhlIHNlY29uZCBhcmd1bWVudCAtIGZsYWcgLSBwcmVmZXJyZWQgdHlwZSBpcyBhIHN0cmluZ1xuXHR2YXIgdG9QcmltaXRpdmUgPSBmdW5jdGlvbiAoaW5wdXQsIFBSRUZFUlJFRF9TVFJJTkcpIHtcblx0ICBpZiAoIWlzT2JqZWN0KGlucHV0KSkgcmV0dXJuIGlucHV0O1xuXHQgIHZhciBmbiwgdmFsO1xuXHQgIGlmIChQUkVGRVJSRURfU1RSSU5HICYmIHR5cGVvZiAoZm4gPSBpbnB1dC50b1N0cmluZykgPT0gJ2Z1bmN0aW9uJyAmJiAhaXNPYmplY3QodmFsID0gZm4uY2FsbChpbnB1dCkpKSByZXR1cm4gdmFsO1xuXHQgIGlmICh0eXBlb2YgKGZuID0gaW5wdXQudmFsdWVPZikgPT0gJ2Z1bmN0aW9uJyAmJiAhaXNPYmplY3QodmFsID0gZm4uY2FsbChpbnB1dCkpKSByZXR1cm4gdmFsO1xuXHQgIGlmICghUFJFRkVSUkVEX1NUUklORyAmJiB0eXBlb2YgKGZuID0gaW5wdXQudG9TdHJpbmcpID09ICdmdW5jdGlvbicgJiYgIWlzT2JqZWN0KHZhbCA9IGZuLmNhbGwoaW5wdXQpKSkgcmV0dXJuIHZhbDtcblx0ICB0aHJvdyBUeXBlRXJyb3IoXCJDYW4ndCBjb252ZXJ0IG9iamVjdCB0byBwcmltaXRpdmUgdmFsdWVcIik7XG5cdH07XG5cblx0dmFyIGhhc093blByb3BlcnR5ID0ge30uaGFzT3duUHJvcGVydHk7XG5cblx0dmFyIGhhcyA9IGZ1bmN0aW9uIChpdCwga2V5KSB7XG5cdCAgcmV0dXJuIGhhc093blByb3BlcnR5LmNhbGwoaXQsIGtleSk7XG5cdH07XG5cblx0dmFyIGRvY3VtZW50JDEgPSBnbG9iYWxfMS5kb2N1bWVudDtcblx0Ly8gdHlwZW9mIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQgaXMgJ29iamVjdCcgaW4gb2xkIElFXG5cdHZhciBFWElTVFMgPSBpc09iamVjdChkb2N1bWVudCQxKSAmJiBpc09iamVjdChkb2N1bWVudCQxLmNyZWF0ZUVsZW1lbnQpO1xuXG5cdHZhciBkb2N1bWVudENyZWF0ZUVsZW1lbnQgPSBmdW5jdGlvbiAoaXQpIHtcblx0ICByZXR1cm4gRVhJU1RTID8gZG9jdW1lbnQkMS5jcmVhdGVFbGVtZW50KGl0KSA6IHt9O1xuXHR9O1xuXG5cdC8vIFRoYW5rJ3MgSUU4IGZvciBoaXMgZnVubnkgZGVmaW5lUHJvcGVydHlcblx0dmFyIGllOERvbURlZmluZSA9ICFkZXNjcmlwdG9ycyAmJiAhZmFpbHMoZnVuY3Rpb24gKCkge1xuXHQgIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkoZG9jdW1lbnRDcmVhdGVFbGVtZW50KCdkaXYnKSwgJ2EnLCB7XG5cdCAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDc7IH1cblx0ICB9KS5hICE9IDc7XG5cdH0pO1xuXG5cdHZhciBuYXRpdmVHZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xuXG5cdC8vIGBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yYCBtZXRob2Rcblx0Ly8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtb2JqZWN0LmdldG93bnByb3BlcnR5ZGVzY3JpcHRvclxuXHR2YXIgZiQxID0gZGVzY3JpcHRvcnMgPyBuYXRpdmVHZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgOiBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTywgUCkge1xuXHQgIE8gPSB0b0luZGV4ZWRPYmplY3QoTyk7XG5cdCAgUCA9IHRvUHJpbWl0aXZlKFAsIHRydWUpO1xuXHQgIGlmIChpZThEb21EZWZpbmUpIHRyeSB7XG5cdCAgICByZXR1cm4gbmF0aXZlR2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE8sIFApO1xuXHQgIH0gY2F0Y2ggKGVycm9yKSB7IC8qIGVtcHR5ICovIH1cblx0ICBpZiAoaGFzKE8sIFApKSByZXR1cm4gY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yKCFvYmplY3RQcm9wZXJ0eUlzRW51bWVyYWJsZS5mLmNhbGwoTywgUCksIE9bUF0pO1xuXHR9O1xuXG5cdHZhciBvYmplY3RHZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSB7XG5cdFx0ZjogZiQxXG5cdH07XG5cblx0dmFyIGFuT2JqZWN0ID0gZnVuY3Rpb24gKGl0KSB7XG5cdCAgaWYgKCFpc09iamVjdChpdCkpIHtcblx0ICAgIHRocm93IFR5cGVFcnJvcihTdHJpbmcoaXQpICsgJyBpcyBub3QgYW4gb2JqZWN0Jyk7XG5cdCAgfSByZXR1cm4gaXQ7XG5cdH07XG5cblx0dmFyIG5hdGl2ZURlZmluZVByb3BlcnR5ID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xuXG5cdC8vIGBPYmplY3QuZGVmaW5lUHJvcGVydHlgIG1ldGhvZFxuXHQvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1vYmplY3QuZGVmaW5lcHJvcGVydHlcblx0dmFyIGYkMiA9IGRlc2NyaXB0b3JzID8gbmF0aXZlRGVmaW5lUHJvcGVydHkgOiBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0eShPLCBQLCBBdHRyaWJ1dGVzKSB7XG5cdCAgYW5PYmplY3QoTyk7XG5cdCAgUCA9IHRvUHJpbWl0aXZlKFAsIHRydWUpO1xuXHQgIGFuT2JqZWN0KEF0dHJpYnV0ZXMpO1xuXHQgIGlmIChpZThEb21EZWZpbmUpIHRyeSB7XG5cdCAgICByZXR1cm4gbmF0aXZlRGVmaW5lUHJvcGVydHkoTywgUCwgQXR0cmlidXRlcyk7XG5cdCAgfSBjYXRjaCAoZXJyb3IpIHsgLyogZW1wdHkgKi8gfVxuXHQgIGlmICgnZ2V0JyBpbiBBdHRyaWJ1dGVzIHx8ICdzZXQnIGluIEF0dHJpYnV0ZXMpIHRocm93IFR5cGVFcnJvcignQWNjZXNzb3JzIG5vdCBzdXBwb3J0ZWQnKTtcblx0ICBpZiAoJ3ZhbHVlJyBpbiBBdHRyaWJ1dGVzKSBPW1BdID0gQXR0cmlidXRlcy52YWx1ZTtcblx0ICByZXR1cm4gTztcblx0fTtcblxuXHR2YXIgb2JqZWN0RGVmaW5lUHJvcGVydHkgPSB7XG5cdFx0ZjogZiQyXG5cdH07XG5cblx0dmFyIGhpZGUgPSBkZXNjcmlwdG9ycyA/IGZ1bmN0aW9uIChvYmplY3QsIGtleSwgdmFsdWUpIHtcblx0ICByZXR1cm4gb2JqZWN0RGVmaW5lUHJvcGVydHkuZihvYmplY3QsIGtleSwgY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yKDEsIHZhbHVlKSk7XG5cdH0gOiBmdW5jdGlvbiAob2JqZWN0LCBrZXksIHZhbHVlKSB7XG5cdCAgb2JqZWN0W2tleV0gPSB2YWx1ZTtcblx0ICByZXR1cm4gb2JqZWN0O1xuXHR9O1xuXG5cdHZhciBzZXRHbG9iYWwgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuXHQgIHRyeSB7XG5cdCAgICBoaWRlKGdsb2JhbF8xLCBrZXksIHZhbHVlKTtcblx0ICB9IGNhdGNoIChlcnJvcikge1xuXHQgICAgZ2xvYmFsXzFba2V5XSA9IHZhbHVlO1xuXHQgIH0gcmV0dXJuIHZhbHVlO1xuXHR9O1xuXG5cdHZhciBpc1B1cmUgPSBmYWxzZTtcblxuXHR2YXIgc2hhcmVkID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSkge1xuXHR2YXIgU0hBUkVEID0gJ19fY29yZS1qc19zaGFyZWRfXyc7XG5cdHZhciBzdG9yZSA9IGdsb2JhbF8xW1NIQVJFRF0gfHwgc2V0R2xvYmFsKFNIQVJFRCwge30pO1xuXG5cdChtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG5cdCAgcmV0dXJuIHN0b3JlW2tleV0gfHwgKHN0b3JlW2tleV0gPSB2YWx1ZSAhPT0gdW5kZWZpbmVkID8gdmFsdWUgOiB7fSk7XG5cdH0pKCd2ZXJzaW9ucycsIFtdKS5wdXNoKHtcblx0ICB2ZXJzaW9uOiAnMy4yLjEnLFxuXHQgIG1vZGU6ICAnZ2xvYmFsJyxcblx0ICBjb3B5cmlnaHQ6ICfCqSAyMDE5IERlbmlzIFB1c2hrYXJldiAoemxvaXJvY2sucnUpJ1xuXHR9KTtcblx0fSk7XG5cblx0dmFyIGZ1bmN0aW9uVG9TdHJpbmcgPSBzaGFyZWQoJ25hdGl2ZS1mdW5jdGlvbi10by1zdHJpbmcnLCBGdW5jdGlvbi50b1N0cmluZyk7XG5cblx0dmFyIFdlYWtNYXAgPSBnbG9iYWxfMS5XZWFrTWFwO1xuXG5cdHZhciBuYXRpdmVXZWFrTWFwID0gdHlwZW9mIFdlYWtNYXAgPT09ICdmdW5jdGlvbicgJiYgL25hdGl2ZSBjb2RlLy50ZXN0KGZ1bmN0aW9uVG9TdHJpbmcuY2FsbChXZWFrTWFwKSk7XG5cblx0dmFyIGlkID0gMDtcblx0dmFyIHBvc3RmaXggPSBNYXRoLnJhbmRvbSgpO1xuXG5cdHZhciB1aWQgPSBmdW5jdGlvbiAoa2V5KSB7XG5cdCAgcmV0dXJuICdTeW1ib2woJyArIFN0cmluZyhrZXkgPT09IHVuZGVmaW5lZCA/ICcnIDoga2V5KSArICcpXycgKyAoKytpZCArIHBvc3RmaXgpLnRvU3RyaW5nKDM2KTtcblx0fTtcblxuXHR2YXIga2V5cyA9IHNoYXJlZCgna2V5cycpO1xuXG5cdHZhciBzaGFyZWRLZXkgPSBmdW5jdGlvbiAoa2V5KSB7XG5cdCAgcmV0dXJuIGtleXNba2V5XSB8fCAoa2V5c1trZXldID0gdWlkKGtleSkpO1xuXHR9O1xuXG5cdHZhciBoaWRkZW5LZXlzID0ge307XG5cblx0dmFyIFdlYWtNYXAkMSA9IGdsb2JhbF8xLldlYWtNYXA7XG5cdHZhciBzZXQsIGdldCwgaGFzJDE7XG5cblx0dmFyIGVuZm9yY2UgPSBmdW5jdGlvbiAoaXQpIHtcblx0ICByZXR1cm4gaGFzJDEoaXQpID8gZ2V0KGl0KSA6IHNldChpdCwge30pO1xuXHR9O1xuXG5cdHZhciBnZXR0ZXJGb3IgPSBmdW5jdGlvbiAoVFlQRSkge1xuXHQgIHJldHVybiBmdW5jdGlvbiAoaXQpIHtcblx0ICAgIHZhciBzdGF0ZTtcblx0ICAgIGlmICghaXNPYmplY3QoaXQpIHx8IChzdGF0ZSA9IGdldChpdCkpLnR5cGUgIT09IFRZUEUpIHtcblx0ICAgICAgdGhyb3cgVHlwZUVycm9yKCdJbmNvbXBhdGlibGUgcmVjZWl2ZXIsICcgKyBUWVBFICsgJyByZXF1aXJlZCcpO1xuXHQgICAgfSByZXR1cm4gc3RhdGU7XG5cdCAgfTtcblx0fTtcblxuXHRpZiAobmF0aXZlV2Vha01hcCkge1xuXHQgIHZhciBzdG9yZSA9IG5ldyBXZWFrTWFwJDEoKTtcblx0ICB2YXIgd21nZXQgPSBzdG9yZS5nZXQ7XG5cdCAgdmFyIHdtaGFzID0gc3RvcmUuaGFzO1xuXHQgIHZhciB3bXNldCA9IHN0b3JlLnNldDtcblx0ICBzZXQgPSBmdW5jdGlvbiAoaXQsIG1ldGFkYXRhKSB7XG5cdCAgICB3bXNldC5jYWxsKHN0b3JlLCBpdCwgbWV0YWRhdGEpO1xuXHQgICAgcmV0dXJuIG1ldGFkYXRhO1xuXHQgIH07XG5cdCAgZ2V0ID0gZnVuY3Rpb24gKGl0KSB7XG5cdCAgICByZXR1cm4gd21nZXQuY2FsbChzdG9yZSwgaXQpIHx8IHt9O1xuXHQgIH07XG5cdCAgaGFzJDEgPSBmdW5jdGlvbiAoaXQpIHtcblx0ICAgIHJldHVybiB3bWhhcy5jYWxsKHN0b3JlLCBpdCk7XG5cdCAgfTtcblx0fSBlbHNlIHtcblx0ICB2YXIgU1RBVEUgPSBzaGFyZWRLZXkoJ3N0YXRlJyk7XG5cdCAgaGlkZGVuS2V5c1tTVEFURV0gPSB0cnVlO1xuXHQgIHNldCA9IGZ1bmN0aW9uIChpdCwgbWV0YWRhdGEpIHtcblx0ICAgIGhpZGUoaXQsIFNUQVRFLCBtZXRhZGF0YSk7XG5cdCAgICByZXR1cm4gbWV0YWRhdGE7XG5cdCAgfTtcblx0ICBnZXQgPSBmdW5jdGlvbiAoaXQpIHtcblx0ICAgIHJldHVybiBoYXMoaXQsIFNUQVRFKSA/IGl0W1NUQVRFXSA6IHt9O1xuXHQgIH07XG5cdCAgaGFzJDEgPSBmdW5jdGlvbiAoaXQpIHtcblx0ICAgIHJldHVybiBoYXMoaXQsIFNUQVRFKTtcblx0ICB9O1xuXHR9XG5cblx0dmFyIGludGVybmFsU3RhdGUgPSB7XG5cdCAgc2V0OiBzZXQsXG5cdCAgZ2V0OiBnZXQsXG5cdCAgaGFzOiBoYXMkMSxcblx0ICBlbmZvcmNlOiBlbmZvcmNlLFxuXHQgIGdldHRlckZvcjogZ2V0dGVyRm9yXG5cdH07XG5cblx0dmFyIHJlZGVmaW5lID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSkge1xuXHR2YXIgZ2V0SW50ZXJuYWxTdGF0ZSA9IGludGVybmFsU3RhdGUuZ2V0O1xuXHR2YXIgZW5mb3JjZUludGVybmFsU3RhdGUgPSBpbnRlcm5hbFN0YXRlLmVuZm9yY2U7XG5cdHZhciBURU1QTEFURSA9IFN0cmluZyhmdW5jdGlvblRvU3RyaW5nKS5zcGxpdCgndG9TdHJpbmcnKTtcblxuXHRzaGFyZWQoJ2luc3BlY3RTb3VyY2UnLCBmdW5jdGlvbiAoaXQpIHtcblx0ICByZXR1cm4gZnVuY3Rpb25Ub1N0cmluZy5jYWxsKGl0KTtcblx0fSk7XG5cblx0KG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKE8sIGtleSwgdmFsdWUsIG9wdGlvbnMpIHtcblx0ICB2YXIgdW5zYWZlID0gb3B0aW9ucyA/ICEhb3B0aW9ucy51bnNhZmUgOiBmYWxzZTtcblx0ICB2YXIgc2ltcGxlID0gb3B0aW9ucyA/ICEhb3B0aW9ucy5lbnVtZXJhYmxlIDogZmFsc2U7XG5cdCAgdmFyIG5vVGFyZ2V0R2V0ID0gb3B0aW9ucyA/ICEhb3B0aW9ucy5ub1RhcmdldEdldCA6IGZhbHNlO1xuXHQgIGlmICh0eXBlb2YgdmFsdWUgPT0gJ2Z1bmN0aW9uJykge1xuXHQgICAgaWYgKHR5cGVvZiBrZXkgPT0gJ3N0cmluZycgJiYgIWhhcyh2YWx1ZSwgJ25hbWUnKSkgaGlkZSh2YWx1ZSwgJ25hbWUnLCBrZXkpO1xuXHQgICAgZW5mb3JjZUludGVybmFsU3RhdGUodmFsdWUpLnNvdXJjZSA9IFRFTVBMQVRFLmpvaW4odHlwZW9mIGtleSA9PSAnc3RyaW5nJyA/IGtleSA6ICcnKTtcblx0ICB9XG5cdCAgaWYgKE8gPT09IGdsb2JhbF8xKSB7XG5cdCAgICBpZiAoc2ltcGxlKSBPW2tleV0gPSB2YWx1ZTtcblx0ICAgIGVsc2Ugc2V0R2xvYmFsKGtleSwgdmFsdWUpO1xuXHQgICAgcmV0dXJuO1xuXHQgIH0gZWxzZSBpZiAoIXVuc2FmZSkge1xuXHQgICAgZGVsZXRlIE9ba2V5XTtcblx0ICB9IGVsc2UgaWYgKCFub1RhcmdldEdldCAmJiBPW2tleV0pIHtcblx0ICAgIHNpbXBsZSA9IHRydWU7XG5cdCAgfVxuXHQgIGlmIChzaW1wbGUpIE9ba2V5XSA9IHZhbHVlO1xuXHQgIGVsc2UgaGlkZShPLCBrZXksIHZhbHVlKTtcblx0Ly8gYWRkIGZha2UgRnVuY3Rpb24jdG9TdHJpbmcgZm9yIGNvcnJlY3Qgd29yayB3cmFwcGVkIG1ldGhvZHMgLyBjb25zdHJ1Y3RvcnMgd2l0aCBtZXRob2RzIGxpa2UgTG9EYXNoIGlzTmF0aXZlXG5cdH0pKEZ1bmN0aW9uLnByb3RvdHlwZSwgJ3RvU3RyaW5nJywgZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG5cdCAgcmV0dXJuIHR5cGVvZiB0aGlzID09ICdmdW5jdGlvbicgJiYgZ2V0SW50ZXJuYWxTdGF0ZSh0aGlzKS5zb3VyY2UgfHwgZnVuY3Rpb25Ub1N0cmluZy5jYWxsKHRoaXMpO1xuXHR9KTtcblx0fSk7XG5cblx0dmFyIHBhdGggPSBnbG9iYWxfMTtcblxuXHR2YXIgYUZ1bmN0aW9uID0gZnVuY3Rpb24gKHZhcmlhYmxlKSB7XG5cdCAgcmV0dXJuIHR5cGVvZiB2YXJpYWJsZSA9PSAnZnVuY3Rpb24nID8gdmFyaWFibGUgOiB1bmRlZmluZWQ7XG5cdH07XG5cblx0dmFyIGdldEJ1aWx0SW4gPSBmdW5jdGlvbiAobmFtZXNwYWNlLCBtZXRob2QpIHtcblx0ICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA8IDIgPyBhRnVuY3Rpb24ocGF0aFtuYW1lc3BhY2VdKSB8fCBhRnVuY3Rpb24oZ2xvYmFsXzFbbmFtZXNwYWNlXSlcblx0ICAgIDogcGF0aFtuYW1lc3BhY2VdICYmIHBhdGhbbmFtZXNwYWNlXVttZXRob2RdIHx8IGdsb2JhbF8xW25hbWVzcGFjZV0gJiYgZ2xvYmFsXzFbbmFtZXNwYWNlXVttZXRob2RdO1xuXHR9O1xuXG5cdHZhciBjZWlsID0gTWF0aC5jZWlsO1xuXHR2YXIgZmxvb3IgPSBNYXRoLmZsb29yO1xuXG5cdC8vIGBUb0ludGVnZXJgIGFic3RyYWN0IG9wZXJhdGlvblxuXHQvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy10b2ludGVnZXJcblx0dmFyIHRvSW50ZWdlciA9IGZ1bmN0aW9uIChhcmd1bWVudCkge1xuXHQgIHJldHVybiBpc05hTihhcmd1bWVudCA9ICthcmd1bWVudCkgPyAwIDogKGFyZ3VtZW50ID4gMCA/IGZsb29yIDogY2VpbCkoYXJndW1lbnQpO1xuXHR9O1xuXG5cdHZhciBtaW4gPSBNYXRoLm1pbjtcblxuXHQvLyBgVG9MZW5ndGhgIGFic3RyYWN0IG9wZXJhdGlvblxuXHQvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy10b2xlbmd0aFxuXHR2YXIgdG9MZW5ndGggPSBmdW5jdGlvbiAoYXJndW1lbnQpIHtcblx0ICByZXR1cm4gYXJndW1lbnQgPiAwID8gbWluKHRvSW50ZWdlcihhcmd1bWVudCksIDB4MUZGRkZGRkZGRkZGRkYpIDogMDsgLy8gMiAqKiA1MyAtIDEgPT0gOTAwNzE5OTI1NDc0MDk5MVxuXHR9O1xuXG5cdHZhciBtYXggPSBNYXRoLm1heDtcblx0dmFyIG1pbiQxID0gTWF0aC5taW47XG5cblx0Ly8gSGVscGVyIGZvciBhIHBvcHVsYXIgcmVwZWF0aW5nIGNhc2Ugb2YgdGhlIHNwZWM6XG5cdC8vIExldCBpbnRlZ2VyIGJlID8gVG9JbnRlZ2VyKGluZGV4KS5cblx0Ly8gSWYgaW50ZWdlciA8IDAsIGxldCByZXN1bHQgYmUgbWF4KChsZW5ndGggKyBpbnRlZ2VyKSwgMCk7IGVsc2UgbGV0IHJlc3VsdCBiZSBtaW4obGVuZ3RoLCBsZW5ndGgpLlxuXHR2YXIgdG9BYnNvbHV0ZUluZGV4ID0gZnVuY3Rpb24gKGluZGV4LCBsZW5ndGgpIHtcblx0ICB2YXIgaW50ZWdlciA9IHRvSW50ZWdlcihpbmRleCk7XG5cdCAgcmV0dXJuIGludGVnZXIgPCAwID8gbWF4KGludGVnZXIgKyBsZW5ndGgsIDApIDogbWluJDEoaW50ZWdlciwgbGVuZ3RoKTtcblx0fTtcblxuXHQvLyBgQXJyYXkucHJvdG90eXBlLnsgaW5kZXhPZiwgaW5jbHVkZXMgfWAgbWV0aG9kcyBpbXBsZW1lbnRhdGlvblxuXHR2YXIgY3JlYXRlTWV0aG9kID0gZnVuY3Rpb24gKElTX0lOQ0xVREVTKSB7XG5cdCAgcmV0dXJuIGZ1bmN0aW9uICgkdGhpcywgZWwsIGZyb21JbmRleCkge1xuXHQgICAgdmFyIE8gPSB0b0luZGV4ZWRPYmplY3QoJHRoaXMpO1xuXHQgICAgdmFyIGxlbmd0aCA9IHRvTGVuZ3RoKE8ubGVuZ3RoKTtcblx0ICAgIHZhciBpbmRleCA9IHRvQWJzb2x1dGVJbmRleChmcm9tSW5kZXgsIGxlbmd0aCk7XG5cdCAgICB2YXIgdmFsdWU7XG5cdCAgICAvLyBBcnJheSNpbmNsdWRlcyB1c2VzIFNhbWVWYWx1ZVplcm8gZXF1YWxpdHkgYWxnb3JpdGhtXG5cdCAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1jb21wYXJlXG5cdCAgICBpZiAoSVNfSU5DTFVERVMgJiYgZWwgIT0gZWwpIHdoaWxlIChsZW5ndGggPiBpbmRleCkge1xuXHQgICAgICB2YWx1ZSA9IE9baW5kZXgrK107XG5cdCAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWNvbXBhcmVcblx0ICAgICAgaWYgKHZhbHVlICE9IHZhbHVlKSByZXR1cm4gdHJ1ZTtcblx0ICAgIC8vIEFycmF5I2luZGV4T2YgaWdub3JlcyBob2xlcywgQXJyYXkjaW5jbHVkZXMgLSBub3Rcblx0ICAgIH0gZWxzZSBmb3IgKDtsZW5ndGggPiBpbmRleDsgaW5kZXgrKykge1xuXHQgICAgICBpZiAoKElTX0lOQ0xVREVTIHx8IGluZGV4IGluIE8pICYmIE9baW5kZXhdID09PSBlbCkgcmV0dXJuIElTX0lOQ0xVREVTIHx8IGluZGV4IHx8IDA7XG5cdCAgICB9IHJldHVybiAhSVNfSU5DTFVERVMgJiYgLTE7XG5cdCAgfTtcblx0fTtcblxuXHR2YXIgYXJyYXlJbmNsdWRlcyA9IHtcblx0ICAvLyBgQXJyYXkucHJvdG90eXBlLmluY2x1ZGVzYCBtZXRob2Rcblx0ICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUuaW5jbHVkZXNcblx0ICBpbmNsdWRlczogY3JlYXRlTWV0aG9kKHRydWUpLFxuXHQgIC8vIGBBcnJheS5wcm90b3R5cGUuaW5kZXhPZmAgbWV0aG9kXG5cdCAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLmluZGV4b2Zcblx0ICBpbmRleE9mOiBjcmVhdGVNZXRob2QoZmFsc2UpXG5cdH07XG5cblx0dmFyIGluZGV4T2YgPSBhcnJheUluY2x1ZGVzLmluZGV4T2Y7XG5cblxuXHR2YXIgb2JqZWN0S2V5c0ludGVybmFsID0gZnVuY3Rpb24gKG9iamVjdCwgbmFtZXMpIHtcblx0ICB2YXIgTyA9IHRvSW5kZXhlZE9iamVjdChvYmplY3QpO1xuXHQgIHZhciBpID0gMDtcblx0ICB2YXIgcmVzdWx0ID0gW107XG5cdCAgdmFyIGtleTtcblx0ICBmb3IgKGtleSBpbiBPKSAhaGFzKGhpZGRlbktleXMsIGtleSkgJiYgaGFzKE8sIGtleSkgJiYgcmVzdWx0LnB1c2goa2V5KTtcblx0ICAvLyBEb24ndCBlbnVtIGJ1ZyAmIGhpZGRlbiBrZXlzXG5cdCAgd2hpbGUgKG5hbWVzLmxlbmd0aCA+IGkpIGlmIChoYXMoTywga2V5ID0gbmFtZXNbaSsrXSkpIHtcblx0ICAgIH5pbmRleE9mKHJlc3VsdCwga2V5KSB8fCByZXN1bHQucHVzaChrZXkpO1xuXHQgIH1cblx0ICByZXR1cm4gcmVzdWx0O1xuXHR9O1xuXG5cdC8vIElFOC0gZG9uJ3QgZW51bSBidWcga2V5c1xuXHR2YXIgZW51bUJ1Z0tleXMgPSBbXG5cdCAgJ2NvbnN0cnVjdG9yJyxcblx0ICAnaGFzT3duUHJvcGVydHknLFxuXHQgICdpc1Byb3RvdHlwZU9mJyxcblx0ICAncHJvcGVydHlJc0VudW1lcmFibGUnLFxuXHQgICd0b0xvY2FsZVN0cmluZycsXG5cdCAgJ3RvU3RyaW5nJyxcblx0ICAndmFsdWVPZidcblx0XTtcblxuXHR2YXIgaGlkZGVuS2V5cyQxID0gZW51bUJ1Z0tleXMuY29uY2F0KCdsZW5ndGgnLCAncHJvdG90eXBlJyk7XG5cblx0Ly8gYE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzYCBtZXRob2Rcblx0Ly8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtb2JqZWN0LmdldG93bnByb3BlcnR5bmFtZXNcblx0dmFyIGYkMyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzIHx8IGZ1bmN0aW9uIGdldE93blByb3BlcnR5TmFtZXMoTykge1xuXHQgIHJldHVybiBvYmplY3RLZXlzSW50ZXJuYWwoTywgaGlkZGVuS2V5cyQxKTtcblx0fTtcblxuXHR2YXIgb2JqZWN0R2V0T3duUHJvcGVydHlOYW1lcyA9IHtcblx0XHRmOiBmJDNcblx0fTtcblxuXHR2YXIgZiQ0ID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcblxuXHR2YXIgb2JqZWN0R2V0T3duUHJvcGVydHlTeW1ib2xzID0ge1xuXHRcdGY6IGYkNFxuXHR9O1xuXG5cdC8vIGFsbCBvYmplY3Qga2V5cywgaW5jbHVkZXMgbm9uLWVudW1lcmFibGUgYW5kIHN5bWJvbHNcblx0dmFyIG93bktleXMgPSBnZXRCdWlsdEluKCdSZWZsZWN0JywgJ293bktleXMnKSB8fCBmdW5jdGlvbiBvd25LZXlzKGl0KSB7XG5cdCAgdmFyIGtleXMgPSBvYmplY3RHZXRPd25Qcm9wZXJ0eU5hbWVzLmYoYW5PYmplY3QoaXQpKTtcblx0ICB2YXIgZ2V0T3duUHJvcGVydHlTeW1ib2xzID0gb2JqZWN0R2V0T3duUHJvcGVydHlTeW1ib2xzLmY7XG5cdCAgcmV0dXJuIGdldE93blByb3BlcnR5U3ltYm9scyA/IGtleXMuY29uY2F0KGdldE93blByb3BlcnR5U3ltYm9scyhpdCkpIDoga2V5cztcblx0fTtcblxuXHR2YXIgY29weUNvbnN0cnVjdG9yUHJvcGVydGllcyA9IGZ1bmN0aW9uICh0YXJnZXQsIHNvdXJjZSkge1xuXHQgIHZhciBrZXlzID0gb3duS2V5cyhzb3VyY2UpO1xuXHQgIHZhciBkZWZpbmVQcm9wZXJ0eSA9IG9iamVjdERlZmluZVByb3BlcnR5LmY7XG5cdCAgdmFyIGdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IG9iamVjdEdldE93blByb3BlcnR5RGVzY3JpcHRvci5mO1xuXHQgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuXHQgICAgdmFyIGtleSA9IGtleXNbaV07XG5cdCAgICBpZiAoIWhhcyh0YXJnZXQsIGtleSkpIGRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTtcblx0ICB9XG5cdH07XG5cblx0dmFyIHJlcGxhY2VtZW50ID0gLyN8XFwucHJvdG90eXBlXFwuLztcblxuXHR2YXIgaXNGb3JjZWQgPSBmdW5jdGlvbiAoZmVhdHVyZSwgZGV0ZWN0aW9uKSB7XG5cdCAgdmFyIHZhbHVlID0gZGF0YVtub3JtYWxpemUoZmVhdHVyZSldO1xuXHQgIHJldHVybiB2YWx1ZSA9PSBQT0xZRklMTCA/IHRydWVcblx0ICAgIDogdmFsdWUgPT0gTkFUSVZFID8gZmFsc2Vcblx0ICAgIDogdHlwZW9mIGRldGVjdGlvbiA9PSAnZnVuY3Rpb24nID8gZmFpbHMoZGV0ZWN0aW9uKVxuXHQgICAgOiAhIWRldGVjdGlvbjtcblx0fTtcblxuXHR2YXIgbm9ybWFsaXplID0gaXNGb3JjZWQubm9ybWFsaXplID0gZnVuY3Rpb24gKHN0cmluZykge1xuXHQgIHJldHVybiBTdHJpbmcoc3RyaW5nKS5yZXBsYWNlKHJlcGxhY2VtZW50LCAnLicpLnRvTG93ZXJDYXNlKCk7XG5cdH07XG5cblx0dmFyIGRhdGEgPSBpc0ZvcmNlZC5kYXRhID0ge307XG5cdHZhciBOQVRJVkUgPSBpc0ZvcmNlZC5OQVRJVkUgPSAnTic7XG5cdHZhciBQT0xZRklMTCA9IGlzRm9yY2VkLlBPTFlGSUxMID0gJ1AnO1xuXG5cdHZhciBpc0ZvcmNlZF8xID0gaXNGb3JjZWQ7XG5cblx0dmFyIGdldE93blByb3BlcnR5RGVzY3JpcHRvciQxID0gb2JqZWN0R2V0T3duUHJvcGVydHlEZXNjcmlwdG9yLmY7XG5cblxuXG5cblxuXG5cdC8qXG5cdCAgb3B0aW9ucy50YXJnZXQgICAgICAtIG5hbWUgb2YgdGhlIHRhcmdldCBvYmplY3Rcblx0ICBvcHRpb25zLmdsb2JhbCAgICAgIC0gdGFyZ2V0IGlzIHRoZSBnbG9iYWwgb2JqZWN0XG5cdCAgb3B0aW9ucy5zdGF0ICAgICAgICAtIGV4cG9ydCBhcyBzdGF0aWMgbWV0aG9kcyBvZiB0YXJnZXRcblx0ICBvcHRpb25zLnByb3RvICAgICAgIC0gZXhwb3J0IGFzIHByb3RvdHlwZSBtZXRob2RzIG9mIHRhcmdldFxuXHQgIG9wdGlvbnMucmVhbCAgICAgICAgLSByZWFsIHByb3RvdHlwZSBtZXRob2QgZm9yIHRoZSBgcHVyZWAgdmVyc2lvblxuXHQgIG9wdGlvbnMuZm9yY2VkICAgICAgLSBleHBvcnQgZXZlbiBpZiB0aGUgbmF0aXZlIGZlYXR1cmUgaXMgYXZhaWxhYmxlXG5cdCAgb3B0aW9ucy5iaW5kICAgICAgICAtIGJpbmQgbWV0aG9kcyB0byB0aGUgdGFyZ2V0LCByZXF1aXJlZCBmb3IgdGhlIGBwdXJlYCB2ZXJzaW9uXG5cdCAgb3B0aW9ucy53cmFwICAgICAgICAtIHdyYXAgY29uc3RydWN0b3JzIHRvIHByZXZlbnRpbmcgZ2xvYmFsIHBvbGx1dGlvbiwgcmVxdWlyZWQgZm9yIHRoZSBgcHVyZWAgdmVyc2lvblxuXHQgIG9wdGlvbnMudW5zYWZlICAgICAgLSB1c2UgdGhlIHNpbXBsZSBhc3NpZ25tZW50IG9mIHByb3BlcnR5IGluc3RlYWQgb2YgZGVsZXRlICsgZGVmaW5lUHJvcGVydHlcblx0ICBvcHRpb25zLnNoYW0gICAgICAgIC0gYWRkIGEgZmxhZyB0byBub3QgY29tcGxldGVseSBmdWxsIHBvbHlmaWxsc1xuXHQgIG9wdGlvbnMuZW51bWVyYWJsZSAgLSBleHBvcnQgYXMgZW51bWVyYWJsZSBwcm9wZXJ0eVxuXHQgIG9wdGlvbnMubm9UYXJnZXRHZXQgLSBwcmV2ZW50IGNhbGxpbmcgYSBnZXR0ZXIgb24gdGFyZ2V0XG5cdCovXG5cdHZhciBfZXhwb3J0ID0gZnVuY3Rpb24gKG9wdGlvbnMsIHNvdXJjZSkge1xuXHQgIHZhciBUQVJHRVQgPSBvcHRpb25zLnRhcmdldDtcblx0ICB2YXIgR0xPQkFMID0gb3B0aW9ucy5nbG9iYWw7XG5cdCAgdmFyIFNUQVRJQyA9IG9wdGlvbnMuc3RhdDtcblx0ICB2YXIgRk9SQ0VELCB0YXJnZXQsIGtleSwgdGFyZ2V0UHJvcGVydHksIHNvdXJjZVByb3BlcnR5LCBkZXNjcmlwdG9yO1xuXHQgIGlmIChHTE9CQUwpIHtcblx0ICAgIHRhcmdldCA9IGdsb2JhbF8xO1xuXHQgIH0gZWxzZSBpZiAoU1RBVElDKSB7XG5cdCAgICB0YXJnZXQgPSBnbG9iYWxfMVtUQVJHRVRdIHx8IHNldEdsb2JhbChUQVJHRVQsIHt9KTtcblx0ICB9IGVsc2Uge1xuXHQgICAgdGFyZ2V0ID0gKGdsb2JhbF8xW1RBUkdFVF0gfHwge30pLnByb3RvdHlwZTtcblx0ICB9XG5cdCAgaWYgKHRhcmdldCkgZm9yIChrZXkgaW4gc291cmNlKSB7XG5cdCAgICBzb3VyY2VQcm9wZXJ0eSA9IHNvdXJjZVtrZXldO1xuXHQgICAgaWYgKG9wdGlvbnMubm9UYXJnZXRHZXQpIHtcblx0ICAgICAgZGVzY3JpcHRvciA9IGdldE93blByb3BlcnR5RGVzY3JpcHRvciQxKHRhcmdldCwga2V5KTtcblx0ICAgICAgdGFyZ2V0UHJvcGVydHkgPSBkZXNjcmlwdG9yICYmIGRlc2NyaXB0b3IudmFsdWU7XG5cdCAgICB9IGVsc2UgdGFyZ2V0UHJvcGVydHkgPSB0YXJnZXRba2V5XTtcblx0ICAgIEZPUkNFRCA9IGlzRm9yY2VkXzEoR0xPQkFMID8ga2V5IDogVEFSR0VUICsgKFNUQVRJQyA/ICcuJyA6ICcjJykgKyBrZXksIG9wdGlvbnMuZm9yY2VkKTtcblx0ICAgIC8vIGNvbnRhaW5lZCBpbiB0YXJnZXRcblx0ICAgIGlmICghRk9SQ0VEICYmIHRhcmdldFByb3BlcnR5ICE9PSB1bmRlZmluZWQpIHtcblx0ICAgICAgaWYgKHR5cGVvZiBzb3VyY2VQcm9wZXJ0eSA9PT0gdHlwZW9mIHRhcmdldFByb3BlcnR5KSBjb250aW51ZTtcblx0ICAgICAgY29weUNvbnN0cnVjdG9yUHJvcGVydGllcyhzb3VyY2VQcm9wZXJ0eSwgdGFyZ2V0UHJvcGVydHkpO1xuXHQgICAgfVxuXHQgICAgLy8gYWRkIGEgZmxhZyB0byBub3QgY29tcGxldGVseSBmdWxsIHBvbHlmaWxsc1xuXHQgICAgaWYgKG9wdGlvbnMuc2hhbSB8fCAodGFyZ2V0UHJvcGVydHkgJiYgdGFyZ2V0UHJvcGVydHkuc2hhbSkpIHtcblx0ICAgICAgaGlkZShzb3VyY2VQcm9wZXJ0eSwgJ3NoYW0nLCB0cnVlKTtcblx0ICAgIH1cblx0ICAgIC8vIGV4dGVuZCBnbG9iYWxcblx0ICAgIHJlZGVmaW5lKHRhcmdldCwga2V5LCBzb3VyY2VQcm9wZXJ0eSwgb3B0aW9ucyk7XG5cdCAgfVxuXHR9O1xuXG5cdHZhciBmcmVlemluZyA9ICFmYWlscyhmdW5jdGlvbiAoKSB7XG5cdCAgcmV0dXJuIE9iamVjdC5pc0V4dGVuc2libGUoT2JqZWN0LnByZXZlbnRFeHRlbnNpb25zKHt9KSk7XG5cdH0pO1xuXG5cdHZhciBpbnRlcm5hbE1ldGFkYXRhID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSkge1xuXHR2YXIgZGVmaW5lUHJvcGVydHkgPSBvYmplY3REZWZpbmVQcm9wZXJ0eS5mO1xuXG5cblxuXHR2YXIgTUVUQURBVEEgPSB1aWQoJ21ldGEnKTtcblx0dmFyIGlkID0gMDtcblxuXHR2YXIgaXNFeHRlbnNpYmxlID0gT2JqZWN0LmlzRXh0ZW5zaWJsZSB8fCBmdW5jdGlvbiAoKSB7XG5cdCAgcmV0dXJuIHRydWU7XG5cdH07XG5cblx0dmFyIHNldE1ldGFkYXRhID0gZnVuY3Rpb24gKGl0KSB7XG5cdCAgZGVmaW5lUHJvcGVydHkoaXQsIE1FVEFEQVRBLCB7IHZhbHVlOiB7XG5cdCAgICBvYmplY3RJRDogJ08nICsgKytpZCwgLy8gb2JqZWN0IElEXG5cdCAgICB3ZWFrRGF0YToge30gICAgICAgICAgLy8gd2VhayBjb2xsZWN0aW9ucyBJRHNcblx0ICB9IH0pO1xuXHR9O1xuXG5cdHZhciBmYXN0S2V5ID0gZnVuY3Rpb24gKGl0LCBjcmVhdGUpIHtcblx0ICAvLyByZXR1cm4gYSBwcmltaXRpdmUgd2l0aCBwcmVmaXhcblx0ICBpZiAoIWlzT2JqZWN0KGl0KSkgcmV0dXJuIHR5cGVvZiBpdCA9PSAnc3ltYm9sJyA/IGl0IDogKHR5cGVvZiBpdCA9PSAnc3RyaW5nJyA/ICdTJyA6ICdQJykgKyBpdDtcblx0ICBpZiAoIWhhcyhpdCwgTUVUQURBVEEpKSB7XG5cdCAgICAvLyBjYW4ndCBzZXQgbWV0YWRhdGEgdG8gdW5jYXVnaHQgZnJvemVuIG9iamVjdFxuXHQgICAgaWYgKCFpc0V4dGVuc2libGUoaXQpKSByZXR1cm4gJ0YnO1xuXHQgICAgLy8gbm90IG5lY2Vzc2FyeSB0byBhZGQgbWV0YWRhdGFcblx0ICAgIGlmICghY3JlYXRlKSByZXR1cm4gJ0UnO1xuXHQgICAgLy8gYWRkIG1pc3NpbmcgbWV0YWRhdGFcblx0ICAgIHNldE1ldGFkYXRhKGl0KTtcblx0ICAvLyByZXR1cm4gb2JqZWN0IElEXG5cdCAgfSByZXR1cm4gaXRbTUVUQURBVEFdLm9iamVjdElEO1xuXHR9O1xuXG5cdHZhciBnZXRXZWFrRGF0YSA9IGZ1bmN0aW9uIChpdCwgY3JlYXRlKSB7XG5cdCAgaWYgKCFoYXMoaXQsIE1FVEFEQVRBKSkge1xuXHQgICAgLy8gY2FuJ3Qgc2V0IG1ldGFkYXRhIHRvIHVuY2F1Z2h0IGZyb3plbiBvYmplY3Rcblx0ICAgIGlmICghaXNFeHRlbnNpYmxlKGl0KSkgcmV0dXJuIHRydWU7XG5cdCAgICAvLyBub3QgbmVjZXNzYXJ5IHRvIGFkZCBtZXRhZGF0YVxuXHQgICAgaWYgKCFjcmVhdGUpIHJldHVybiBmYWxzZTtcblx0ICAgIC8vIGFkZCBtaXNzaW5nIG1ldGFkYXRhXG5cdCAgICBzZXRNZXRhZGF0YShpdCk7XG5cdCAgLy8gcmV0dXJuIHRoZSBzdG9yZSBvZiB3ZWFrIGNvbGxlY3Rpb25zIElEc1xuXHQgIH0gcmV0dXJuIGl0W01FVEFEQVRBXS53ZWFrRGF0YTtcblx0fTtcblxuXHQvLyBhZGQgbWV0YWRhdGEgb24gZnJlZXplLWZhbWlseSBtZXRob2RzIGNhbGxpbmdcblx0dmFyIG9uRnJlZXplID0gZnVuY3Rpb24gKGl0KSB7XG5cdCAgaWYgKGZyZWV6aW5nICYmIG1ldGEuUkVRVUlSRUQgJiYgaXNFeHRlbnNpYmxlKGl0KSAmJiAhaGFzKGl0LCBNRVRBREFUQSkpIHNldE1ldGFkYXRhKGl0KTtcblx0ICByZXR1cm4gaXQ7XG5cdH07XG5cblx0dmFyIG1ldGEgPSBtb2R1bGUuZXhwb3J0cyA9IHtcblx0ICBSRVFVSVJFRDogZmFsc2UsXG5cdCAgZmFzdEtleTogZmFzdEtleSxcblx0ICBnZXRXZWFrRGF0YTogZ2V0V2Vha0RhdGEsXG5cdCAgb25GcmVlemU6IG9uRnJlZXplXG5cdH07XG5cblx0aGlkZGVuS2V5c1tNRVRBREFUQV0gPSB0cnVlO1xuXHR9KTtcblx0dmFyIGludGVybmFsTWV0YWRhdGFfMSA9IGludGVybmFsTWV0YWRhdGEuUkVRVUlSRUQ7XG5cdHZhciBpbnRlcm5hbE1ldGFkYXRhXzIgPSBpbnRlcm5hbE1ldGFkYXRhLmZhc3RLZXk7XG5cdHZhciBpbnRlcm5hbE1ldGFkYXRhXzMgPSBpbnRlcm5hbE1ldGFkYXRhLmdldFdlYWtEYXRhO1xuXHR2YXIgaW50ZXJuYWxNZXRhZGF0YV80ID0gaW50ZXJuYWxNZXRhZGF0YS5vbkZyZWV6ZTtcblxuXHR2YXIgbmF0aXZlU3ltYm9sID0gISFPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzICYmICFmYWlscyhmdW5jdGlvbiAoKSB7XG5cdCAgLy8gQ2hyb21lIDM4IFN5bWJvbCBoYXMgaW5jb3JyZWN0IHRvU3RyaW5nIGNvbnZlcnNpb25cblx0ICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWZcblx0ICByZXR1cm4gIVN0cmluZyhTeW1ib2woKSk7XG5cdH0pO1xuXG5cdHZhciBTeW1ib2wkMSA9IGdsb2JhbF8xLlN5bWJvbDtcblx0dmFyIHN0b3JlJDEgPSBzaGFyZWQoJ3drcycpO1xuXG5cdHZhciB3ZWxsS25vd25TeW1ib2wgPSBmdW5jdGlvbiAobmFtZSkge1xuXHQgIHJldHVybiBzdG9yZSQxW25hbWVdIHx8IChzdG9yZSQxW25hbWVdID0gbmF0aXZlU3ltYm9sICYmIFN5bWJvbCQxW25hbWVdXG5cdCAgICB8fCAobmF0aXZlU3ltYm9sID8gU3ltYm9sJDEgOiB1aWQpKCdTeW1ib2wuJyArIG5hbWUpKTtcblx0fTtcblxuXHR2YXIgaXRlcmF0b3JzID0ge307XG5cblx0dmFyIElURVJBVE9SID0gd2VsbEtub3duU3ltYm9sKCdpdGVyYXRvcicpO1xuXHR2YXIgQXJyYXlQcm90b3R5cGUgPSBBcnJheS5wcm90b3R5cGU7XG5cblx0Ly8gY2hlY2sgb24gZGVmYXVsdCBBcnJheSBpdGVyYXRvclxuXHR2YXIgaXNBcnJheUl0ZXJhdG9yTWV0aG9kID0gZnVuY3Rpb24gKGl0KSB7XG5cdCAgcmV0dXJuIGl0ICE9PSB1bmRlZmluZWQgJiYgKGl0ZXJhdG9ycy5BcnJheSA9PT0gaXQgfHwgQXJyYXlQcm90b3R5cGVbSVRFUkFUT1JdID09PSBpdCk7XG5cdH07XG5cblx0dmFyIGFGdW5jdGlvbiQxID0gZnVuY3Rpb24gKGl0KSB7XG5cdCAgaWYgKHR5cGVvZiBpdCAhPSAnZnVuY3Rpb24nKSB7XG5cdCAgICB0aHJvdyBUeXBlRXJyb3IoU3RyaW5nKGl0KSArICcgaXMgbm90IGEgZnVuY3Rpb24nKTtcblx0ICB9IHJldHVybiBpdDtcblx0fTtcblxuXHQvLyBvcHRpb25hbCAvIHNpbXBsZSBjb250ZXh0IGJpbmRpbmdcblx0dmFyIGJpbmRDb250ZXh0ID0gZnVuY3Rpb24gKGZuLCB0aGF0LCBsZW5ndGgpIHtcblx0ICBhRnVuY3Rpb24kMShmbik7XG5cdCAgaWYgKHRoYXQgPT09IHVuZGVmaW5lZCkgcmV0dXJuIGZuO1xuXHQgIHN3aXRjaCAobGVuZ3RoKSB7XG5cdCAgICBjYXNlIDA6IHJldHVybiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgIHJldHVybiBmbi5jYWxsKHRoYXQpO1xuXHQgICAgfTtcblx0ICAgIGNhc2UgMTogcmV0dXJuIGZ1bmN0aW9uIChhKSB7XG5cdCAgICAgIHJldHVybiBmbi5jYWxsKHRoYXQsIGEpO1xuXHQgICAgfTtcblx0ICAgIGNhc2UgMjogcmV0dXJuIGZ1bmN0aW9uIChhLCBiKSB7XG5cdCAgICAgIHJldHVybiBmbi5jYWxsKHRoYXQsIGEsIGIpO1xuXHQgICAgfTtcblx0ICAgIGNhc2UgMzogcmV0dXJuIGZ1bmN0aW9uIChhLCBiLCBjKSB7XG5cdCAgICAgIHJldHVybiBmbi5jYWxsKHRoYXQsIGEsIGIsIGMpO1xuXHQgICAgfTtcblx0ICB9XG5cdCAgcmV0dXJuIGZ1bmN0aW9uICgvKiAuLi5hcmdzICovKSB7XG5cdCAgICByZXR1cm4gZm4uYXBwbHkodGhhdCwgYXJndW1lbnRzKTtcblx0ICB9O1xuXHR9O1xuXG5cdHZhciBUT19TVFJJTkdfVEFHID0gd2VsbEtub3duU3ltYm9sKCd0b1N0cmluZ1RhZycpO1xuXHQvLyBFUzMgd3JvbmcgaGVyZVxuXHR2YXIgQ09SUkVDVF9BUkdVTUVOVFMgPSBjbGFzc29mUmF3KGZ1bmN0aW9uICgpIHsgcmV0dXJuIGFyZ3VtZW50czsgfSgpKSA9PSAnQXJndW1lbnRzJztcblxuXHQvLyBmYWxsYmFjayBmb3IgSUUxMSBTY3JpcHQgQWNjZXNzIERlbmllZCBlcnJvclxuXHR2YXIgdHJ5R2V0ID0gZnVuY3Rpb24gKGl0LCBrZXkpIHtcblx0ICB0cnkge1xuXHQgICAgcmV0dXJuIGl0W2tleV07XG5cdCAgfSBjYXRjaCAoZXJyb3IpIHsgLyogZW1wdHkgKi8gfVxuXHR9O1xuXG5cdC8vIGdldHRpbmcgdGFnIGZyb20gRVM2KyBgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZ2Bcblx0dmFyIGNsYXNzb2YgPSBmdW5jdGlvbiAoaXQpIHtcblx0ICB2YXIgTywgdGFnLCByZXN1bHQ7XG5cdCAgcmV0dXJuIGl0ID09PSB1bmRlZmluZWQgPyAnVW5kZWZpbmVkJyA6IGl0ID09PSBudWxsID8gJ051bGwnXG5cdCAgICAvLyBAQHRvU3RyaW5nVGFnIGNhc2Vcblx0ICAgIDogdHlwZW9mICh0YWcgPSB0cnlHZXQoTyA9IE9iamVjdChpdCksIFRPX1NUUklOR19UQUcpKSA9PSAnc3RyaW5nJyA/IHRhZ1xuXHQgICAgLy8gYnVpbHRpblRhZyBjYXNlXG5cdCAgICA6IENPUlJFQ1RfQVJHVU1FTlRTID8gY2xhc3NvZlJhdyhPKVxuXHQgICAgLy8gRVMzIGFyZ3VtZW50cyBmYWxsYmFja1xuXHQgICAgOiAocmVzdWx0ID0gY2xhc3NvZlJhdyhPKSkgPT0gJ09iamVjdCcgJiYgdHlwZW9mIE8uY2FsbGVlID09ICdmdW5jdGlvbicgPyAnQXJndW1lbnRzJyA6IHJlc3VsdDtcblx0fTtcblxuXHR2YXIgSVRFUkFUT1IkMSA9IHdlbGxLbm93blN5bWJvbCgnaXRlcmF0b3InKTtcblxuXHR2YXIgZ2V0SXRlcmF0b3JNZXRob2QgPSBmdW5jdGlvbiAoaXQpIHtcblx0ICBpZiAoaXQgIT0gdW5kZWZpbmVkKSByZXR1cm4gaXRbSVRFUkFUT1IkMV1cblx0ICAgIHx8IGl0WydAQGl0ZXJhdG9yJ11cblx0ICAgIHx8IGl0ZXJhdG9yc1tjbGFzc29mKGl0KV07XG5cdH07XG5cblx0Ly8gY2FsbCBzb21ldGhpbmcgb24gaXRlcmF0b3Igc3RlcCB3aXRoIHNhZmUgY2xvc2luZyBvbiBlcnJvclxuXHR2YXIgY2FsbFdpdGhTYWZlSXRlcmF0aW9uQ2xvc2luZyA9IGZ1bmN0aW9uIChpdGVyYXRvciwgZm4sIHZhbHVlLCBFTlRSSUVTKSB7XG5cdCAgdHJ5IHtcblx0ICAgIHJldHVybiBFTlRSSUVTID8gZm4oYW5PYmplY3QodmFsdWUpWzBdLCB2YWx1ZVsxXSkgOiBmbih2YWx1ZSk7XG5cdCAgLy8gNy40LjYgSXRlcmF0b3JDbG9zZShpdGVyYXRvciwgY29tcGxldGlvbilcblx0ICB9IGNhdGNoIChlcnJvcikge1xuXHQgICAgdmFyIHJldHVybk1ldGhvZCA9IGl0ZXJhdG9yWydyZXR1cm4nXTtcblx0ICAgIGlmIChyZXR1cm5NZXRob2QgIT09IHVuZGVmaW5lZCkgYW5PYmplY3QocmV0dXJuTWV0aG9kLmNhbGwoaXRlcmF0b3IpKTtcblx0ICAgIHRocm93IGVycm9yO1xuXHQgIH1cblx0fTtcblxuXHR2YXIgaXRlcmF0ZV8xID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSkge1xuXHR2YXIgUmVzdWx0ID0gZnVuY3Rpb24gKHN0b3BwZWQsIHJlc3VsdCkge1xuXHQgIHRoaXMuc3RvcHBlZCA9IHN0b3BwZWQ7XG5cdCAgdGhpcy5yZXN1bHQgPSByZXN1bHQ7XG5cdH07XG5cblx0dmFyIGl0ZXJhdGUgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdGVyYWJsZSwgZm4sIHRoYXQsIEFTX0VOVFJJRVMsIElTX0lURVJBVE9SKSB7XG5cdCAgdmFyIGJvdW5kRnVuY3Rpb24gPSBiaW5kQ29udGV4dChmbiwgdGhhdCwgQVNfRU5UUklFUyA/IDIgOiAxKTtcblx0ICB2YXIgaXRlcmF0b3IsIGl0ZXJGbiwgaW5kZXgsIGxlbmd0aCwgcmVzdWx0LCBzdGVwO1xuXG5cdCAgaWYgKElTX0lURVJBVE9SKSB7XG5cdCAgICBpdGVyYXRvciA9IGl0ZXJhYmxlO1xuXHQgIH0gZWxzZSB7XG5cdCAgICBpdGVyRm4gPSBnZXRJdGVyYXRvck1ldGhvZChpdGVyYWJsZSk7XG5cdCAgICBpZiAodHlwZW9mIGl0ZXJGbiAhPSAnZnVuY3Rpb24nKSB0aHJvdyBUeXBlRXJyb3IoJ1RhcmdldCBpcyBub3QgaXRlcmFibGUnKTtcblx0ICAgIC8vIG9wdGltaXNhdGlvbiBmb3IgYXJyYXkgaXRlcmF0b3JzXG5cdCAgICBpZiAoaXNBcnJheUl0ZXJhdG9yTWV0aG9kKGl0ZXJGbikpIHtcblx0ICAgICAgZm9yIChpbmRleCA9IDAsIGxlbmd0aCA9IHRvTGVuZ3RoKGl0ZXJhYmxlLmxlbmd0aCk7IGxlbmd0aCA+IGluZGV4OyBpbmRleCsrKSB7XG5cdCAgICAgICAgcmVzdWx0ID0gQVNfRU5UUklFU1xuXHQgICAgICAgICAgPyBib3VuZEZ1bmN0aW9uKGFuT2JqZWN0KHN0ZXAgPSBpdGVyYWJsZVtpbmRleF0pWzBdLCBzdGVwWzFdKVxuXHQgICAgICAgICAgOiBib3VuZEZ1bmN0aW9uKGl0ZXJhYmxlW2luZGV4XSk7XG5cdCAgICAgICAgaWYgKHJlc3VsdCAmJiByZXN1bHQgaW5zdGFuY2VvZiBSZXN1bHQpIHJldHVybiByZXN1bHQ7XG5cdCAgICAgIH0gcmV0dXJuIG5ldyBSZXN1bHQoZmFsc2UpO1xuXHQgICAgfVxuXHQgICAgaXRlcmF0b3IgPSBpdGVyRm4uY2FsbChpdGVyYWJsZSk7XG5cdCAgfVxuXG5cdCAgd2hpbGUgKCEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xuXHQgICAgcmVzdWx0ID0gY2FsbFdpdGhTYWZlSXRlcmF0aW9uQ2xvc2luZyhpdGVyYXRvciwgYm91bmRGdW5jdGlvbiwgc3RlcC52YWx1ZSwgQVNfRU5UUklFUyk7XG5cdCAgICBpZiAocmVzdWx0ICYmIHJlc3VsdCBpbnN0YW5jZW9mIFJlc3VsdCkgcmV0dXJuIHJlc3VsdDtcblx0ICB9IHJldHVybiBuZXcgUmVzdWx0KGZhbHNlKTtcblx0fTtcblxuXHRpdGVyYXRlLnN0b3AgPSBmdW5jdGlvbiAocmVzdWx0KSB7XG5cdCAgcmV0dXJuIG5ldyBSZXN1bHQodHJ1ZSwgcmVzdWx0KTtcblx0fTtcblx0fSk7XG5cblx0dmFyIGFuSW5zdGFuY2UgPSBmdW5jdGlvbiAoaXQsIENvbnN0cnVjdG9yLCBuYW1lKSB7XG5cdCAgaWYgKCEoaXQgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHtcblx0ICAgIHRocm93IFR5cGVFcnJvcignSW5jb3JyZWN0ICcgKyAobmFtZSA/IG5hbWUgKyAnICcgOiAnJykgKyAnaW52b2NhdGlvbicpO1xuXHQgIH0gcmV0dXJuIGl0O1xuXHR9O1xuXG5cdHZhciBJVEVSQVRPUiQyID0gd2VsbEtub3duU3ltYm9sKCdpdGVyYXRvcicpO1xuXHR2YXIgU0FGRV9DTE9TSU5HID0gZmFsc2U7XG5cblx0dHJ5IHtcblx0ICB2YXIgY2FsbGVkID0gMDtcblx0ICB2YXIgaXRlcmF0b3JXaXRoUmV0dXJuID0ge1xuXHQgICAgbmV4dDogZnVuY3Rpb24gKCkge1xuXHQgICAgICByZXR1cm4geyBkb25lOiAhIWNhbGxlZCsrIH07XG5cdCAgICB9LFxuXHQgICAgJ3JldHVybic6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgU0FGRV9DTE9TSU5HID0gdHJ1ZTtcblx0ICAgIH1cblx0ICB9O1xuXHQgIGl0ZXJhdG9yV2l0aFJldHVybltJVEVSQVRPUiQyXSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgIHJldHVybiB0aGlzO1xuXHQgIH07XG5cdCAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXRocm93LWxpdGVyYWxcblx0ICBBcnJheS5mcm9tKGl0ZXJhdG9yV2l0aFJldHVybiwgZnVuY3Rpb24gKCkgeyB0aHJvdyAyOyB9KTtcblx0fSBjYXRjaCAoZXJyb3IpIHsgLyogZW1wdHkgKi8gfVxuXG5cdHZhciBjaGVja0NvcnJlY3RuZXNzT2ZJdGVyYXRpb24gPSBmdW5jdGlvbiAoZXhlYywgU0tJUF9DTE9TSU5HKSB7XG5cdCAgaWYgKCFTS0lQX0NMT1NJTkcgJiYgIVNBRkVfQ0xPU0lORykgcmV0dXJuIGZhbHNlO1xuXHQgIHZhciBJVEVSQVRJT05fU1VQUE9SVCA9IGZhbHNlO1xuXHQgIHRyeSB7XG5cdCAgICB2YXIgb2JqZWN0ID0ge307XG5cdCAgICBvYmplY3RbSVRFUkFUT1IkMl0gPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgIHJldHVybiB7XG5cdCAgICAgICAgbmV4dDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgcmV0dXJuIHsgZG9uZTogSVRFUkFUSU9OX1NVUFBPUlQgPSB0cnVlIH07XG5cdCAgICAgICAgfVxuXHQgICAgICB9O1xuXHQgICAgfTtcblx0ICAgIGV4ZWMob2JqZWN0KTtcblx0ICB9IGNhdGNoIChlcnJvcikgeyAvKiBlbXB0eSAqLyB9XG5cdCAgcmV0dXJuIElURVJBVElPTl9TVVBQT1JUO1xuXHR9O1xuXG5cdHZhciBkZWZpbmVQcm9wZXJ0eSA9IG9iamVjdERlZmluZVByb3BlcnR5LmY7XG5cblxuXG5cdHZhciBUT19TVFJJTkdfVEFHJDEgPSB3ZWxsS25vd25TeW1ib2woJ3RvU3RyaW5nVGFnJyk7XG5cblx0dmFyIHNldFRvU3RyaW5nVGFnID0gZnVuY3Rpb24gKGl0LCBUQUcsIFNUQVRJQykge1xuXHQgIGlmIChpdCAmJiAhaGFzKGl0ID0gU1RBVElDID8gaXQgOiBpdC5wcm90b3R5cGUsIFRPX1NUUklOR19UQUckMSkpIHtcblx0ICAgIGRlZmluZVByb3BlcnR5KGl0LCBUT19TVFJJTkdfVEFHJDEsIHsgY29uZmlndXJhYmxlOiB0cnVlLCB2YWx1ZTogVEFHIH0pO1xuXHQgIH1cblx0fTtcblxuXHR2YXIgYVBvc3NpYmxlUHJvdG90eXBlID0gZnVuY3Rpb24gKGl0KSB7XG5cdCAgaWYgKCFpc09iamVjdChpdCkgJiYgaXQgIT09IG51bGwpIHtcblx0ICAgIHRocm93IFR5cGVFcnJvcihcIkNhbid0IHNldCBcIiArIFN0cmluZyhpdCkgKyAnIGFzIGEgcHJvdG90eXBlJyk7XG5cdCAgfSByZXR1cm4gaXQ7XG5cdH07XG5cblx0Ly8gYE9iamVjdC5zZXRQcm90b3R5cGVPZmAgbWV0aG9kXG5cdC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLW9iamVjdC5zZXRwcm90b3R5cGVvZlxuXHQvLyBXb3JrcyB3aXRoIF9fcHJvdG9fXyBvbmx5LiBPbGQgdjggY2FuJ3Qgd29yayB3aXRoIG51bGwgcHJvdG8gb2JqZWN0cy5cblx0LyogZXNsaW50LWRpc2FibGUgbm8tcHJvdG8gKi9cblx0dmFyIG9iamVjdFNldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8ICgnX19wcm90b19fJyBpbiB7fSA/IGZ1bmN0aW9uICgpIHtcblx0ICB2YXIgQ09SUkVDVF9TRVRURVIgPSBmYWxzZTtcblx0ICB2YXIgdGVzdCA9IHt9O1xuXHQgIHZhciBzZXR0ZXI7XG5cdCAgdHJ5IHtcblx0ICAgIHNldHRlciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoT2JqZWN0LnByb3RvdHlwZSwgJ19fcHJvdG9fXycpLnNldDtcblx0ICAgIHNldHRlci5jYWxsKHRlc3QsIFtdKTtcblx0ICAgIENPUlJFQ1RfU0VUVEVSID0gdGVzdCBpbnN0YW5jZW9mIEFycmF5O1xuXHQgIH0gY2F0Y2ggKGVycm9yKSB7IC8qIGVtcHR5ICovIH1cblx0ICByZXR1cm4gZnVuY3Rpb24gc2V0UHJvdG90eXBlT2YoTywgcHJvdG8pIHtcblx0ICAgIGFuT2JqZWN0KE8pO1xuXHQgICAgYVBvc3NpYmxlUHJvdG90eXBlKHByb3RvKTtcblx0ICAgIGlmIChDT1JSRUNUX1NFVFRFUikgc2V0dGVyLmNhbGwoTywgcHJvdG8pO1xuXHQgICAgZWxzZSBPLl9fcHJvdG9fXyA9IHByb3RvO1xuXHQgICAgcmV0dXJuIE87XG5cdCAgfTtcblx0fSgpIDogdW5kZWZpbmVkKTtcblxuXHQvLyBtYWtlcyBzdWJjbGFzc2luZyB3b3JrIGNvcnJlY3QgZm9yIHdyYXBwZWQgYnVpbHQtaW5zXG5cdHZhciBpbmhlcml0SWZSZXF1aXJlZCA9IGZ1bmN0aW9uICgkdGhpcywgZHVtbXksIFdyYXBwZXIpIHtcblx0ICB2YXIgTmV3VGFyZ2V0LCBOZXdUYXJnZXRQcm90b3R5cGU7XG5cdCAgaWYgKFxuXHQgICAgLy8gaXQgY2FuIHdvcmsgb25seSB3aXRoIG5hdGl2ZSBgc2V0UHJvdG90eXBlT2ZgXG5cdCAgICBvYmplY3RTZXRQcm90b3R5cGVPZiAmJlxuXHQgICAgLy8gd2UgaGF2ZW4ndCBjb21wbGV0ZWx5IGNvcnJlY3QgcHJlLUVTNiB3YXkgZm9yIGdldHRpbmcgYG5ldy50YXJnZXRgLCBzbyB1c2UgdGhpc1xuXHQgICAgdHlwZW9mIChOZXdUYXJnZXQgPSBkdW1teS5jb25zdHJ1Y3RvcikgPT0gJ2Z1bmN0aW9uJyAmJlxuXHQgICAgTmV3VGFyZ2V0ICE9PSBXcmFwcGVyICYmXG5cdCAgICBpc09iamVjdChOZXdUYXJnZXRQcm90b3R5cGUgPSBOZXdUYXJnZXQucHJvdG90eXBlKSAmJlxuXHQgICAgTmV3VGFyZ2V0UHJvdG90eXBlICE9PSBXcmFwcGVyLnByb3RvdHlwZVxuXHQgICkgb2JqZWN0U2V0UHJvdG90eXBlT2YoJHRoaXMsIE5ld1RhcmdldFByb3RvdHlwZSk7XG5cdCAgcmV0dXJuICR0aGlzO1xuXHR9O1xuXG5cdHZhciBjb2xsZWN0aW9uID0gZnVuY3Rpb24gKENPTlNUUlVDVE9SX05BTUUsIHdyYXBwZXIsIGNvbW1vbiwgSVNfTUFQLCBJU19XRUFLKSB7XG5cdCAgdmFyIE5hdGl2ZUNvbnN0cnVjdG9yID0gZ2xvYmFsXzFbQ09OU1RSVUNUT1JfTkFNRV07XG5cdCAgdmFyIE5hdGl2ZVByb3RvdHlwZSA9IE5hdGl2ZUNvbnN0cnVjdG9yICYmIE5hdGl2ZUNvbnN0cnVjdG9yLnByb3RvdHlwZTtcblx0ICB2YXIgQ29uc3RydWN0b3IgPSBOYXRpdmVDb25zdHJ1Y3Rvcjtcblx0ICB2YXIgQURERVIgPSBJU19NQVAgPyAnc2V0JyA6ICdhZGQnO1xuXHQgIHZhciBleHBvcnRlZCA9IHt9O1xuXG5cdCAgdmFyIGZpeE1ldGhvZCA9IGZ1bmN0aW9uIChLRVkpIHtcblx0ICAgIHZhciBuYXRpdmVNZXRob2QgPSBOYXRpdmVQcm90b3R5cGVbS0VZXTtcblx0ICAgIHJlZGVmaW5lKE5hdGl2ZVByb3RvdHlwZSwgS0VZLFxuXHQgICAgICBLRVkgPT0gJ2FkZCcgPyBmdW5jdGlvbiBhZGQodmFsdWUpIHtcblx0ICAgICAgICBuYXRpdmVNZXRob2QuY2FsbCh0aGlzLCB2YWx1ZSA9PT0gMCA/IDAgOiB2YWx1ZSk7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICAgIH0gOiBLRVkgPT0gJ2RlbGV0ZScgPyBmdW5jdGlvbiAoa2V5KSB7XG5cdCAgICAgICAgcmV0dXJuIElTX1dFQUsgJiYgIWlzT2JqZWN0KGtleSkgPyBmYWxzZSA6IG5hdGl2ZU1ldGhvZC5jYWxsKHRoaXMsIGtleSA9PT0gMCA/IDAgOiBrZXkpO1xuXHQgICAgICB9IDogS0VZID09ICdnZXQnID8gZnVuY3Rpb24gZ2V0KGtleSkge1xuXHQgICAgICAgIHJldHVybiBJU19XRUFLICYmICFpc09iamVjdChrZXkpID8gdW5kZWZpbmVkIDogbmF0aXZlTWV0aG9kLmNhbGwodGhpcywga2V5ID09PSAwID8gMCA6IGtleSk7XG5cdCAgICAgIH0gOiBLRVkgPT0gJ2hhcycgPyBmdW5jdGlvbiBoYXMoa2V5KSB7XG5cdCAgICAgICAgcmV0dXJuIElTX1dFQUsgJiYgIWlzT2JqZWN0KGtleSkgPyBmYWxzZSA6IG5hdGl2ZU1ldGhvZC5jYWxsKHRoaXMsIGtleSA9PT0gMCA/IDAgOiBrZXkpO1xuXHQgICAgICB9IDogZnVuY3Rpb24gc2V0KGtleSwgdmFsdWUpIHtcblx0ICAgICAgICBuYXRpdmVNZXRob2QuY2FsbCh0aGlzLCBrZXkgPT09IDAgPyAwIDoga2V5LCB2YWx1ZSk7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICAgIH1cblx0ICAgICk7XG5cdCAgfTtcblxuXHQgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBtYXgtbGVuXG5cdCAgaWYgKGlzRm9yY2VkXzEoQ09OU1RSVUNUT1JfTkFNRSwgdHlwZW9mIE5hdGl2ZUNvbnN0cnVjdG9yICE9ICdmdW5jdGlvbicgfHwgIShJU19XRUFLIHx8IE5hdGl2ZVByb3RvdHlwZS5mb3JFYWNoICYmICFmYWlscyhmdW5jdGlvbiAoKSB7XG5cdCAgICBuZXcgTmF0aXZlQ29uc3RydWN0b3IoKS5lbnRyaWVzKCkubmV4dCgpO1xuXHQgIH0pKSkpIHtcblx0ICAgIC8vIGNyZWF0ZSBjb2xsZWN0aW9uIGNvbnN0cnVjdG9yXG5cdCAgICBDb25zdHJ1Y3RvciA9IGNvbW1vbi5nZXRDb25zdHJ1Y3Rvcih3cmFwcGVyLCBDT05TVFJVQ1RPUl9OQU1FLCBJU19NQVAsIEFEREVSKTtcblx0ICAgIGludGVybmFsTWV0YWRhdGEuUkVRVUlSRUQgPSB0cnVlO1xuXHQgIH0gZWxzZSBpZiAoaXNGb3JjZWRfMShDT05TVFJVQ1RPUl9OQU1FLCB0cnVlKSkge1xuXHQgICAgdmFyIGluc3RhbmNlID0gbmV3IENvbnN0cnVjdG9yKCk7XG5cdCAgICAvLyBlYXJseSBpbXBsZW1lbnRhdGlvbnMgbm90IHN1cHBvcnRzIGNoYWluaW5nXG5cdCAgICB2YXIgSEFTTlRfQ0hBSU5JTkcgPSBpbnN0YW5jZVtBRERFUl0oSVNfV0VBSyA/IHt9IDogLTAsIDEpICE9IGluc3RhbmNlO1xuXHQgICAgLy8gVjggfiBDaHJvbWl1bSA0MC0gd2Vhay1jb2xsZWN0aW9ucyB0aHJvd3Mgb24gcHJpbWl0aXZlcywgYnV0IHNob3VsZCByZXR1cm4gZmFsc2Vcblx0ICAgIHZhciBUSFJPV1NfT05fUFJJTUlUSVZFUyA9IGZhaWxzKGZ1bmN0aW9uICgpIHsgaW5zdGFuY2UuaGFzKDEpOyB9KTtcblx0ICAgIC8vIG1vc3QgZWFybHkgaW1wbGVtZW50YXRpb25zIGRvZXNuJ3Qgc3VwcG9ydHMgaXRlcmFibGVzLCBtb3N0IG1vZGVybiAtIG5vdCBjbG9zZSBpdCBjb3JyZWN0bHlcblx0ICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1uZXdcblx0ICAgIHZhciBBQ0NFUFRfSVRFUkFCTEVTID0gY2hlY2tDb3JyZWN0bmVzc09mSXRlcmF0aW9uKGZ1bmN0aW9uIChpdGVyYWJsZSkgeyBuZXcgTmF0aXZlQ29uc3RydWN0b3IoaXRlcmFibGUpOyB9KTtcblx0ICAgIC8vIGZvciBlYXJseSBpbXBsZW1lbnRhdGlvbnMgLTAgYW5kICswIG5vdCB0aGUgc2FtZVxuXHQgICAgdmFyIEJVR0dZX1pFUk8gPSAhSVNfV0VBSyAmJiBmYWlscyhmdW5jdGlvbiAoKSB7XG5cdCAgICAgIC8vIFY4IH4gQ2hyb21pdW0gNDItIGZhaWxzIG9ubHkgd2l0aCA1KyBlbGVtZW50c1xuXHQgICAgICB2YXIgJGluc3RhbmNlID0gbmV3IE5hdGl2ZUNvbnN0cnVjdG9yKCk7XG5cdCAgICAgIHZhciBpbmRleCA9IDU7XG5cdCAgICAgIHdoaWxlIChpbmRleC0tKSAkaW5zdGFuY2VbQURERVJdKGluZGV4LCBpbmRleCk7XG5cdCAgICAgIHJldHVybiAhJGluc3RhbmNlLmhhcygtMCk7XG5cdCAgICB9KTtcblxuXHQgICAgaWYgKCFBQ0NFUFRfSVRFUkFCTEVTKSB7XG5cdCAgICAgIENvbnN0cnVjdG9yID0gd3JhcHBlcihmdW5jdGlvbiAoZHVtbXksIGl0ZXJhYmxlKSB7XG5cdCAgICAgICAgYW5JbnN0YW5jZShkdW1teSwgQ29uc3RydWN0b3IsIENPTlNUUlVDVE9SX05BTUUpO1xuXHQgICAgICAgIHZhciB0aGF0ID0gaW5oZXJpdElmUmVxdWlyZWQobmV3IE5hdGl2ZUNvbnN0cnVjdG9yKCksIGR1bW15LCBDb25zdHJ1Y3Rvcik7XG5cdCAgICAgICAgaWYgKGl0ZXJhYmxlICE9IHVuZGVmaW5lZCkgaXRlcmF0ZV8xKGl0ZXJhYmxlLCB0aGF0W0FEREVSXSwgdGhhdCwgSVNfTUFQKTtcblx0ICAgICAgICByZXR1cm4gdGhhdDtcblx0ICAgICAgfSk7XG5cdCAgICAgIENvbnN0cnVjdG9yLnByb3RvdHlwZSA9IE5hdGl2ZVByb3RvdHlwZTtcblx0ICAgICAgTmF0aXZlUHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQ29uc3RydWN0b3I7XG5cdCAgICB9XG5cblx0ICAgIGlmIChUSFJPV1NfT05fUFJJTUlUSVZFUyB8fCBCVUdHWV9aRVJPKSB7XG5cdCAgICAgIGZpeE1ldGhvZCgnZGVsZXRlJyk7XG5cdCAgICAgIGZpeE1ldGhvZCgnaGFzJyk7XG5cdCAgICAgIElTX01BUCAmJiBmaXhNZXRob2QoJ2dldCcpO1xuXHQgICAgfVxuXG5cdCAgICBpZiAoQlVHR1lfWkVSTyB8fCBIQVNOVF9DSEFJTklORykgZml4TWV0aG9kKEFEREVSKTtcblxuXHQgICAgLy8gd2VhayBjb2xsZWN0aW9ucyBzaG91bGQgbm90IGNvbnRhaW5zIC5jbGVhciBtZXRob2Rcblx0ICAgIGlmIChJU19XRUFLICYmIE5hdGl2ZVByb3RvdHlwZS5jbGVhcikgZGVsZXRlIE5hdGl2ZVByb3RvdHlwZS5jbGVhcjtcblx0ICB9XG5cblx0ICBleHBvcnRlZFtDT05TVFJVQ1RPUl9OQU1FXSA9IENvbnN0cnVjdG9yO1xuXHQgIF9leHBvcnQoeyBnbG9iYWw6IHRydWUsIGZvcmNlZDogQ29uc3RydWN0b3IgIT0gTmF0aXZlQ29uc3RydWN0b3IgfSwgZXhwb3J0ZWQpO1xuXG5cdCAgc2V0VG9TdHJpbmdUYWcoQ29uc3RydWN0b3IsIENPTlNUUlVDVE9SX05BTUUpO1xuXG5cdCAgaWYgKCFJU19XRUFLKSBjb21tb24uc2V0U3Ryb25nKENvbnN0cnVjdG9yLCBDT05TVFJVQ1RPUl9OQU1FLCBJU19NQVApO1xuXG5cdCAgcmV0dXJuIENvbnN0cnVjdG9yO1xuXHR9O1xuXG5cdC8vIGBPYmplY3Qua2V5c2AgbWV0aG9kXG5cdC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLW9iamVjdC5rZXlzXG5cdHZhciBvYmplY3RLZXlzID0gT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24ga2V5cyhPKSB7XG5cdCAgcmV0dXJuIG9iamVjdEtleXNJbnRlcm5hbChPLCBlbnVtQnVnS2V5cyk7XG5cdH07XG5cblx0Ly8gYE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzYCBtZXRob2Rcblx0Ly8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtb2JqZWN0LmRlZmluZXByb3BlcnRpZXNcblx0dmFyIG9iamVjdERlZmluZVByb3BlcnRpZXMgPSBkZXNjcmlwdG9ycyA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzIDogZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyhPLCBQcm9wZXJ0aWVzKSB7XG5cdCAgYW5PYmplY3QoTyk7XG5cdCAgdmFyIGtleXMgPSBvYmplY3RLZXlzKFByb3BlcnRpZXMpO1xuXHQgIHZhciBsZW5ndGggPSBrZXlzLmxlbmd0aDtcblx0ICB2YXIgaW5kZXggPSAwO1xuXHQgIHZhciBrZXk7XG5cdCAgd2hpbGUgKGxlbmd0aCA+IGluZGV4KSBvYmplY3REZWZpbmVQcm9wZXJ0eS5mKE8sIGtleSA9IGtleXNbaW5kZXgrK10sIFByb3BlcnRpZXNba2V5XSk7XG5cdCAgcmV0dXJuIE87XG5cdH07XG5cblx0dmFyIGh0bWwgPSBnZXRCdWlsdEluKCdkb2N1bWVudCcsICdkb2N1bWVudEVsZW1lbnQnKTtcblxuXHR2YXIgSUVfUFJPVE8gPSBzaGFyZWRLZXkoJ0lFX1BST1RPJyk7XG5cblx0dmFyIFBST1RPVFlQRSA9ICdwcm90b3R5cGUnO1xuXHR2YXIgRW1wdHkgPSBmdW5jdGlvbiAoKSB7IC8qIGVtcHR5ICovIH07XG5cblx0Ly8gQ3JlYXRlIG9iamVjdCB3aXRoIGZha2UgYG51bGxgIHByb3RvdHlwZTogdXNlIGlmcmFtZSBPYmplY3Qgd2l0aCBjbGVhcmVkIHByb3RvdHlwZVxuXHR2YXIgY3JlYXRlRGljdCA9IGZ1bmN0aW9uICgpIHtcblx0ICAvLyBUaHJhc2gsIHdhc3RlIGFuZCBzb2RvbXk6IElFIEdDIGJ1Z1xuXHQgIHZhciBpZnJhbWUgPSBkb2N1bWVudENyZWF0ZUVsZW1lbnQoJ2lmcmFtZScpO1xuXHQgIHZhciBsZW5ndGggPSBlbnVtQnVnS2V5cy5sZW5ndGg7XG5cdCAgdmFyIGx0ID0gJzwnO1xuXHQgIHZhciBzY3JpcHQgPSAnc2NyaXB0Jztcblx0ICB2YXIgZ3QgPSAnPic7XG5cdCAgdmFyIGpzID0gJ2phdmEnICsgc2NyaXB0ICsgJzonO1xuXHQgIHZhciBpZnJhbWVEb2N1bWVudDtcblx0ICBpZnJhbWUuc3R5bGUuZGlzcGxheSA9ICdub25lJztcblx0ICBodG1sLmFwcGVuZENoaWxkKGlmcmFtZSk7XG5cdCAgaWZyYW1lLnNyYyA9IFN0cmluZyhqcyk7XG5cdCAgaWZyYW1lRG9jdW1lbnQgPSBpZnJhbWUuY29udGVudFdpbmRvdy5kb2N1bWVudDtcblx0ICBpZnJhbWVEb2N1bWVudC5vcGVuKCk7XG5cdCAgaWZyYW1lRG9jdW1lbnQud3JpdGUobHQgKyBzY3JpcHQgKyBndCArICdkb2N1bWVudC5GPU9iamVjdCcgKyBsdCArICcvJyArIHNjcmlwdCArIGd0KTtcblx0ICBpZnJhbWVEb2N1bWVudC5jbG9zZSgpO1xuXHQgIGNyZWF0ZURpY3QgPSBpZnJhbWVEb2N1bWVudC5GO1xuXHQgIHdoaWxlIChsZW5ndGgtLSkgZGVsZXRlIGNyZWF0ZURpY3RbUFJPVE9UWVBFXVtlbnVtQnVnS2V5c1tsZW5ndGhdXTtcblx0ICByZXR1cm4gY3JlYXRlRGljdCgpO1xuXHR9O1xuXG5cdC8vIGBPYmplY3QuY3JlYXRlYCBtZXRob2Rcblx0Ly8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtb2JqZWN0LmNyZWF0ZVxuXHR2YXIgb2JqZWN0Q3JlYXRlID0gT2JqZWN0LmNyZWF0ZSB8fCBmdW5jdGlvbiBjcmVhdGUoTywgUHJvcGVydGllcykge1xuXHQgIHZhciByZXN1bHQ7XG5cdCAgaWYgKE8gIT09IG51bGwpIHtcblx0ICAgIEVtcHR5W1BST1RPVFlQRV0gPSBhbk9iamVjdChPKTtcblx0ICAgIHJlc3VsdCA9IG5ldyBFbXB0eSgpO1xuXHQgICAgRW1wdHlbUFJPVE9UWVBFXSA9IG51bGw7XG5cdCAgICAvLyBhZGQgXCJfX3Byb3RvX19cIiBmb3IgT2JqZWN0LmdldFByb3RvdHlwZU9mIHBvbHlmaWxsXG5cdCAgICByZXN1bHRbSUVfUFJPVE9dID0gTztcblx0ICB9IGVsc2UgcmVzdWx0ID0gY3JlYXRlRGljdCgpO1xuXHQgIHJldHVybiBQcm9wZXJ0aWVzID09PSB1bmRlZmluZWQgPyByZXN1bHQgOiBvYmplY3REZWZpbmVQcm9wZXJ0aWVzKHJlc3VsdCwgUHJvcGVydGllcyk7XG5cdH07XG5cblx0aGlkZGVuS2V5c1tJRV9QUk9UT10gPSB0cnVlO1xuXG5cdHZhciByZWRlZmluZUFsbCA9IGZ1bmN0aW9uICh0YXJnZXQsIHNyYywgb3B0aW9ucykge1xuXHQgIGZvciAodmFyIGtleSBpbiBzcmMpIHJlZGVmaW5lKHRhcmdldCwga2V5LCBzcmNba2V5XSwgb3B0aW9ucyk7XG5cdCAgcmV0dXJuIHRhcmdldDtcblx0fTtcblxuXHQvLyBgVG9PYmplY3RgIGFic3RyYWN0IG9wZXJhdGlvblxuXHQvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy10b29iamVjdFxuXHR2YXIgdG9PYmplY3QgPSBmdW5jdGlvbiAoYXJndW1lbnQpIHtcblx0ICByZXR1cm4gT2JqZWN0KHJlcXVpcmVPYmplY3RDb2VyY2libGUoYXJndW1lbnQpKTtcblx0fTtcblxuXHR2YXIgY29ycmVjdFByb3RvdHlwZUdldHRlciA9ICFmYWlscyhmdW5jdGlvbiAoKSB7XG5cdCAgZnVuY3Rpb24gRigpIHsgLyogZW1wdHkgKi8gfVxuXHQgIEYucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gbnVsbDtcblx0ICByZXR1cm4gT2JqZWN0LmdldFByb3RvdHlwZU9mKG5ldyBGKCkpICE9PSBGLnByb3RvdHlwZTtcblx0fSk7XG5cblx0dmFyIElFX1BST1RPJDEgPSBzaGFyZWRLZXkoJ0lFX1BST1RPJyk7XG5cdHZhciBPYmplY3RQcm90b3R5cGUgPSBPYmplY3QucHJvdG90eXBlO1xuXG5cdC8vIGBPYmplY3QuZ2V0UHJvdG90eXBlT2ZgIG1ldGhvZFxuXHQvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1vYmplY3QuZ2V0cHJvdG90eXBlb2Zcblx0dmFyIG9iamVjdEdldFByb3RvdHlwZU9mID0gY29ycmVjdFByb3RvdHlwZUdldHRlciA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIChPKSB7XG5cdCAgTyA9IHRvT2JqZWN0KE8pO1xuXHQgIGlmIChoYXMoTywgSUVfUFJPVE8kMSkpIHJldHVybiBPW0lFX1BST1RPJDFdO1xuXHQgIGlmICh0eXBlb2YgTy5jb25zdHJ1Y3RvciA9PSAnZnVuY3Rpb24nICYmIE8gaW5zdGFuY2VvZiBPLmNvbnN0cnVjdG9yKSB7XG5cdCAgICByZXR1cm4gTy5jb25zdHJ1Y3Rvci5wcm90b3R5cGU7XG5cdCAgfSByZXR1cm4gTyBpbnN0YW5jZW9mIE9iamVjdCA/IE9iamVjdFByb3RvdHlwZSA6IG51bGw7XG5cdH07XG5cblx0dmFyIElURVJBVE9SJDMgPSB3ZWxsS25vd25TeW1ib2woJ2l0ZXJhdG9yJyk7XG5cdHZhciBCVUdHWV9TQUZBUklfSVRFUkFUT1JTID0gZmFsc2U7XG5cblx0dmFyIHJldHVyblRoaXMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9O1xuXG5cdC8vIGAlSXRlcmF0b3JQcm90b3R5cGUlYCBvYmplY3Rcblx0Ly8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtJWl0ZXJhdG9ycHJvdG90eXBlJS1vYmplY3Rcblx0dmFyIEl0ZXJhdG9yUHJvdG90eXBlLCBQcm90b3R5cGVPZkFycmF5SXRlcmF0b3JQcm90b3R5cGUsIGFycmF5SXRlcmF0b3I7XG5cblx0aWYgKFtdLmtleXMpIHtcblx0ICBhcnJheUl0ZXJhdG9yID0gW10ua2V5cygpO1xuXHQgIC8vIFNhZmFyaSA4IGhhcyBidWdneSBpdGVyYXRvcnMgdy9vIGBuZXh0YFxuXHQgIGlmICghKCduZXh0JyBpbiBhcnJheUl0ZXJhdG9yKSkgQlVHR1lfU0FGQVJJX0lURVJBVE9SUyA9IHRydWU7XG5cdCAgZWxzZSB7XG5cdCAgICBQcm90b3R5cGVPZkFycmF5SXRlcmF0b3JQcm90b3R5cGUgPSBvYmplY3RHZXRQcm90b3R5cGVPZihvYmplY3RHZXRQcm90b3R5cGVPZihhcnJheUl0ZXJhdG9yKSk7XG5cdCAgICBpZiAoUHJvdG90eXBlT2ZBcnJheUl0ZXJhdG9yUHJvdG90eXBlICE9PSBPYmplY3QucHJvdG90eXBlKSBJdGVyYXRvclByb3RvdHlwZSA9IFByb3RvdHlwZU9mQXJyYXlJdGVyYXRvclByb3RvdHlwZTtcblx0ICB9XG5cdH1cblxuXHRpZiAoSXRlcmF0b3JQcm90b3R5cGUgPT0gdW5kZWZpbmVkKSBJdGVyYXRvclByb3RvdHlwZSA9IHt9O1xuXG5cdC8vIDI1LjEuMi4xLjEgJUl0ZXJhdG9yUHJvdG90eXBlJVtAQGl0ZXJhdG9yXSgpXG5cdGlmICggIWhhcyhJdGVyYXRvclByb3RvdHlwZSwgSVRFUkFUT1IkMykpIGhpZGUoSXRlcmF0b3JQcm90b3R5cGUsIElURVJBVE9SJDMsIHJldHVyblRoaXMpO1xuXG5cdHZhciBpdGVyYXRvcnNDb3JlID0ge1xuXHQgIEl0ZXJhdG9yUHJvdG90eXBlOiBJdGVyYXRvclByb3RvdHlwZSxcblx0ICBCVUdHWV9TQUZBUklfSVRFUkFUT1JTOiBCVUdHWV9TQUZBUklfSVRFUkFUT1JTXG5cdH07XG5cblx0dmFyIEl0ZXJhdG9yUHJvdG90eXBlJDEgPSBpdGVyYXRvcnNDb3JlLkl0ZXJhdG9yUHJvdG90eXBlO1xuXG5cblxuXG5cblx0dmFyIHJldHVyblRoaXMkMSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH07XG5cblx0dmFyIGNyZWF0ZUl0ZXJhdG9yQ29uc3RydWN0b3IgPSBmdW5jdGlvbiAoSXRlcmF0b3JDb25zdHJ1Y3RvciwgTkFNRSwgbmV4dCkge1xuXHQgIHZhciBUT19TVFJJTkdfVEFHID0gTkFNRSArICcgSXRlcmF0b3InO1xuXHQgIEl0ZXJhdG9yQ29uc3RydWN0b3IucHJvdG90eXBlID0gb2JqZWN0Q3JlYXRlKEl0ZXJhdG9yUHJvdG90eXBlJDEsIHsgbmV4dDogY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yKDEsIG5leHQpIH0pO1xuXHQgIHNldFRvU3RyaW5nVGFnKEl0ZXJhdG9yQ29uc3RydWN0b3IsIFRPX1NUUklOR19UQUcsIGZhbHNlKTtcblx0ICBpdGVyYXRvcnNbVE9fU1RSSU5HX1RBR10gPSByZXR1cm5UaGlzJDE7XG5cdCAgcmV0dXJuIEl0ZXJhdG9yQ29uc3RydWN0b3I7XG5cdH07XG5cblx0dmFyIEl0ZXJhdG9yUHJvdG90eXBlJDIgPSBpdGVyYXRvcnNDb3JlLkl0ZXJhdG9yUHJvdG90eXBlO1xuXHR2YXIgQlVHR1lfU0FGQVJJX0lURVJBVE9SUyQxID0gaXRlcmF0b3JzQ29yZS5CVUdHWV9TQUZBUklfSVRFUkFUT1JTO1xuXHR2YXIgSVRFUkFUT1IkNCA9IHdlbGxLbm93blN5bWJvbCgnaXRlcmF0b3InKTtcblx0dmFyIEtFWVMgPSAna2V5cyc7XG5cdHZhciBWQUxVRVMgPSAndmFsdWVzJztcblx0dmFyIEVOVFJJRVMgPSAnZW50cmllcyc7XG5cblx0dmFyIHJldHVyblRoaXMkMiA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH07XG5cblx0dmFyIGRlZmluZUl0ZXJhdG9yID0gZnVuY3Rpb24gKEl0ZXJhYmxlLCBOQU1FLCBJdGVyYXRvckNvbnN0cnVjdG9yLCBuZXh0LCBERUZBVUxULCBJU19TRVQsIEZPUkNFRCkge1xuXHQgIGNyZWF0ZUl0ZXJhdG9yQ29uc3RydWN0b3IoSXRlcmF0b3JDb25zdHJ1Y3RvciwgTkFNRSwgbmV4dCk7XG5cblx0ICB2YXIgZ2V0SXRlcmF0aW9uTWV0aG9kID0gZnVuY3Rpb24gKEtJTkQpIHtcblx0ICAgIGlmIChLSU5EID09PSBERUZBVUxUICYmIGRlZmF1bHRJdGVyYXRvcikgcmV0dXJuIGRlZmF1bHRJdGVyYXRvcjtcblx0ICAgIGlmICghQlVHR1lfU0FGQVJJX0lURVJBVE9SUyQxICYmIEtJTkQgaW4gSXRlcmFibGVQcm90b3R5cGUpIHJldHVybiBJdGVyYWJsZVByb3RvdHlwZVtLSU5EXTtcblx0ICAgIHN3aXRjaCAoS0lORCkge1xuXHQgICAgICBjYXNlIEtFWVM6IHJldHVybiBmdW5jdGlvbiBrZXlzKCkgeyByZXR1cm4gbmV3IEl0ZXJhdG9yQ29uc3RydWN0b3IodGhpcywgS0lORCk7IH07XG5cdCAgICAgIGNhc2UgVkFMVUVTOiByZXR1cm4gZnVuY3Rpb24gdmFsdWVzKCkgeyByZXR1cm4gbmV3IEl0ZXJhdG9yQ29uc3RydWN0b3IodGhpcywgS0lORCk7IH07XG5cdCAgICAgIGNhc2UgRU5UUklFUzogcmV0dXJuIGZ1bmN0aW9uIGVudHJpZXMoKSB7IHJldHVybiBuZXcgSXRlcmF0b3JDb25zdHJ1Y3Rvcih0aGlzLCBLSU5EKTsgfTtcblx0ICAgIH0gcmV0dXJuIGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5ldyBJdGVyYXRvckNvbnN0cnVjdG9yKHRoaXMpOyB9O1xuXHQgIH07XG5cblx0ICB2YXIgVE9fU1RSSU5HX1RBRyA9IE5BTUUgKyAnIEl0ZXJhdG9yJztcblx0ICB2YXIgSU5DT1JSRUNUX1ZBTFVFU19OQU1FID0gZmFsc2U7XG5cdCAgdmFyIEl0ZXJhYmxlUHJvdG90eXBlID0gSXRlcmFibGUucHJvdG90eXBlO1xuXHQgIHZhciBuYXRpdmVJdGVyYXRvciA9IEl0ZXJhYmxlUHJvdG90eXBlW0lURVJBVE9SJDRdXG5cdCAgICB8fCBJdGVyYWJsZVByb3RvdHlwZVsnQEBpdGVyYXRvciddXG5cdCAgICB8fCBERUZBVUxUICYmIEl0ZXJhYmxlUHJvdG90eXBlW0RFRkFVTFRdO1xuXHQgIHZhciBkZWZhdWx0SXRlcmF0b3IgPSAhQlVHR1lfU0FGQVJJX0lURVJBVE9SUyQxICYmIG5hdGl2ZUl0ZXJhdG9yIHx8IGdldEl0ZXJhdGlvbk1ldGhvZChERUZBVUxUKTtcblx0ICB2YXIgYW55TmF0aXZlSXRlcmF0b3IgPSBOQU1FID09ICdBcnJheScgPyBJdGVyYWJsZVByb3RvdHlwZS5lbnRyaWVzIHx8IG5hdGl2ZUl0ZXJhdG9yIDogbmF0aXZlSXRlcmF0b3I7XG5cdCAgdmFyIEN1cnJlbnRJdGVyYXRvclByb3RvdHlwZSwgbWV0aG9kcywgS0VZO1xuXG5cdCAgLy8gZml4IG5hdGl2ZVxuXHQgIGlmIChhbnlOYXRpdmVJdGVyYXRvcikge1xuXHQgICAgQ3VycmVudEl0ZXJhdG9yUHJvdG90eXBlID0gb2JqZWN0R2V0UHJvdG90eXBlT2YoYW55TmF0aXZlSXRlcmF0b3IuY2FsbChuZXcgSXRlcmFibGUoKSkpO1xuXHQgICAgaWYgKEl0ZXJhdG9yUHJvdG90eXBlJDIgIT09IE9iamVjdC5wcm90b3R5cGUgJiYgQ3VycmVudEl0ZXJhdG9yUHJvdG90eXBlLm5leHQpIHtcblx0ICAgICAgaWYgKCBvYmplY3RHZXRQcm90b3R5cGVPZihDdXJyZW50SXRlcmF0b3JQcm90b3R5cGUpICE9PSBJdGVyYXRvclByb3RvdHlwZSQyKSB7XG5cdCAgICAgICAgaWYgKG9iamVjdFNldFByb3RvdHlwZU9mKSB7XG5cdCAgICAgICAgICBvYmplY3RTZXRQcm90b3R5cGVPZihDdXJyZW50SXRlcmF0b3JQcm90b3R5cGUsIEl0ZXJhdG9yUHJvdG90eXBlJDIpO1xuXHQgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIEN1cnJlbnRJdGVyYXRvclByb3RvdHlwZVtJVEVSQVRPUiQ0XSAhPSAnZnVuY3Rpb24nKSB7XG5cdCAgICAgICAgICBoaWRlKEN1cnJlbnRJdGVyYXRvclByb3RvdHlwZSwgSVRFUkFUT1IkNCwgcmV0dXJuVGhpcyQyKTtcblx0ICAgICAgICB9XG5cdCAgICAgIH1cblx0ICAgICAgLy8gU2V0IEBAdG9TdHJpbmdUYWcgdG8gbmF0aXZlIGl0ZXJhdG9yc1xuXHQgICAgICBzZXRUb1N0cmluZ1RhZyhDdXJyZW50SXRlcmF0b3JQcm90b3R5cGUsIFRPX1NUUklOR19UQUcsIHRydWUpO1xuXHQgICAgfVxuXHQgIH1cblxuXHQgIC8vIGZpeCBBcnJheSN7dmFsdWVzLCBAQGl0ZXJhdG9yfS5uYW1lIGluIFY4IC8gRkZcblx0ICBpZiAoREVGQVVMVCA9PSBWQUxVRVMgJiYgbmF0aXZlSXRlcmF0b3IgJiYgbmF0aXZlSXRlcmF0b3IubmFtZSAhPT0gVkFMVUVTKSB7XG5cdCAgICBJTkNPUlJFQ1RfVkFMVUVTX05BTUUgPSB0cnVlO1xuXHQgICAgZGVmYXVsdEl0ZXJhdG9yID0gZnVuY3Rpb24gdmFsdWVzKCkgeyByZXR1cm4gbmF0aXZlSXRlcmF0b3IuY2FsbCh0aGlzKTsgfTtcblx0ICB9XG5cblx0ICAvLyBkZWZpbmUgaXRlcmF0b3Jcblx0ICBpZiAoIEl0ZXJhYmxlUHJvdG90eXBlW0lURVJBVE9SJDRdICE9PSBkZWZhdWx0SXRlcmF0b3IpIHtcblx0ICAgIGhpZGUoSXRlcmFibGVQcm90b3R5cGUsIElURVJBVE9SJDQsIGRlZmF1bHRJdGVyYXRvcik7XG5cdCAgfVxuXHQgIGl0ZXJhdG9yc1tOQU1FXSA9IGRlZmF1bHRJdGVyYXRvcjtcblxuXHQgIC8vIGV4cG9ydCBhZGRpdGlvbmFsIG1ldGhvZHNcblx0ICBpZiAoREVGQVVMVCkge1xuXHQgICAgbWV0aG9kcyA9IHtcblx0ICAgICAgdmFsdWVzOiBnZXRJdGVyYXRpb25NZXRob2QoVkFMVUVTKSxcblx0ICAgICAga2V5czogSVNfU0VUID8gZGVmYXVsdEl0ZXJhdG9yIDogZ2V0SXRlcmF0aW9uTWV0aG9kKEtFWVMpLFxuXHQgICAgICBlbnRyaWVzOiBnZXRJdGVyYXRpb25NZXRob2QoRU5UUklFUylcblx0ICAgIH07XG5cdCAgICBpZiAoRk9SQ0VEKSBmb3IgKEtFWSBpbiBtZXRob2RzKSB7XG5cdCAgICAgIGlmIChCVUdHWV9TQUZBUklfSVRFUkFUT1JTJDEgfHwgSU5DT1JSRUNUX1ZBTFVFU19OQU1FIHx8ICEoS0VZIGluIEl0ZXJhYmxlUHJvdG90eXBlKSkge1xuXHQgICAgICAgIHJlZGVmaW5lKEl0ZXJhYmxlUHJvdG90eXBlLCBLRVksIG1ldGhvZHNbS0VZXSk7XG5cdCAgICAgIH1cblx0ICAgIH0gZWxzZSBfZXhwb3J0KHsgdGFyZ2V0OiBOQU1FLCBwcm90bzogdHJ1ZSwgZm9yY2VkOiBCVUdHWV9TQUZBUklfSVRFUkFUT1JTJDEgfHwgSU5DT1JSRUNUX1ZBTFVFU19OQU1FIH0sIG1ldGhvZHMpO1xuXHQgIH1cblxuXHQgIHJldHVybiBtZXRob2RzO1xuXHR9O1xuXG5cdHZhciBTUEVDSUVTID0gd2VsbEtub3duU3ltYm9sKCdzcGVjaWVzJyk7XG5cblx0dmFyIHNldFNwZWNpZXMgPSBmdW5jdGlvbiAoQ09OU1RSVUNUT1JfTkFNRSkge1xuXHQgIHZhciBDb25zdHJ1Y3RvciA9IGdldEJ1aWx0SW4oQ09OU1RSVUNUT1JfTkFNRSk7XG5cdCAgdmFyIGRlZmluZVByb3BlcnR5ID0gb2JqZWN0RGVmaW5lUHJvcGVydHkuZjtcblxuXHQgIGlmIChkZXNjcmlwdG9ycyAmJiBDb25zdHJ1Y3RvciAmJiAhQ29uc3RydWN0b3JbU1BFQ0lFU10pIHtcblx0ICAgIGRlZmluZVByb3BlcnR5KENvbnN0cnVjdG9yLCBTUEVDSUVTLCB7XG5cdCAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcblx0ICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9XG5cdCAgICB9KTtcblx0ICB9XG5cdH07XG5cblx0dmFyIGRlZmluZVByb3BlcnR5JDEgPSBvYmplY3REZWZpbmVQcm9wZXJ0eS5mO1xuXG5cblxuXG5cblxuXG5cblx0dmFyIGZhc3RLZXkgPSBpbnRlcm5hbE1ldGFkYXRhLmZhc3RLZXk7XG5cblxuXHR2YXIgc2V0SW50ZXJuYWxTdGF0ZSA9IGludGVybmFsU3RhdGUuc2V0O1xuXHR2YXIgaW50ZXJuYWxTdGF0ZUdldHRlckZvciA9IGludGVybmFsU3RhdGUuZ2V0dGVyRm9yO1xuXG5cdHZhciBjb2xsZWN0aW9uU3Ryb25nID0ge1xuXHQgIGdldENvbnN0cnVjdG9yOiBmdW5jdGlvbiAod3JhcHBlciwgQ09OU1RSVUNUT1JfTkFNRSwgSVNfTUFQLCBBRERFUikge1xuXHQgICAgdmFyIEMgPSB3cmFwcGVyKGZ1bmN0aW9uICh0aGF0LCBpdGVyYWJsZSkge1xuXHQgICAgICBhbkluc3RhbmNlKHRoYXQsIEMsIENPTlNUUlVDVE9SX05BTUUpO1xuXHQgICAgICBzZXRJbnRlcm5hbFN0YXRlKHRoYXQsIHtcblx0ICAgICAgICB0eXBlOiBDT05TVFJVQ1RPUl9OQU1FLFxuXHQgICAgICAgIGluZGV4OiBvYmplY3RDcmVhdGUobnVsbCksXG5cdCAgICAgICAgZmlyc3Q6IHVuZGVmaW5lZCxcblx0ICAgICAgICBsYXN0OiB1bmRlZmluZWQsXG5cdCAgICAgICAgc2l6ZTogMFxuXHQgICAgICB9KTtcblx0ICAgICAgaWYgKCFkZXNjcmlwdG9ycykgdGhhdC5zaXplID0gMDtcblx0ICAgICAgaWYgKGl0ZXJhYmxlICE9IHVuZGVmaW5lZCkgaXRlcmF0ZV8xKGl0ZXJhYmxlLCB0aGF0W0FEREVSXSwgdGhhdCwgSVNfTUFQKTtcblx0ICAgIH0pO1xuXG5cdCAgICB2YXIgZ2V0SW50ZXJuYWxTdGF0ZSA9IGludGVybmFsU3RhdGVHZXR0ZXJGb3IoQ09OU1RSVUNUT1JfTkFNRSk7XG5cblx0ICAgIHZhciBkZWZpbmUgPSBmdW5jdGlvbiAodGhhdCwga2V5LCB2YWx1ZSkge1xuXHQgICAgICB2YXIgc3RhdGUgPSBnZXRJbnRlcm5hbFN0YXRlKHRoYXQpO1xuXHQgICAgICB2YXIgZW50cnkgPSBnZXRFbnRyeSh0aGF0LCBrZXkpO1xuXHQgICAgICB2YXIgcHJldmlvdXMsIGluZGV4O1xuXHQgICAgICAvLyBjaGFuZ2UgZXhpc3RpbmcgZW50cnlcblx0ICAgICAgaWYgKGVudHJ5KSB7XG5cdCAgICAgICAgZW50cnkudmFsdWUgPSB2YWx1ZTtcblx0ICAgICAgLy8gY3JlYXRlIG5ldyBlbnRyeVxuXHQgICAgICB9IGVsc2Uge1xuXHQgICAgICAgIHN0YXRlLmxhc3QgPSBlbnRyeSA9IHtcblx0ICAgICAgICAgIGluZGV4OiBpbmRleCA9IGZhc3RLZXkoa2V5LCB0cnVlKSxcblx0ICAgICAgICAgIGtleToga2V5LFxuXHQgICAgICAgICAgdmFsdWU6IHZhbHVlLFxuXHQgICAgICAgICAgcHJldmlvdXM6IHByZXZpb3VzID0gc3RhdGUubGFzdCxcblx0ICAgICAgICAgIG5leHQ6IHVuZGVmaW5lZCxcblx0ICAgICAgICAgIHJlbW92ZWQ6IGZhbHNlXG5cdCAgICAgICAgfTtcblx0ICAgICAgICBpZiAoIXN0YXRlLmZpcnN0KSBzdGF0ZS5maXJzdCA9IGVudHJ5O1xuXHQgICAgICAgIGlmIChwcmV2aW91cykgcHJldmlvdXMubmV4dCA9IGVudHJ5O1xuXHQgICAgICAgIGlmIChkZXNjcmlwdG9ycykgc3RhdGUuc2l6ZSsrO1xuXHQgICAgICAgIGVsc2UgdGhhdC5zaXplKys7XG5cdCAgICAgICAgLy8gYWRkIHRvIGluZGV4XG5cdCAgICAgICAgaWYgKGluZGV4ICE9PSAnRicpIHN0YXRlLmluZGV4W2luZGV4XSA9IGVudHJ5O1xuXHQgICAgICB9IHJldHVybiB0aGF0O1xuXHQgICAgfTtcblxuXHQgICAgdmFyIGdldEVudHJ5ID0gZnVuY3Rpb24gKHRoYXQsIGtleSkge1xuXHQgICAgICB2YXIgc3RhdGUgPSBnZXRJbnRlcm5hbFN0YXRlKHRoYXQpO1xuXHQgICAgICAvLyBmYXN0IGNhc2Vcblx0ICAgICAgdmFyIGluZGV4ID0gZmFzdEtleShrZXkpO1xuXHQgICAgICB2YXIgZW50cnk7XG5cdCAgICAgIGlmIChpbmRleCAhPT0gJ0YnKSByZXR1cm4gc3RhdGUuaW5kZXhbaW5kZXhdO1xuXHQgICAgICAvLyBmcm96ZW4gb2JqZWN0IGNhc2Vcblx0ICAgICAgZm9yIChlbnRyeSA9IHN0YXRlLmZpcnN0OyBlbnRyeTsgZW50cnkgPSBlbnRyeS5uZXh0KSB7XG5cdCAgICAgICAgaWYgKGVudHJ5LmtleSA9PSBrZXkpIHJldHVybiBlbnRyeTtcblx0ICAgICAgfVxuXHQgICAgfTtcblxuXHQgICAgcmVkZWZpbmVBbGwoQy5wcm90b3R5cGUsIHtcblx0ICAgICAgLy8gMjMuMS4zLjEgTWFwLnByb3RvdHlwZS5jbGVhcigpXG5cdCAgICAgIC8vIDIzLjIuMy4yIFNldC5wcm90b3R5cGUuY2xlYXIoKVxuXHQgICAgICBjbGVhcjogZnVuY3Rpb24gY2xlYXIoKSB7XG5cdCAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuXHQgICAgICAgIHZhciBzdGF0ZSA9IGdldEludGVybmFsU3RhdGUodGhhdCk7XG5cdCAgICAgICAgdmFyIGRhdGEgPSBzdGF0ZS5pbmRleDtcblx0ICAgICAgICB2YXIgZW50cnkgPSBzdGF0ZS5maXJzdDtcblx0ICAgICAgICB3aGlsZSAoZW50cnkpIHtcblx0ICAgICAgICAgIGVudHJ5LnJlbW92ZWQgPSB0cnVlO1xuXHQgICAgICAgICAgaWYgKGVudHJ5LnByZXZpb3VzKSBlbnRyeS5wcmV2aW91cyA9IGVudHJ5LnByZXZpb3VzLm5leHQgPSB1bmRlZmluZWQ7XG5cdCAgICAgICAgICBkZWxldGUgZGF0YVtlbnRyeS5pbmRleF07XG5cdCAgICAgICAgICBlbnRyeSA9IGVudHJ5Lm5leHQ7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHN0YXRlLmZpcnN0ID0gc3RhdGUubGFzdCA9IHVuZGVmaW5lZDtcblx0ICAgICAgICBpZiAoZGVzY3JpcHRvcnMpIHN0YXRlLnNpemUgPSAwO1xuXHQgICAgICAgIGVsc2UgdGhhdC5zaXplID0gMDtcblx0ICAgICAgfSxcblx0ICAgICAgLy8gMjMuMS4zLjMgTWFwLnByb3RvdHlwZS5kZWxldGUoa2V5KVxuXHQgICAgICAvLyAyMy4yLjMuNCBTZXQucHJvdG90eXBlLmRlbGV0ZSh2YWx1ZSlcblx0ICAgICAgJ2RlbGV0ZSc6IGZ1bmN0aW9uIChrZXkpIHtcblx0ICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG5cdCAgICAgICAgdmFyIHN0YXRlID0gZ2V0SW50ZXJuYWxTdGF0ZSh0aGF0KTtcblx0ICAgICAgICB2YXIgZW50cnkgPSBnZXRFbnRyeSh0aGF0LCBrZXkpO1xuXHQgICAgICAgIGlmIChlbnRyeSkge1xuXHQgICAgICAgICAgdmFyIG5leHQgPSBlbnRyeS5uZXh0O1xuXHQgICAgICAgICAgdmFyIHByZXYgPSBlbnRyeS5wcmV2aW91cztcblx0ICAgICAgICAgIGRlbGV0ZSBzdGF0ZS5pbmRleFtlbnRyeS5pbmRleF07XG5cdCAgICAgICAgICBlbnRyeS5yZW1vdmVkID0gdHJ1ZTtcblx0ICAgICAgICAgIGlmIChwcmV2KSBwcmV2Lm5leHQgPSBuZXh0O1xuXHQgICAgICAgICAgaWYgKG5leHQpIG5leHQucHJldmlvdXMgPSBwcmV2O1xuXHQgICAgICAgICAgaWYgKHN0YXRlLmZpcnN0ID09IGVudHJ5KSBzdGF0ZS5maXJzdCA9IG5leHQ7XG5cdCAgICAgICAgICBpZiAoc3RhdGUubGFzdCA9PSBlbnRyeSkgc3RhdGUubGFzdCA9IHByZXY7XG5cdCAgICAgICAgICBpZiAoZGVzY3JpcHRvcnMpIHN0YXRlLnNpemUtLTtcblx0ICAgICAgICAgIGVsc2UgdGhhdC5zaXplLS07XG5cdCAgICAgICAgfSByZXR1cm4gISFlbnRyeTtcblx0ICAgICAgfSxcblx0ICAgICAgLy8gMjMuMi4zLjYgU2V0LnByb3RvdHlwZS5mb3JFYWNoKGNhbGxiYWNrZm4sIHRoaXNBcmcgPSB1bmRlZmluZWQpXG5cdCAgICAgIC8vIDIzLjEuMy41IE1hcC5wcm90b3R5cGUuZm9yRWFjaChjYWxsYmFja2ZuLCB0aGlzQXJnID0gdW5kZWZpbmVkKVxuXHQgICAgICBmb3JFYWNoOiBmdW5jdGlvbiBmb3JFYWNoKGNhbGxiYWNrZm4gLyogLCB0aGF0ID0gdW5kZWZpbmVkICovKSB7XG5cdCAgICAgICAgdmFyIHN0YXRlID0gZ2V0SW50ZXJuYWxTdGF0ZSh0aGlzKTtcblx0ICAgICAgICB2YXIgYm91bmRGdW5jdGlvbiA9IGJpbmRDb250ZXh0KGNhbGxiYWNrZm4sIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkLCAzKTtcblx0ICAgICAgICB2YXIgZW50cnk7XG5cdCAgICAgICAgd2hpbGUgKGVudHJ5ID0gZW50cnkgPyBlbnRyeS5uZXh0IDogc3RhdGUuZmlyc3QpIHtcblx0ICAgICAgICAgIGJvdW5kRnVuY3Rpb24oZW50cnkudmFsdWUsIGVudHJ5LmtleSwgdGhpcyk7XG5cdCAgICAgICAgICAvLyByZXZlcnQgdG8gdGhlIGxhc3QgZXhpc3RpbmcgZW50cnlcblx0ICAgICAgICAgIHdoaWxlIChlbnRyeSAmJiBlbnRyeS5yZW1vdmVkKSBlbnRyeSA9IGVudHJ5LnByZXZpb3VzO1xuXHQgICAgICAgIH1cblx0ICAgICAgfSxcblx0ICAgICAgLy8gMjMuMS4zLjcgTWFwLnByb3RvdHlwZS5oYXMoa2V5KVxuXHQgICAgICAvLyAyMy4yLjMuNyBTZXQucHJvdG90eXBlLmhhcyh2YWx1ZSlcblx0ICAgICAgaGFzOiBmdW5jdGlvbiBoYXMoa2V5KSB7XG5cdCAgICAgICAgcmV0dXJuICEhZ2V0RW50cnkodGhpcywga2V5KTtcblx0ICAgICAgfVxuXHQgICAgfSk7XG5cblx0ICAgIHJlZGVmaW5lQWxsKEMucHJvdG90eXBlLCBJU19NQVAgPyB7XG5cdCAgICAgIC8vIDIzLjEuMy42IE1hcC5wcm90b3R5cGUuZ2V0KGtleSlcblx0ICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoa2V5KSB7XG5cdCAgICAgICAgdmFyIGVudHJ5ID0gZ2V0RW50cnkodGhpcywga2V5KTtcblx0ICAgICAgICByZXR1cm4gZW50cnkgJiYgZW50cnkudmFsdWU7XG5cdCAgICAgIH0sXG5cdCAgICAgIC8vIDIzLjEuMy45IE1hcC5wcm90b3R5cGUuc2V0KGtleSwgdmFsdWUpXG5cdCAgICAgIHNldDogZnVuY3Rpb24gc2V0KGtleSwgdmFsdWUpIHtcblx0ICAgICAgICByZXR1cm4gZGVmaW5lKHRoaXMsIGtleSA9PT0gMCA/IDAgOiBrZXksIHZhbHVlKTtcblx0ICAgICAgfVxuXHQgICAgfSA6IHtcblx0ICAgICAgLy8gMjMuMi4zLjEgU2V0LnByb3RvdHlwZS5hZGQodmFsdWUpXG5cdCAgICAgIGFkZDogZnVuY3Rpb24gYWRkKHZhbHVlKSB7XG5cdCAgICAgICAgcmV0dXJuIGRlZmluZSh0aGlzLCB2YWx1ZSA9IHZhbHVlID09PSAwID8gMCA6IHZhbHVlLCB2YWx1ZSk7XG5cdCAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgaWYgKGRlc2NyaXB0b3JzKSBkZWZpbmVQcm9wZXJ0eSQxKEMucHJvdG90eXBlLCAnc2l6ZScsIHtcblx0ICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgcmV0dXJuIGdldEludGVybmFsU3RhdGUodGhpcykuc2l6ZTtcblx0ICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICByZXR1cm4gQztcblx0ICB9LFxuXHQgIHNldFN0cm9uZzogZnVuY3Rpb24gKEMsIENPTlNUUlVDVE9SX05BTUUsIElTX01BUCkge1xuXHQgICAgdmFyIElURVJBVE9SX05BTUUgPSBDT05TVFJVQ1RPUl9OQU1FICsgJyBJdGVyYXRvcic7XG5cdCAgICB2YXIgZ2V0SW50ZXJuYWxDb2xsZWN0aW9uU3RhdGUgPSBpbnRlcm5hbFN0YXRlR2V0dGVyRm9yKENPTlNUUlVDVE9SX05BTUUpO1xuXHQgICAgdmFyIGdldEludGVybmFsSXRlcmF0b3JTdGF0ZSA9IGludGVybmFsU3RhdGVHZXR0ZXJGb3IoSVRFUkFUT1JfTkFNRSk7XG5cdCAgICAvLyBhZGQgLmtleXMsIC52YWx1ZXMsIC5lbnRyaWVzLCBbQEBpdGVyYXRvcl1cblx0ICAgIC8vIDIzLjEuMy40LCAyMy4xLjMuOCwgMjMuMS4zLjExLCAyMy4xLjMuMTIsIDIzLjIuMy41LCAyMy4yLjMuOCwgMjMuMi4zLjEwLCAyMy4yLjMuMTFcblx0ICAgIGRlZmluZUl0ZXJhdG9yKEMsIENPTlNUUlVDVE9SX05BTUUsIGZ1bmN0aW9uIChpdGVyYXRlZCwga2luZCkge1xuXHQgICAgICBzZXRJbnRlcm5hbFN0YXRlKHRoaXMsIHtcblx0ICAgICAgICB0eXBlOiBJVEVSQVRPUl9OQU1FLFxuXHQgICAgICAgIHRhcmdldDogaXRlcmF0ZWQsXG5cdCAgICAgICAgc3RhdGU6IGdldEludGVybmFsQ29sbGVjdGlvblN0YXRlKGl0ZXJhdGVkKSxcblx0ICAgICAgICBraW5kOiBraW5kLFxuXHQgICAgICAgIGxhc3Q6IHVuZGVmaW5lZFxuXHQgICAgICB9KTtcblx0ICAgIH0sIGZ1bmN0aW9uICgpIHtcblx0ICAgICAgdmFyIHN0YXRlID0gZ2V0SW50ZXJuYWxJdGVyYXRvclN0YXRlKHRoaXMpO1xuXHQgICAgICB2YXIga2luZCA9IHN0YXRlLmtpbmQ7XG5cdCAgICAgIHZhciBlbnRyeSA9IHN0YXRlLmxhc3Q7XG5cdCAgICAgIC8vIHJldmVydCB0byB0aGUgbGFzdCBleGlzdGluZyBlbnRyeVxuXHQgICAgICB3aGlsZSAoZW50cnkgJiYgZW50cnkucmVtb3ZlZCkgZW50cnkgPSBlbnRyeS5wcmV2aW91cztcblx0ICAgICAgLy8gZ2V0IG5leHQgZW50cnlcblx0ICAgICAgaWYgKCFzdGF0ZS50YXJnZXQgfHwgIShzdGF0ZS5sYXN0ID0gZW50cnkgPSBlbnRyeSA/IGVudHJ5Lm5leHQgOiBzdGF0ZS5zdGF0ZS5maXJzdCkpIHtcblx0ICAgICAgICAvLyBvciBmaW5pc2ggdGhlIGl0ZXJhdGlvblxuXHQgICAgICAgIHN0YXRlLnRhcmdldCA9IHVuZGVmaW5lZDtcblx0ICAgICAgICByZXR1cm4geyB2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlIH07XG5cdCAgICAgIH1cblx0ICAgICAgLy8gcmV0dXJuIHN0ZXAgYnkga2luZFxuXHQgICAgICBpZiAoa2luZCA9PSAna2V5cycpIHJldHVybiB7IHZhbHVlOiBlbnRyeS5rZXksIGRvbmU6IGZhbHNlIH07XG5cdCAgICAgIGlmIChraW5kID09ICd2YWx1ZXMnKSByZXR1cm4geyB2YWx1ZTogZW50cnkudmFsdWUsIGRvbmU6IGZhbHNlIH07XG5cdCAgICAgIHJldHVybiB7IHZhbHVlOiBbZW50cnkua2V5LCBlbnRyeS52YWx1ZV0sIGRvbmU6IGZhbHNlIH07XG5cdCAgICB9LCBJU19NQVAgPyAnZW50cmllcycgOiAndmFsdWVzJywgIUlTX01BUCwgdHJ1ZSk7XG5cblx0ICAgIC8vIGFkZCBbQEBzcGVjaWVzXSwgMjMuMS4yLjIsIDIzLjIuMi4yXG5cdCAgICBzZXRTcGVjaWVzKENPTlNUUlVDVE9SX05BTUUpO1xuXHQgIH1cblx0fTtcblxuXHQvLyBgTWFwYCBjb25zdHJ1Y3RvclxuXHQvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1tYXAtb2JqZWN0c1xuXHR2YXIgZXNfbWFwID0gY29sbGVjdGlvbignTWFwJywgZnVuY3Rpb24gKGdldCkge1xuXHQgIHJldHVybiBmdW5jdGlvbiBNYXAoKSB7IHJldHVybiBnZXQodGhpcywgYXJndW1lbnRzLmxlbmd0aCA/IGFyZ3VtZW50c1swXSA6IHVuZGVmaW5lZCk7IH07XG5cdH0sIGNvbGxlY3Rpb25TdHJvbmcsIHRydWUpO1xuXG5cdHZhciBUT19TVFJJTkdfVEFHJDIgPSB3ZWxsS25vd25TeW1ib2woJ3RvU3RyaW5nVGFnJyk7XG5cdHZhciB0ZXN0ID0ge307XG5cblx0dGVzdFtUT19TVFJJTkdfVEFHJDJdID0gJ3onO1xuXG5cdC8vIGBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nYCBtZXRob2QgaW1wbGVtZW50YXRpb25cblx0Ly8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZ1xuXHR2YXIgb2JqZWN0VG9TdHJpbmcgPSBTdHJpbmcodGVzdCkgIT09ICdbb2JqZWN0IHpdJyA/IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuXHQgIHJldHVybiAnW29iamVjdCAnICsgY2xhc3NvZih0aGlzKSArICddJztcblx0fSA6IHRlc3QudG9TdHJpbmc7XG5cblx0dmFyIE9iamVjdFByb3RvdHlwZSQxID0gT2JqZWN0LnByb3RvdHlwZTtcblxuXHQvLyBgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZ2AgbWV0aG9kXG5cdC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmdcblx0aWYgKG9iamVjdFRvU3RyaW5nICE9PSBPYmplY3RQcm90b3R5cGUkMS50b1N0cmluZykge1xuXHQgIHJlZGVmaW5lKE9iamVjdFByb3RvdHlwZSQxLCAndG9TdHJpbmcnLCBvYmplY3RUb1N0cmluZywgeyB1bnNhZmU6IHRydWUgfSk7XG5cdH1cblxuXHQvLyBgU3RyaW5nLnByb3RvdHlwZS57IGNvZGVQb2ludEF0LCBhdCB9YCBtZXRob2RzIGltcGxlbWVudGF0aW9uXG5cdHZhciBjcmVhdGVNZXRob2QkMSA9IGZ1bmN0aW9uIChDT05WRVJUX1RPX1NUUklORykge1xuXHQgIHJldHVybiBmdW5jdGlvbiAoJHRoaXMsIHBvcykge1xuXHQgICAgdmFyIFMgPSBTdHJpbmcocmVxdWlyZU9iamVjdENvZXJjaWJsZSgkdGhpcykpO1xuXHQgICAgdmFyIHBvc2l0aW9uID0gdG9JbnRlZ2VyKHBvcyk7XG5cdCAgICB2YXIgc2l6ZSA9IFMubGVuZ3RoO1xuXHQgICAgdmFyIGZpcnN0LCBzZWNvbmQ7XG5cdCAgICBpZiAocG9zaXRpb24gPCAwIHx8IHBvc2l0aW9uID49IHNpemUpIHJldHVybiBDT05WRVJUX1RPX1NUUklORyA/ICcnIDogdW5kZWZpbmVkO1xuXHQgICAgZmlyc3QgPSBTLmNoYXJDb2RlQXQocG9zaXRpb24pO1xuXHQgICAgcmV0dXJuIGZpcnN0IDwgMHhEODAwIHx8IGZpcnN0ID4gMHhEQkZGIHx8IHBvc2l0aW9uICsgMSA9PT0gc2l6ZVxuXHQgICAgICB8fCAoc2Vjb25kID0gUy5jaGFyQ29kZUF0KHBvc2l0aW9uICsgMSkpIDwgMHhEQzAwIHx8IHNlY29uZCA+IDB4REZGRlxuXHQgICAgICAgID8gQ09OVkVSVF9UT19TVFJJTkcgPyBTLmNoYXJBdChwb3NpdGlvbikgOiBmaXJzdFxuXHQgICAgICAgIDogQ09OVkVSVF9UT19TVFJJTkcgPyBTLnNsaWNlKHBvc2l0aW9uLCBwb3NpdGlvbiArIDIpIDogKGZpcnN0IC0gMHhEODAwIDw8IDEwKSArIChzZWNvbmQgLSAweERDMDApICsgMHgxMDAwMDtcblx0ICB9O1xuXHR9O1xuXG5cdHZhciBzdHJpbmdNdWx0aWJ5dGUgPSB7XG5cdCAgLy8gYFN0cmluZy5wcm90b3R5cGUuY29kZVBvaW50QXRgIG1ldGhvZFxuXHQgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXN0cmluZy5wcm90b3R5cGUuY29kZXBvaW50YXRcblx0ICBjb2RlQXQ6IGNyZWF0ZU1ldGhvZCQxKGZhbHNlKSxcblx0ICAvLyBgU3RyaW5nLnByb3RvdHlwZS5hdGAgbWV0aG9kXG5cdCAgLy8gaHR0cHM6Ly9naXRodWIuY29tL21hdGhpYXNieW5lbnMvU3RyaW5nLnByb3RvdHlwZS5hdFxuXHQgIGNoYXJBdDogY3JlYXRlTWV0aG9kJDEodHJ1ZSlcblx0fTtcblxuXHR2YXIgY2hhckF0ID0gc3RyaW5nTXVsdGlieXRlLmNoYXJBdDtcblxuXG5cblx0dmFyIFNUUklOR19JVEVSQVRPUiA9ICdTdHJpbmcgSXRlcmF0b3InO1xuXHR2YXIgc2V0SW50ZXJuYWxTdGF0ZSQxID0gaW50ZXJuYWxTdGF0ZS5zZXQ7XG5cdHZhciBnZXRJbnRlcm5hbFN0YXRlID0gaW50ZXJuYWxTdGF0ZS5nZXR0ZXJGb3IoU1RSSU5HX0lURVJBVE9SKTtcblxuXHQvLyBgU3RyaW5nLnByb3RvdHlwZVtAQGl0ZXJhdG9yXWAgbWV0aG9kXG5cdC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXN0cmluZy5wcm90b3R5cGUtQEBpdGVyYXRvclxuXHRkZWZpbmVJdGVyYXRvcihTdHJpbmcsICdTdHJpbmcnLCBmdW5jdGlvbiAoaXRlcmF0ZWQpIHtcblx0ICBzZXRJbnRlcm5hbFN0YXRlJDEodGhpcywge1xuXHQgICAgdHlwZTogU1RSSU5HX0lURVJBVE9SLFxuXHQgICAgc3RyaW5nOiBTdHJpbmcoaXRlcmF0ZWQpLFxuXHQgICAgaW5kZXg6IDBcblx0ICB9KTtcblx0Ly8gYCVTdHJpbmdJdGVyYXRvclByb3RvdHlwZSUubmV4dGAgbWV0aG9kXG5cdC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLSVzdHJpbmdpdGVyYXRvcnByb3RvdHlwZSUubmV4dFxuXHR9LCBmdW5jdGlvbiBuZXh0KCkge1xuXHQgIHZhciBzdGF0ZSA9IGdldEludGVybmFsU3RhdGUodGhpcyk7XG5cdCAgdmFyIHN0cmluZyA9IHN0YXRlLnN0cmluZztcblx0ICB2YXIgaW5kZXggPSBzdGF0ZS5pbmRleDtcblx0ICB2YXIgcG9pbnQ7XG5cdCAgaWYgKGluZGV4ID49IHN0cmluZy5sZW5ndGgpIHJldHVybiB7IHZhbHVlOiB1bmRlZmluZWQsIGRvbmU6IHRydWUgfTtcblx0ICBwb2ludCA9IGNoYXJBdChzdHJpbmcsIGluZGV4KTtcblx0ICBzdGF0ZS5pbmRleCArPSBwb2ludC5sZW5ndGg7XG5cdCAgcmV0dXJuIHsgdmFsdWU6IHBvaW50LCBkb25lOiBmYWxzZSB9O1xuXHR9KTtcblxuXHQvLyBpdGVyYWJsZSBET00gY29sbGVjdGlvbnNcblx0Ly8gZmxhZyAtIGBpdGVyYWJsZWAgaW50ZXJmYWNlIC0gJ2VudHJpZXMnLCAna2V5cycsICd2YWx1ZXMnLCAnZm9yRWFjaCcgbWV0aG9kc1xuXHR2YXIgZG9tSXRlcmFibGVzID0ge1xuXHQgIENTU1J1bGVMaXN0OiAwLFxuXHQgIENTU1N0eWxlRGVjbGFyYXRpb246IDAsXG5cdCAgQ1NTVmFsdWVMaXN0OiAwLFxuXHQgIENsaWVudFJlY3RMaXN0OiAwLFxuXHQgIERPTVJlY3RMaXN0OiAwLFxuXHQgIERPTVN0cmluZ0xpc3Q6IDAsXG5cdCAgRE9NVG9rZW5MaXN0OiAxLFxuXHQgIERhdGFUcmFuc2Zlckl0ZW1MaXN0OiAwLFxuXHQgIEZpbGVMaXN0OiAwLFxuXHQgIEhUTUxBbGxDb2xsZWN0aW9uOiAwLFxuXHQgIEhUTUxDb2xsZWN0aW9uOiAwLFxuXHQgIEhUTUxGb3JtRWxlbWVudDogMCxcblx0ICBIVE1MU2VsZWN0RWxlbWVudDogMCxcblx0ICBNZWRpYUxpc3Q6IDAsXG5cdCAgTWltZVR5cGVBcnJheTogMCxcblx0ICBOYW1lZE5vZGVNYXA6IDAsXG5cdCAgTm9kZUxpc3Q6IDEsXG5cdCAgUGFpbnRSZXF1ZXN0TGlzdDogMCxcblx0ICBQbHVnaW46IDAsXG5cdCAgUGx1Z2luQXJyYXk6IDAsXG5cdCAgU1ZHTGVuZ3RoTGlzdDogMCxcblx0ICBTVkdOdW1iZXJMaXN0OiAwLFxuXHQgIFNWR1BhdGhTZWdMaXN0OiAwLFxuXHQgIFNWR1BvaW50TGlzdDogMCxcblx0ICBTVkdTdHJpbmdMaXN0OiAwLFxuXHQgIFNWR1RyYW5zZm9ybUxpc3Q6IDAsXG5cdCAgU291cmNlQnVmZmVyTGlzdDogMCxcblx0ICBTdHlsZVNoZWV0TGlzdDogMCxcblx0ICBUZXh0VHJhY2tDdWVMaXN0OiAwLFxuXHQgIFRleHRUcmFja0xpc3Q6IDAsXG5cdCAgVG91Y2hMaXN0OiAwXG5cdH07XG5cblx0dmFyIFVOU0NPUEFCTEVTID0gd2VsbEtub3duU3ltYm9sKCd1bnNjb3BhYmxlcycpO1xuXHR2YXIgQXJyYXlQcm90b3R5cGUkMSA9IEFycmF5LnByb3RvdHlwZTtcblxuXHQvLyBBcnJheS5wcm90b3R5cGVbQEB1bnNjb3BhYmxlc11cblx0Ly8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLUBAdW5zY29wYWJsZXNcblx0aWYgKEFycmF5UHJvdG90eXBlJDFbVU5TQ09QQUJMRVNdID09IHVuZGVmaW5lZCkge1xuXHQgIGhpZGUoQXJyYXlQcm90b3R5cGUkMSwgVU5TQ09QQUJMRVMsIG9iamVjdENyZWF0ZShudWxsKSk7XG5cdH1cblxuXHQvLyBhZGQgYSBrZXkgdG8gQXJyYXkucHJvdG90eXBlW0BAdW5zY29wYWJsZXNdXG5cdHZhciBhZGRUb1Vuc2NvcGFibGVzID0gZnVuY3Rpb24gKGtleSkge1xuXHQgIEFycmF5UHJvdG90eXBlJDFbVU5TQ09QQUJMRVNdW2tleV0gPSB0cnVlO1xuXHR9O1xuXG5cdHZhciBBUlJBWV9JVEVSQVRPUiA9ICdBcnJheSBJdGVyYXRvcic7XG5cdHZhciBzZXRJbnRlcm5hbFN0YXRlJDIgPSBpbnRlcm5hbFN0YXRlLnNldDtcblx0dmFyIGdldEludGVybmFsU3RhdGUkMSA9IGludGVybmFsU3RhdGUuZ2V0dGVyRm9yKEFSUkFZX0lURVJBVE9SKTtcblxuXHQvLyBgQXJyYXkucHJvdG90eXBlLmVudHJpZXNgIG1ldGhvZFxuXHQvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUuZW50cmllc1xuXHQvLyBgQXJyYXkucHJvdG90eXBlLmtleXNgIG1ldGhvZFxuXHQvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUua2V5c1xuXHQvLyBgQXJyYXkucHJvdG90eXBlLnZhbHVlc2AgbWV0aG9kXG5cdC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS52YWx1ZXNcblx0Ly8gYEFycmF5LnByb3RvdHlwZVtAQGl0ZXJhdG9yXWAgbWV0aG9kXG5cdC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS1AQGl0ZXJhdG9yXG5cdC8vIGBDcmVhdGVBcnJheUl0ZXJhdG9yYCBpbnRlcm5hbCBtZXRob2Rcblx0Ly8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtY3JlYXRlYXJyYXlpdGVyYXRvclxuXHR2YXIgZXNfYXJyYXlfaXRlcmF0b3IgPSBkZWZpbmVJdGVyYXRvcihBcnJheSwgJ0FycmF5JywgZnVuY3Rpb24gKGl0ZXJhdGVkLCBraW5kKSB7XG5cdCAgc2V0SW50ZXJuYWxTdGF0ZSQyKHRoaXMsIHtcblx0ICAgIHR5cGU6IEFSUkFZX0lURVJBVE9SLFxuXHQgICAgdGFyZ2V0OiB0b0luZGV4ZWRPYmplY3QoaXRlcmF0ZWQpLCAvLyB0YXJnZXRcblx0ICAgIGluZGV4OiAwLCAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbmV4dCBpbmRleFxuXHQgICAga2luZDoga2luZCAgICAgICAgICAgICAgICAgICAgICAgICAvLyBraW5kXG5cdCAgfSk7XG5cdC8vIGAlQXJyYXlJdGVyYXRvclByb3RvdHlwZSUubmV4dGAgbWV0aG9kXG5cdC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLSVhcnJheWl0ZXJhdG9ycHJvdG90eXBlJS5uZXh0XG5cdH0sIGZ1bmN0aW9uICgpIHtcblx0ICB2YXIgc3RhdGUgPSBnZXRJbnRlcm5hbFN0YXRlJDEodGhpcyk7XG5cdCAgdmFyIHRhcmdldCA9IHN0YXRlLnRhcmdldDtcblx0ICB2YXIga2luZCA9IHN0YXRlLmtpbmQ7XG5cdCAgdmFyIGluZGV4ID0gc3RhdGUuaW5kZXgrKztcblx0ICBpZiAoIXRhcmdldCB8fCBpbmRleCA+PSB0YXJnZXQubGVuZ3RoKSB7XG5cdCAgICBzdGF0ZS50YXJnZXQgPSB1bmRlZmluZWQ7XG5cdCAgICByZXR1cm4geyB2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlIH07XG5cdCAgfVxuXHQgIGlmIChraW5kID09ICdrZXlzJykgcmV0dXJuIHsgdmFsdWU6IGluZGV4LCBkb25lOiBmYWxzZSB9O1xuXHQgIGlmIChraW5kID09ICd2YWx1ZXMnKSByZXR1cm4geyB2YWx1ZTogdGFyZ2V0W2luZGV4XSwgZG9uZTogZmFsc2UgfTtcblx0ICByZXR1cm4geyB2YWx1ZTogW2luZGV4LCB0YXJnZXRbaW5kZXhdXSwgZG9uZTogZmFsc2UgfTtcblx0fSwgJ3ZhbHVlcycpO1xuXG5cdC8vIGFyZ3VtZW50c0xpc3RbQEBpdGVyYXRvcl0gaXMgJUFycmF5UHJvdG9fdmFsdWVzJVxuXHQvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1jcmVhdGV1bm1hcHBlZGFyZ3VtZW50c29iamVjdFxuXHQvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1jcmVhdGVtYXBwZWRhcmd1bWVudHNvYmplY3Rcblx0aXRlcmF0b3JzLkFyZ3VtZW50cyA9IGl0ZXJhdG9ycy5BcnJheTtcblxuXHQvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUtQEB1bnNjb3BhYmxlc1xuXHRhZGRUb1Vuc2NvcGFibGVzKCdrZXlzJyk7XG5cdGFkZFRvVW5zY29wYWJsZXMoJ3ZhbHVlcycpO1xuXHRhZGRUb1Vuc2NvcGFibGVzKCdlbnRyaWVzJyk7XG5cblx0dmFyIElURVJBVE9SJDUgPSB3ZWxsS25vd25TeW1ib2woJ2l0ZXJhdG9yJyk7XG5cdHZhciBUT19TVFJJTkdfVEFHJDMgPSB3ZWxsS25vd25TeW1ib2woJ3RvU3RyaW5nVGFnJyk7XG5cdHZhciBBcnJheVZhbHVlcyA9IGVzX2FycmF5X2l0ZXJhdG9yLnZhbHVlcztcblxuXHRmb3IgKHZhciBDT0xMRUNUSU9OX05BTUUgaW4gZG9tSXRlcmFibGVzKSB7XG5cdCAgdmFyIENvbGxlY3Rpb24gPSBnbG9iYWxfMVtDT0xMRUNUSU9OX05BTUVdO1xuXHQgIHZhciBDb2xsZWN0aW9uUHJvdG90eXBlID0gQ29sbGVjdGlvbiAmJiBDb2xsZWN0aW9uLnByb3RvdHlwZTtcblx0ICBpZiAoQ29sbGVjdGlvblByb3RvdHlwZSkge1xuXHQgICAgLy8gc29tZSBDaHJvbWUgdmVyc2lvbnMgaGF2ZSBub24tY29uZmlndXJhYmxlIG1ldGhvZHMgb24gRE9NVG9rZW5MaXN0XG5cdCAgICBpZiAoQ29sbGVjdGlvblByb3RvdHlwZVtJVEVSQVRPUiQ1XSAhPT0gQXJyYXlWYWx1ZXMpIHRyeSB7XG5cdCAgICAgIGhpZGUoQ29sbGVjdGlvblByb3RvdHlwZSwgSVRFUkFUT1IkNSwgQXJyYXlWYWx1ZXMpO1xuXHQgICAgfSBjYXRjaCAoZXJyb3IpIHtcblx0ICAgICAgQ29sbGVjdGlvblByb3RvdHlwZVtJVEVSQVRPUiQ1XSA9IEFycmF5VmFsdWVzO1xuXHQgICAgfVxuXHQgICAgaWYgKCFDb2xsZWN0aW9uUHJvdG90eXBlW1RPX1NUUklOR19UQUckM10pIGhpZGUoQ29sbGVjdGlvblByb3RvdHlwZSwgVE9fU1RSSU5HX1RBRyQzLCBDT0xMRUNUSU9OX05BTUUpO1xuXHQgICAgaWYgKGRvbUl0ZXJhYmxlc1tDT0xMRUNUSU9OX05BTUVdKSBmb3IgKHZhciBNRVRIT0RfTkFNRSBpbiBlc19hcnJheV9pdGVyYXRvcikge1xuXHQgICAgICAvLyBzb21lIENocm9tZSB2ZXJzaW9ucyBoYXZlIG5vbi1jb25maWd1cmFibGUgbWV0aG9kcyBvbiBET01Ub2tlbkxpc3Rcblx0ICAgICAgaWYgKENvbGxlY3Rpb25Qcm90b3R5cGVbTUVUSE9EX05BTUVdICE9PSBlc19hcnJheV9pdGVyYXRvcltNRVRIT0RfTkFNRV0pIHRyeSB7XG5cdCAgICAgICAgaGlkZShDb2xsZWN0aW9uUHJvdG90eXBlLCBNRVRIT0RfTkFNRSwgZXNfYXJyYXlfaXRlcmF0b3JbTUVUSE9EX05BTUVdKTtcblx0ICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcblx0ICAgICAgICBDb2xsZWN0aW9uUHJvdG90eXBlW01FVEhPRF9OQU1FXSA9IGVzX2FycmF5X2l0ZXJhdG9yW01FVEhPRF9OQU1FXTtcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgIH1cblx0fVxuXG5cdHZhciBtYXAgPSBwYXRoLk1hcDtcblxuXHQvLyBgSXNBcnJheWAgYWJzdHJhY3Qgb3BlcmF0aW9uXG5cdC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWlzYXJyYXlcblx0dmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uIGlzQXJyYXkoYXJnKSB7XG5cdCAgcmV0dXJuIGNsYXNzb2ZSYXcoYXJnKSA9PSAnQXJyYXknO1xuXHR9O1xuXG5cdHZhciBTUEVDSUVTJDEgPSB3ZWxsS25vd25TeW1ib2woJ3NwZWNpZXMnKTtcblxuXHQvLyBgQXJyYXlTcGVjaWVzQ3JlYXRlYCBhYnN0cmFjdCBvcGVyYXRpb25cblx0Ly8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtYXJyYXlzcGVjaWVzY3JlYXRlXG5cdHZhciBhcnJheVNwZWNpZXNDcmVhdGUgPSBmdW5jdGlvbiAob3JpZ2luYWxBcnJheSwgbGVuZ3RoKSB7XG5cdCAgdmFyIEM7XG5cdCAgaWYgKGlzQXJyYXkob3JpZ2luYWxBcnJheSkpIHtcblx0ICAgIEMgPSBvcmlnaW5hbEFycmF5LmNvbnN0cnVjdG9yO1xuXHQgICAgLy8gY3Jvc3MtcmVhbG0gZmFsbGJhY2tcblx0ICAgIGlmICh0eXBlb2YgQyA9PSAnZnVuY3Rpb24nICYmIChDID09PSBBcnJheSB8fCBpc0FycmF5KEMucHJvdG90eXBlKSkpIEMgPSB1bmRlZmluZWQ7XG5cdCAgICBlbHNlIGlmIChpc09iamVjdChDKSkge1xuXHQgICAgICBDID0gQ1tTUEVDSUVTJDFdO1xuXHQgICAgICBpZiAoQyA9PT0gbnVsbCkgQyA9IHVuZGVmaW5lZDtcblx0ICAgIH1cblx0ICB9IHJldHVybiBuZXcgKEMgPT09IHVuZGVmaW5lZCA/IEFycmF5IDogQykobGVuZ3RoID09PSAwID8gMCA6IGxlbmd0aCk7XG5cdH07XG5cblx0dmFyIHB1c2ggPSBbXS5wdXNoO1xuXG5cdC8vIGBBcnJheS5wcm90b3R5cGUueyBmb3JFYWNoLCBtYXAsIGZpbHRlciwgc29tZSwgZXZlcnksIGZpbmQsIGZpbmRJbmRleCB9YCBtZXRob2RzIGltcGxlbWVudGF0aW9uXG5cdHZhciBjcmVhdGVNZXRob2QkMiA9IGZ1bmN0aW9uIChUWVBFKSB7XG5cdCAgdmFyIElTX01BUCA9IFRZUEUgPT0gMTtcblx0ICB2YXIgSVNfRklMVEVSID0gVFlQRSA9PSAyO1xuXHQgIHZhciBJU19TT01FID0gVFlQRSA9PSAzO1xuXHQgIHZhciBJU19FVkVSWSA9IFRZUEUgPT0gNDtcblx0ICB2YXIgSVNfRklORF9JTkRFWCA9IFRZUEUgPT0gNjtcblx0ICB2YXIgTk9fSE9MRVMgPSBUWVBFID09IDUgfHwgSVNfRklORF9JTkRFWDtcblx0ICByZXR1cm4gZnVuY3Rpb24gKCR0aGlzLCBjYWxsYmFja2ZuLCB0aGF0LCBzcGVjaWZpY0NyZWF0ZSkge1xuXHQgICAgdmFyIE8gPSB0b09iamVjdCgkdGhpcyk7XG5cdCAgICB2YXIgc2VsZiA9IGluZGV4ZWRPYmplY3QoTyk7XG5cdCAgICB2YXIgYm91bmRGdW5jdGlvbiA9IGJpbmRDb250ZXh0KGNhbGxiYWNrZm4sIHRoYXQsIDMpO1xuXHQgICAgdmFyIGxlbmd0aCA9IHRvTGVuZ3RoKHNlbGYubGVuZ3RoKTtcblx0ICAgIHZhciBpbmRleCA9IDA7XG5cdCAgICB2YXIgY3JlYXRlID0gc3BlY2lmaWNDcmVhdGUgfHwgYXJyYXlTcGVjaWVzQ3JlYXRlO1xuXHQgICAgdmFyIHRhcmdldCA9IElTX01BUCA/IGNyZWF0ZSgkdGhpcywgbGVuZ3RoKSA6IElTX0ZJTFRFUiA/IGNyZWF0ZSgkdGhpcywgMCkgOiB1bmRlZmluZWQ7XG5cdCAgICB2YXIgdmFsdWUsIHJlc3VsdDtcblx0ICAgIGZvciAoO2xlbmd0aCA+IGluZGV4OyBpbmRleCsrKSBpZiAoTk9fSE9MRVMgfHwgaW5kZXggaW4gc2VsZikge1xuXHQgICAgICB2YWx1ZSA9IHNlbGZbaW5kZXhdO1xuXHQgICAgICByZXN1bHQgPSBib3VuZEZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgTyk7XG5cdCAgICAgIGlmIChUWVBFKSB7XG5cdCAgICAgICAgaWYgKElTX01BUCkgdGFyZ2V0W2luZGV4XSA9IHJlc3VsdDsgLy8gbWFwXG5cdCAgICAgICAgZWxzZSBpZiAocmVzdWx0KSBzd2l0Y2ggKFRZUEUpIHtcblx0ICAgICAgICAgIGNhc2UgMzogcmV0dXJuIHRydWU7ICAgICAgICAgICAgICAvLyBzb21lXG5cdCAgICAgICAgICBjYXNlIDU6IHJldHVybiB2YWx1ZTsgICAgICAgICAgICAgLy8gZmluZFxuXHQgICAgICAgICAgY2FzZSA2OiByZXR1cm4gaW5kZXg7ICAgICAgICAgICAgIC8vIGZpbmRJbmRleFxuXHQgICAgICAgICAgY2FzZSAyOiBwdXNoLmNhbGwodGFyZ2V0LCB2YWx1ZSk7IC8vIGZpbHRlclxuXHQgICAgICAgIH0gZWxzZSBpZiAoSVNfRVZFUlkpIHJldHVybiBmYWxzZTsgIC8vIGV2ZXJ5XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICAgIHJldHVybiBJU19GSU5EX0lOREVYID8gLTEgOiBJU19TT01FIHx8IElTX0VWRVJZID8gSVNfRVZFUlkgOiB0YXJnZXQ7XG5cdCAgfTtcblx0fTtcblxuXHR2YXIgYXJyYXlJdGVyYXRpb24gPSB7XG5cdCAgLy8gYEFycmF5LnByb3RvdHlwZS5mb3JFYWNoYCBtZXRob2Rcblx0ICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUuZm9yZWFjaFxuXHQgIGZvckVhY2g6IGNyZWF0ZU1ldGhvZCQyKDApLFxuXHQgIC8vIGBBcnJheS5wcm90b3R5cGUubWFwYCBtZXRob2Rcblx0ICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUubWFwXG5cdCAgbWFwOiBjcmVhdGVNZXRob2QkMigxKSxcblx0ICAvLyBgQXJyYXkucHJvdG90eXBlLmZpbHRlcmAgbWV0aG9kXG5cdCAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLmZpbHRlclxuXHQgIGZpbHRlcjogY3JlYXRlTWV0aG9kJDIoMiksXG5cdCAgLy8gYEFycmF5LnByb3RvdHlwZS5zb21lYCBtZXRob2Rcblx0ICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUuc29tZVxuXHQgIHNvbWU6IGNyZWF0ZU1ldGhvZCQyKDMpLFxuXHQgIC8vIGBBcnJheS5wcm90b3R5cGUuZXZlcnlgIG1ldGhvZFxuXHQgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5ldmVyeVxuXHQgIGV2ZXJ5OiBjcmVhdGVNZXRob2QkMig0KSxcblx0ICAvLyBgQXJyYXkucHJvdG90eXBlLmZpbmRgIG1ldGhvZFxuXHQgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5maW5kXG5cdCAgZmluZDogY3JlYXRlTWV0aG9kJDIoNSksXG5cdCAgLy8gYEFycmF5LnByb3RvdHlwZS5maW5kSW5kZXhgIG1ldGhvZFxuXHQgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5maW5kSW5kZXhcblx0ICBmaW5kSW5kZXg6IGNyZWF0ZU1ldGhvZCQyKDYpXG5cdH07XG5cblx0dmFyIGdldFdlYWtEYXRhID0gaW50ZXJuYWxNZXRhZGF0YS5nZXRXZWFrRGF0YTtcblxuXG5cblxuXG5cblxuXG5cdHZhciBzZXRJbnRlcm5hbFN0YXRlJDMgPSBpbnRlcm5hbFN0YXRlLnNldDtcblx0dmFyIGludGVybmFsU3RhdGVHZXR0ZXJGb3IkMSA9IGludGVybmFsU3RhdGUuZ2V0dGVyRm9yO1xuXHR2YXIgZmluZCA9IGFycmF5SXRlcmF0aW9uLmZpbmQ7XG5cdHZhciBmaW5kSW5kZXggPSBhcnJheUl0ZXJhdGlvbi5maW5kSW5kZXg7XG5cdHZhciBpZCQxID0gMDtcblxuXHQvLyBmYWxsYmFjayBmb3IgdW5jYXVnaHQgZnJvemVuIGtleXNcblx0dmFyIHVuY2F1Z2h0RnJvemVuU3RvcmUgPSBmdW5jdGlvbiAoc3RvcmUpIHtcblx0ICByZXR1cm4gc3RvcmUuZnJvemVuIHx8IChzdG9yZS5mcm96ZW4gPSBuZXcgVW5jYXVnaHRGcm96ZW5TdG9yZSgpKTtcblx0fTtcblxuXHR2YXIgVW5jYXVnaHRGcm96ZW5TdG9yZSA9IGZ1bmN0aW9uICgpIHtcblx0ICB0aGlzLmVudHJpZXMgPSBbXTtcblx0fTtcblxuXHR2YXIgZmluZFVuY2F1Z2h0RnJvemVuID0gZnVuY3Rpb24gKHN0b3JlLCBrZXkpIHtcblx0ICByZXR1cm4gZmluZChzdG9yZS5lbnRyaWVzLCBmdW5jdGlvbiAoaXQpIHtcblx0ICAgIHJldHVybiBpdFswXSA9PT0ga2V5O1xuXHQgIH0pO1xuXHR9O1xuXG5cdFVuY2F1Z2h0RnJvemVuU3RvcmUucHJvdG90eXBlID0ge1xuXHQgIGdldDogZnVuY3Rpb24gKGtleSkge1xuXHQgICAgdmFyIGVudHJ5ID0gZmluZFVuY2F1Z2h0RnJvemVuKHRoaXMsIGtleSk7XG5cdCAgICBpZiAoZW50cnkpIHJldHVybiBlbnRyeVsxXTtcblx0ICB9LFxuXHQgIGhhczogZnVuY3Rpb24gKGtleSkge1xuXHQgICAgcmV0dXJuICEhZmluZFVuY2F1Z2h0RnJvemVuKHRoaXMsIGtleSk7XG5cdCAgfSxcblx0ICBzZXQ6IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG5cdCAgICB2YXIgZW50cnkgPSBmaW5kVW5jYXVnaHRGcm96ZW4odGhpcywga2V5KTtcblx0ICAgIGlmIChlbnRyeSkgZW50cnlbMV0gPSB2YWx1ZTtcblx0ICAgIGVsc2UgdGhpcy5lbnRyaWVzLnB1c2goW2tleSwgdmFsdWVdKTtcblx0ICB9LFxuXHQgICdkZWxldGUnOiBmdW5jdGlvbiAoa2V5KSB7XG5cdCAgICB2YXIgaW5kZXggPSBmaW5kSW5kZXgodGhpcy5lbnRyaWVzLCBmdW5jdGlvbiAoaXQpIHtcblx0ICAgICAgcmV0dXJuIGl0WzBdID09PSBrZXk7XG5cdCAgICB9KTtcblx0ICAgIGlmICh+aW5kZXgpIHRoaXMuZW50cmllcy5zcGxpY2UoaW5kZXgsIDEpO1xuXHQgICAgcmV0dXJuICEhfmluZGV4O1xuXHQgIH1cblx0fTtcblxuXHR2YXIgY29sbGVjdGlvbldlYWsgPSB7XG5cdCAgZ2V0Q29uc3RydWN0b3I6IGZ1bmN0aW9uICh3cmFwcGVyLCBDT05TVFJVQ1RPUl9OQU1FLCBJU19NQVAsIEFEREVSKSB7XG5cdCAgICB2YXIgQyA9IHdyYXBwZXIoZnVuY3Rpb24gKHRoYXQsIGl0ZXJhYmxlKSB7XG5cdCAgICAgIGFuSW5zdGFuY2UodGhhdCwgQywgQ09OU1RSVUNUT1JfTkFNRSk7XG5cdCAgICAgIHNldEludGVybmFsU3RhdGUkMyh0aGF0LCB7XG5cdCAgICAgICAgdHlwZTogQ09OU1RSVUNUT1JfTkFNRSxcblx0ICAgICAgICBpZDogaWQkMSsrLFxuXHQgICAgICAgIGZyb3plbjogdW5kZWZpbmVkXG5cdCAgICAgIH0pO1xuXHQgICAgICBpZiAoaXRlcmFibGUgIT0gdW5kZWZpbmVkKSBpdGVyYXRlXzEoaXRlcmFibGUsIHRoYXRbQURERVJdLCB0aGF0LCBJU19NQVApO1xuXHQgICAgfSk7XG5cblx0ICAgIHZhciBnZXRJbnRlcm5hbFN0YXRlID0gaW50ZXJuYWxTdGF0ZUdldHRlckZvciQxKENPTlNUUlVDVE9SX05BTUUpO1xuXG5cdCAgICB2YXIgZGVmaW5lID0gZnVuY3Rpb24gKHRoYXQsIGtleSwgdmFsdWUpIHtcblx0ICAgICAgdmFyIHN0YXRlID0gZ2V0SW50ZXJuYWxTdGF0ZSh0aGF0KTtcblx0ICAgICAgdmFyIGRhdGEgPSBnZXRXZWFrRGF0YShhbk9iamVjdChrZXkpLCB0cnVlKTtcblx0ICAgICAgaWYgKGRhdGEgPT09IHRydWUpIHVuY2F1Z2h0RnJvemVuU3RvcmUoc3RhdGUpLnNldChrZXksIHZhbHVlKTtcblx0ICAgICAgZWxzZSBkYXRhW3N0YXRlLmlkXSA9IHZhbHVlO1xuXHQgICAgICByZXR1cm4gdGhhdDtcblx0ICAgIH07XG5cblx0ICAgIHJlZGVmaW5lQWxsKEMucHJvdG90eXBlLCB7XG5cdCAgICAgIC8vIDIzLjMuMy4yIFdlYWtNYXAucHJvdG90eXBlLmRlbGV0ZShrZXkpXG5cdCAgICAgIC8vIDIzLjQuMy4zIFdlYWtTZXQucHJvdG90eXBlLmRlbGV0ZSh2YWx1ZSlcblx0ICAgICAgJ2RlbGV0ZSc6IGZ1bmN0aW9uIChrZXkpIHtcblx0ICAgICAgICB2YXIgc3RhdGUgPSBnZXRJbnRlcm5hbFN0YXRlKHRoaXMpO1xuXHQgICAgICAgIGlmICghaXNPYmplY3Qoa2V5KSkgcmV0dXJuIGZhbHNlO1xuXHQgICAgICAgIHZhciBkYXRhID0gZ2V0V2Vha0RhdGEoa2V5KTtcblx0ICAgICAgICBpZiAoZGF0YSA9PT0gdHJ1ZSkgcmV0dXJuIHVuY2F1Z2h0RnJvemVuU3RvcmUoc3RhdGUpWydkZWxldGUnXShrZXkpO1xuXHQgICAgICAgIHJldHVybiBkYXRhICYmIGhhcyhkYXRhLCBzdGF0ZS5pZCkgJiYgZGVsZXRlIGRhdGFbc3RhdGUuaWRdO1xuXHQgICAgICB9LFxuXHQgICAgICAvLyAyMy4zLjMuNCBXZWFrTWFwLnByb3RvdHlwZS5oYXMoa2V5KVxuXHQgICAgICAvLyAyMy40LjMuNCBXZWFrU2V0LnByb3RvdHlwZS5oYXModmFsdWUpXG5cdCAgICAgIGhhczogZnVuY3Rpb24gaGFzJDEoa2V5KSB7XG5cdCAgICAgICAgdmFyIHN0YXRlID0gZ2V0SW50ZXJuYWxTdGF0ZSh0aGlzKTtcblx0ICAgICAgICBpZiAoIWlzT2JqZWN0KGtleSkpIHJldHVybiBmYWxzZTtcblx0ICAgICAgICB2YXIgZGF0YSA9IGdldFdlYWtEYXRhKGtleSk7XG5cdCAgICAgICAgaWYgKGRhdGEgPT09IHRydWUpIHJldHVybiB1bmNhdWdodEZyb3plblN0b3JlKHN0YXRlKS5oYXMoa2V5KTtcblx0ICAgICAgICByZXR1cm4gZGF0YSAmJiBoYXMoZGF0YSwgc3RhdGUuaWQpO1xuXHQgICAgICB9XG5cdCAgICB9KTtcblxuXHQgICAgcmVkZWZpbmVBbGwoQy5wcm90b3R5cGUsIElTX01BUCA/IHtcblx0ICAgICAgLy8gMjMuMy4zLjMgV2Vha01hcC5wcm90b3R5cGUuZ2V0KGtleSlcblx0ICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoa2V5KSB7XG5cdCAgICAgICAgdmFyIHN0YXRlID0gZ2V0SW50ZXJuYWxTdGF0ZSh0aGlzKTtcblx0ICAgICAgICBpZiAoaXNPYmplY3Qoa2V5KSkge1xuXHQgICAgICAgICAgdmFyIGRhdGEgPSBnZXRXZWFrRGF0YShrZXkpO1xuXHQgICAgICAgICAgaWYgKGRhdGEgPT09IHRydWUpIHJldHVybiB1bmNhdWdodEZyb3plblN0b3JlKHN0YXRlKS5nZXQoa2V5KTtcblx0ICAgICAgICAgIHJldHVybiBkYXRhID8gZGF0YVtzdGF0ZS5pZF0gOiB1bmRlZmluZWQ7XG5cdCAgICAgICAgfVxuXHQgICAgICB9LFxuXHQgICAgICAvLyAyMy4zLjMuNSBXZWFrTWFwLnByb3RvdHlwZS5zZXQoa2V5LCB2YWx1ZSlcblx0ICAgICAgc2V0OiBmdW5jdGlvbiBzZXQoa2V5LCB2YWx1ZSkge1xuXHQgICAgICAgIHJldHVybiBkZWZpbmUodGhpcywga2V5LCB2YWx1ZSk7XG5cdCAgICAgIH1cblx0ICAgIH0gOiB7XG5cdCAgICAgIC8vIDIzLjQuMy4xIFdlYWtTZXQucHJvdG90eXBlLmFkZCh2YWx1ZSlcblx0ICAgICAgYWRkOiBmdW5jdGlvbiBhZGQodmFsdWUpIHtcblx0ICAgICAgICByZXR1cm4gZGVmaW5lKHRoaXMsIHZhbHVlLCB0cnVlKTtcblx0ICAgICAgfVxuXHQgICAgfSk7XG5cblx0ICAgIHJldHVybiBDO1xuXHQgIH1cblx0fTtcblxuXHR2YXIgZXNfd2Vha01hcCA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUpIHtcblxuXG5cblxuXG5cblx0dmFyIGVuZm9yY2VJdGVybmFsU3RhdGUgPSBpbnRlcm5hbFN0YXRlLmVuZm9yY2U7XG5cblxuXHR2YXIgSVNfSUUxMSA9ICFnbG9iYWxfMS5BY3RpdmVYT2JqZWN0ICYmICdBY3RpdmVYT2JqZWN0JyBpbiBnbG9iYWxfMTtcblx0dmFyIGlzRXh0ZW5zaWJsZSA9IE9iamVjdC5pc0V4dGVuc2libGU7XG5cdHZhciBJbnRlcm5hbFdlYWtNYXA7XG5cblx0dmFyIHdyYXBwZXIgPSBmdW5jdGlvbiAoZ2V0KSB7XG5cdCAgcmV0dXJuIGZ1bmN0aW9uIFdlYWtNYXAoKSB7XG5cdCAgICByZXR1cm4gZ2V0KHRoaXMsIGFyZ3VtZW50cy5sZW5ndGggPyBhcmd1bWVudHNbMF0gOiB1bmRlZmluZWQpO1xuXHQgIH07XG5cdH07XG5cblx0Ly8gYFdlYWtNYXBgIGNvbnN0cnVjdG9yXG5cdC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXdlYWttYXAtY29uc3RydWN0b3Jcblx0dmFyICRXZWFrTWFwID0gbW9kdWxlLmV4cG9ydHMgPSBjb2xsZWN0aW9uKCdXZWFrTWFwJywgd3JhcHBlciwgY29sbGVjdGlvbldlYWssIHRydWUsIHRydWUpO1xuXG5cdC8vIElFMTEgV2Vha01hcCBmcm96ZW4ga2V5cyBmaXhcblx0Ly8gV2UgY2FuJ3QgdXNlIGZlYXR1cmUgZGV0ZWN0aW9uIGJlY2F1c2UgaXQgY3Jhc2ggc29tZSBvbGQgSUUgYnVpbGRzXG5cdC8vIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy80ODVcblx0aWYgKG5hdGl2ZVdlYWtNYXAgJiYgSVNfSUUxMSkge1xuXHQgIEludGVybmFsV2Vha01hcCA9IGNvbGxlY3Rpb25XZWFrLmdldENvbnN0cnVjdG9yKHdyYXBwZXIsICdXZWFrTWFwJywgdHJ1ZSk7XG5cdCAgaW50ZXJuYWxNZXRhZGF0YS5SRVFVSVJFRCA9IHRydWU7XG5cdCAgdmFyIFdlYWtNYXBQcm90b3R5cGUgPSAkV2Vha01hcC5wcm90b3R5cGU7XG5cdCAgdmFyIG5hdGl2ZURlbGV0ZSA9IFdlYWtNYXBQcm90b3R5cGVbJ2RlbGV0ZSddO1xuXHQgIHZhciBuYXRpdmVIYXMgPSBXZWFrTWFwUHJvdG90eXBlLmhhcztcblx0ICB2YXIgbmF0aXZlR2V0ID0gV2Vha01hcFByb3RvdHlwZS5nZXQ7XG5cdCAgdmFyIG5hdGl2ZVNldCA9IFdlYWtNYXBQcm90b3R5cGUuc2V0O1xuXHQgIHJlZGVmaW5lQWxsKFdlYWtNYXBQcm90b3R5cGUsIHtcblx0ICAgICdkZWxldGUnOiBmdW5jdGlvbiAoa2V5KSB7XG5cdCAgICAgIGlmIChpc09iamVjdChrZXkpICYmICFpc0V4dGVuc2libGUoa2V5KSkge1xuXHQgICAgICAgIHZhciBzdGF0ZSA9IGVuZm9yY2VJdGVybmFsU3RhdGUodGhpcyk7XG5cdCAgICAgICAgaWYgKCFzdGF0ZS5mcm96ZW4pIHN0YXRlLmZyb3plbiA9IG5ldyBJbnRlcm5hbFdlYWtNYXAoKTtcblx0ICAgICAgICByZXR1cm4gbmF0aXZlRGVsZXRlLmNhbGwodGhpcywga2V5KSB8fCBzdGF0ZS5mcm96ZW5bJ2RlbGV0ZSddKGtleSk7XG5cdCAgICAgIH0gcmV0dXJuIG5hdGl2ZURlbGV0ZS5jYWxsKHRoaXMsIGtleSk7XG5cdCAgICB9LFxuXHQgICAgaGFzOiBmdW5jdGlvbiBoYXMoa2V5KSB7XG5cdCAgICAgIGlmIChpc09iamVjdChrZXkpICYmICFpc0V4dGVuc2libGUoa2V5KSkge1xuXHQgICAgICAgIHZhciBzdGF0ZSA9IGVuZm9yY2VJdGVybmFsU3RhdGUodGhpcyk7XG5cdCAgICAgICAgaWYgKCFzdGF0ZS5mcm96ZW4pIHN0YXRlLmZyb3plbiA9IG5ldyBJbnRlcm5hbFdlYWtNYXAoKTtcblx0ICAgICAgICByZXR1cm4gbmF0aXZlSGFzLmNhbGwodGhpcywga2V5KSB8fCBzdGF0ZS5mcm96ZW4uaGFzKGtleSk7XG5cdCAgICAgIH0gcmV0dXJuIG5hdGl2ZUhhcy5jYWxsKHRoaXMsIGtleSk7XG5cdCAgICB9LFxuXHQgICAgZ2V0OiBmdW5jdGlvbiBnZXQoa2V5KSB7XG5cdCAgICAgIGlmIChpc09iamVjdChrZXkpICYmICFpc0V4dGVuc2libGUoa2V5KSkge1xuXHQgICAgICAgIHZhciBzdGF0ZSA9IGVuZm9yY2VJdGVybmFsU3RhdGUodGhpcyk7XG5cdCAgICAgICAgaWYgKCFzdGF0ZS5mcm96ZW4pIHN0YXRlLmZyb3plbiA9IG5ldyBJbnRlcm5hbFdlYWtNYXAoKTtcblx0ICAgICAgICByZXR1cm4gbmF0aXZlSGFzLmNhbGwodGhpcywga2V5KSA/IG5hdGl2ZUdldC5jYWxsKHRoaXMsIGtleSkgOiBzdGF0ZS5mcm96ZW4uZ2V0KGtleSk7XG5cdCAgICAgIH0gcmV0dXJuIG5hdGl2ZUdldC5jYWxsKHRoaXMsIGtleSk7XG5cdCAgICB9LFxuXHQgICAgc2V0OiBmdW5jdGlvbiBzZXQoa2V5LCB2YWx1ZSkge1xuXHQgICAgICBpZiAoaXNPYmplY3Qoa2V5KSAmJiAhaXNFeHRlbnNpYmxlKGtleSkpIHtcblx0ICAgICAgICB2YXIgc3RhdGUgPSBlbmZvcmNlSXRlcm5hbFN0YXRlKHRoaXMpO1xuXHQgICAgICAgIGlmICghc3RhdGUuZnJvemVuKSBzdGF0ZS5mcm96ZW4gPSBuZXcgSW50ZXJuYWxXZWFrTWFwKCk7XG5cdCAgICAgICAgbmF0aXZlSGFzLmNhbGwodGhpcywga2V5KSA/IG5hdGl2ZVNldC5jYWxsKHRoaXMsIGtleSwgdmFsdWUpIDogc3RhdGUuZnJvemVuLnNldChrZXksIHZhbHVlKTtcblx0ICAgICAgfSBlbHNlIG5hdGl2ZVNldC5jYWxsKHRoaXMsIGtleSwgdmFsdWUpO1xuXHQgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH1cblx0ICB9KTtcblx0fVxuXHR9KTtcblxuXHR2YXIgd2Vha01hcCA9IHBhdGguV2Vha01hcDtcblxuXHQvLyBgU2V0YCBjb25zdHJ1Y3RvclxuXHQvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1zZXQtb2JqZWN0c1xuXHR2YXIgZXNfc2V0ID0gY29sbGVjdGlvbignU2V0JywgZnVuY3Rpb24gKGdldCkge1xuXHQgIHJldHVybiBmdW5jdGlvbiBTZXQoKSB7IHJldHVybiBnZXQodGhpcywgYXJndW1lbnRzLmxlbmd0aCA/IGFyZ3VtZW50c1swXSA6IHVuZGVmaW5lZCk7IH07XG5cdH0sIGNvbGxlY3Rpb25TdHJvbmcpO1xuXG5cdHZhciBzZXQkMSA9IHBhdGguU2V0O1xuXG5cdC8vIGBXZWFrU2V0YCBjb25zdHJ1Y3RvclxuXHQvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy13ZWFrc2V0LWNvbnN0cnVjdG9yXG5cdGNvbGxlY3Rpb24oJ1dlYWtTZXQnLCBmdW5jdGlvbiAoZ2V0KSB7XG5cdCAgcmV0dXJuIGZ1bmN0aW9uIFdlYWtTZXQoKSB7IHJldHVybiBnZXQodGhpcywgYXJndW1lbnRzLmxlbmd0aCA/IGFyZ3VtZW50c1swXSA6IHVuZGVmaW5lZCk7IH07XG5cdH0sIGNvbGxlY3Rpb25XZWFrLCBmYWxzZSwgdHJ1ZSk7XG5cblx0dmFyIHdlYWtTZXQgPSBwYXRoLldlYWtTZXQ7XG5cblx0dmFyIGVzMjAxNUNvbGxlY3Rpb24gPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcblx0fSk7XG5cblx0dW53cmFwRXhwb3J0cyhlczIwMTVDb2xsZWN0aW9uKTtcblxuXHR2YXIgJGZpbmQgPSBhcnJheUl0ZXJhdGlvbi5maW5kO1xuXG5cblx0dmFyIEZJTkQgPSAnZmluZCc7XG5cdHZhciBTS0lQU19IT0xFUyA9IHRydWU7XG5cblx0Ly8gU2hvdWxkbid0IHNraXAgaG9sZXNcblx0aWYgKEZJTkQgaW4gW10pIEFycmF5KDEpW0ZJTkRdKGZ1bmN0aW9uICgpIHsgU0tJUFNfSE9MRVMgPSBmYWxzZTsgfSk7XG5cblx0Ly8gYEFycmF5LnByb3RvdHlwZS5maW5kYCBtZXRob2Rcblx0Ly8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLmZpbmRcblx0X2V4cG9ydCh7IHRhcmdldDogJ0FycmF5JywgcHJvdG86IHRydWUsIGZvcmNlZDogU0tJUFNfSE9MRVMgfSwge1xuXHQgIGZpbmQ6IGZ1bmN0aW9uIGZpbmQoY2FsbGJhY2tmbiAvKiAsIHRoYXQgPSB1bmRlZmluZWQgKi8pIHtcblx0ICAgIHJldHVybiAkZmluZCh0aGlzLCBjYWxsYmFja2ZuLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG5cdCAgfVxuXHR9KTtcblxuXHQvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUtQEB1bnNjb3BhYmxlc1xuXHRhZGRUb1Vuc2NvcGFibGVzKEZJTkQpO1xuXG5cdHZhciBjYWxsID0gRnVuY3Rpb24uY2FsbDtcblxuXHR2YXIgZW50cnlVbmJpbmQgPSBmdW5jdGlvbiAoQ09OU1RSVUNUT1IsIE1FVEhPRCwgbGVuZ3RoKSB7XG5cdCAgcmV0dXJuIGJpbmRDb250ZXh0KGNhbGwsIGdsb2JhbF8xW0NPTlNUUlVDVE9SXS5wcm90b3R5cGVbTUVUSE9EXSwgbGVuZ3RoKTtcblx0fTtcblxuXHR2YXIgZmluZCQxID0gZW50cnlVbmJpbmQoJ0FycmF5JywgJ2ZpbmQnKTtcblxuXHR2YXIgZGVmaW5lUHJvcGVydHkkMiA9IG9iamVjdERlZmluZVByb3BlcnR5LmY7XG5cblxuXG5cblxuXHR2YXIgRGF0YVZpZXcgPSBnbG9iYWxfMS5EYXRhVmlldztcblx0dmFyIERhdGFWaWV3UHJvdG90eXBlID0gRGF0YVZpZXcgJiYgRGF0YVZpZXcucHJvdG90eXBlO1xuXHR2YXIgSW50OEFycmF5JDEgPSBnbG9iYWxfMS5JbnQ4QXJyYXk7XG5cdHZhciBJbnQ4QXJyYXlQcm90b3R5cGUgPSBJbnQ4QXJyYXkkMSAmJiBJbnQ4QXJyYXkkMS5wcm90b3R5cGU7XG5cdHZhciBVaW50OENsYW1wZWRBcnJheSA9IGdsb2JhbF8xLlVpbnQ4Q2xhbXBlZEFycmF5O1xuXHR2YXIgVWludDhDbGFtcGVkQXJyYXlQcm90b3R5cGUgPSBVaW50OENsYW1wZWRBcnJheSAmJiBVaW50OENsYW1wZWRBcnJheS5wcm90b3R5cGU7XG5cdHZhciBUeXBlZEFycmF5ID0gSW50OEFycmF5JDEgJiYgb2JqZWN0R2V0UHJvdG90eXBlT2YoSW50OEFycmF5JDEpO1xuXHR2YXIgVHlwZWRBcnJheVByb3RvdHlwZSA9IEludDhBcnJheVByb3RvdHlwZSAmJiBvYmplY3RHZXRQcm90b3R5cGVPZihJbnQ4QXJyYXlQcm90b3R5cGUpO1xuXHR2YXIgT2JqZWN0UHJvdG90eXBlJDIgPSBPYmplY3QucHJvdG90eXBlO1xuXHR2YXIgaXNQcm90b3R5cGVPZiA9IE9iamVjdFByb3RvdHlwZSQyLmlzUHJvdG90eXBlT2Y7XG5cblx0dmFyIFRPX1NUUklOR19UQUckNCA9IHdlbGxLbm93blN5bWJvbCgndG9TdHJpbmdUYWcnKTtcblx0dmFyIFRZUEVEX0FSUkFZX1RBRyA9IHVpZCgnVFlQRURfQVJSQVlfVEFHJyk7XG5cdHZhciBOQVRJVkVfQVJSQVlfQlVGRkVSID0gISEoZ2xvYmFsXzEuQXJyYXlCdWZmZXIgJiYgRGF0YVZpZXcpO1xuXHQvLyBGaXhpbmcgbmF0aXZlIHR5cGVkIGFycmF5cyBpbiBPcGVyYSBQcmVzdG8gY3Jhc2hlcyB0aGUgYnJvd3Nlciwgc2VlICM1OTVcblx0dmFyIE5BVElWRV9BUlJBWV9CVUZGRVJfVklFV1MgPSBOQVRJVkVfQVJSQVlfQlVGRkVSICYmICEhb2JqZWN0U2V0UHJvdG90eXBlT2YgJiYgY2xhc3NvZihnbG9iYWxfMS5vcGVyYSkgIT09ICdPcGVyYSc7XG5cdHZhciBUWVBFRF9BUlJBWV9UQUdfUkVRSVJFRCA9IGZhbHNlO1xuXHR2YXIgTkFNRTtcblxuXHR2YXIgVHlwZWRBcnJheUNvbnN0cnVjdG9yc0xpc3QgPSB7XG5cdCAgSW50OEFycmF5OiAxLFxuXHQgIFVpbnQ4QXJyYXk6IDEsXG5cdCAgVWludDhDbGFtcGVkQXJyYXk6IDEsXG5cdCAgSW50MTZBcnJheTogMixcblx0ICBVaW50MTZBcnJheTogMixcblx0ICBJbnQzMkFycmF5OiA0LFxuXHQgIFVpbnQzMkFycmF5OiA0LFxuXHQgIEZsb2F0MzJBcnJheTogNCxcblx0ICBGbG9hdDY0QXJyYXk6IDhcblx0fTtcblxuXHR2YXIgaXNWaWV3ID0gZnVuY3Rpb24gaXNWaWV3KGl0KSB7XG5cdCAgdmFyIGtsYXNzID0gY2xhc3NvZihpdCk7XG5cdCAgcmV0dXJuIGtsYXNzID09PSAnRGF0YVZpZXcnIHx8IGhhcyhUeXBlZEFycmF5Q29uc3RydWN0b3JzTGlzdCwga2xhc3MpO1xuXHR9O1xuXG5cdHZhciBpc1R5cGVkQXJyYXkgPSBmdW5jdGlvbiAoaXQpIHtcblx0ICByZXR1cm4gaXNPYmplY3QoaXQpICYmIGhhcyhUeXBlZEFycmF5Q29uc3RydWN0b3JzTGlzdCwgY2xhc3NvZihpdCkpO1xuXHR9O1xuXG5cdHZhciBhVHlwZWRBcnJheSA9IGZ1bmN0aW9uIChpdCkge1xuXHQgIGlmIChpc1R5cGVkQXJyYXkoaXQpKSByZXR1cm4gaXQ7XG5cdCAgdGhyb3cgVHlwZUVycm9yKCdUYXJnZXQgaXMgbm90IGEgdHlwZWQgYXJyYXknKTtcblx0fTtcblxuXHR2YXIgYVR5cGVkQXJyYXlDb25zdHJ1Y3RvciA9IGZ1bmN0aW9uIChDKSB7XG5cdCAgaWYgKG9iamVjdFNldFByb3RvdHlwZU9mKSB7XG5cdCAgICBpZiAoaXNQcm90b3R5cGVPZi5jYWxsKFR5cGVkQXJyYXksIEMpKSByZXR1cm4gQztcblx0ICB9IGVsc2UgZm9yICh2YXIgQVJSQVkgaW4gVHlwZWRBcnJheUNvbnN0cnVjdG9yc0xpc3QpIGlmIChoYXMoVHlwZWRBcnJheUNvbnN0cnVjdG9yc0xpc3QsIE5BTUUpKSB7XG5cdCAgICB2YXIgVHlwZWRBcnJheUNvbnN0cnVjdG9yID0gZ2xvYmFsXzFbQVJSQVldO1xuXHQgICAgaWYgKFR5cGVkQXJyYXlDb25zdHJ1Y3RvciAmJiAoQyA9PT0gVHlwZWRBcnJheUNvbnN0cnVjdG9yIHx8IGlzUHJvdG90eXBlT2YuY2FsbChUeXBlZEFycmF5Q29uc3RydWN0b3IsIEMpKSkge1xuXHQgICAgICByZXR1cm4gQztcblx0ICAgIH1cblx0ICB9IHRocm93IFR5cGVFcnJvcignVGFyZ2V0IGlzIG5vdCBhIHR5cGVkIGFycmF5IGNvbnN0cnVjdG9yJyk7XG5cdH07XG5cblx0dmFyIGV4cG9ydFByb3RvID0gZnVuY3Rpb24gKEtFWSwgcHJvcGVydHksIGZvcmNlZCkge1xuXHQgIGlmICghZGVzY3JpcHRvcnMpIHJldHVybjtcblx0ICBpZiAoZm9yY2VkKSBmb3IgKHZhciBBUlJBWSBpbiBUeXBlZEFycmF5Q29uc3RydWN0b3JzTGlzdCkge1xuXHQgICAgdmFyIFR5cGVkQXJyYXlDb25zdHJ1Y3RvciA9IGdsb2JhbF8xW0FSUkFZXTtcblx0ICAgIGlmIChUeXBlZEFycmF5Q29uc3RydWN0b3IgJiYgaGFzKFR5cGVkQXJyYXlDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIEtFWSkpIHtcblx0ICAgICAgZGVsZXRlIFR5cGVkQXJyYXlDb25zdHJ1Y3Rvci5wcm90b3R5cGVbS0VZXTtcblx0ICAgIH1cblx0ICB9XG5cdCAgaWYgKCFUeXBlZEFycmF5UHJvdG90eXBlW0tFWV0gfHwgZm9yY2VkKSB7XG5cdCAgICByZWRlZmluZShUeXBlZEFycmF5UHJvdG90eXBlLCBLRVksIGZvcmNlZCA/IHByb3BlcnR5XG5cdCAgICAgIDogTkFUSVZFX0FSUkFZX0JVRkZFUl9WSUVXUyAmJiBJbnQ4QXJyYXlQcm90b3R5cGVbS0VZXSB8fCBwcm9wZXJ0eSk7XG5cdCAgfVxuXHR9O1xuXG5cdHZhciBleHBvcnRTdGF0aWMgPSBmdW5jdGlvbiAoS0VZLCBwcm9wZXJ0eSwgZm9yY2VkKSB7XG5cdCAgdmFyIEFSUkFZLCBUeXBlZEFycmF5Q29uc3RydWN0b3I7XG5cdCAgaWYgKCFkZXNjcmlwdG9ycykgcmV0dXJuO1xuXHQgIGlmIChvYmplY3RTZXRQcm90b3R5cGVPZikge1xuXHQgICAgaWYgKGZvcmNlZCkgZm9yIChBUlJBWSBpbiBUeXBlZEFycmF5Q29uc3RydWN0b3JzTGlzdCkge1xuXHQgICAgICBUeXBlZEFycmF5Q29uc3RydWN0b3IgPSBnbG9iYWxfMVtBUlJBWV07XG5cdCAgICAgIGlmIChUeXBlZEFycmF5Q29uc3RydWN0b3IgJiYgaGFzKFR5cGVkQXJyYXlDb25zdHJ1Y3RvciwgS0VZKSkge1xuXHQgICAgICAgIGRlbGV0ZSBUeXBlZEFycmF5Q29uc3RydWN0b3JbS0VZXTtcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgICAgaWYgKCFUeXBlZEFycmF5W0tFWV0gfHwgZm9yY2VkKSB7XG5cdCAgICAgIC8vIFY4IH4gQ2hyb21lIDQ5LTUwIGAlVHlwZWRBcnJheSVgIG1ldGhvZHMgYXJlIG5vbi13cml0YWJsZSBub24tY29uZmlndXJhYmxlXG5cdCAgICAgIHRyeSB7XG5cdCAgICAgICAgcmV0dXJuIHJlZGVmaW5lKFR5cGVkQXJyYXksIEtFWSwgZm9yY2VkID8gcHJvcGVydHkgOiBOQVRJVkVfQVJSQVlfQlVGRkVSX1ZJRVdTICYmIEludDhBcnJheSQxW0tFWV0gfHwgcHJvcGVydHkpO1xuXHQgICAgICB9IGNhdGNoIChlcnJvcikgeyAvKiBlbXB0eSAqLyB9XG5cdCAgICB9IGVsc2UgcmV0dXJuO1xuXHQgIH1cblx0ICBmb3IgKEFSUkFZIGluIFR5cGVkQXJyYXlDb25zdHJ1Y3RvcnNMaXN0KSB7XG5cdCAgICBUeXBlZEFycmF5Q29uc3RydWN0b3IgPSBnbG9iYWxfMVtBUlJBWV07XG5cdCAgICBpZiAoVHlwZWRBcnJheUNvbnN0cnVjdG9yICYmICghVHlwZWRBcnJheUNvbnN0cnVjdG9yW0tFWV0gfHwgZm9yY2VkKSkge1xuXHQgICAgICByZWRlZmluZShUeXBlZEFycmF5Q29uc3RydWN0b3IsIEtFWSwgcHJvcGVydHkpO1xuXHQgICAgfVxuXHQgIH1cblx0fTtcblxuXHRmb3IgKE5BTUUgaW4gVHlwZWRBcnJheUNvbnN0cnVjdG9yc0xpc3QpIHtcblx0ICBpZiAoIWdsb2JhbF8xW05BTUVdKSBOQVRJVkVfQVJSQVlfQlVGRkVSX1ZJRVdTID0gZmFsc2U7XG5cdH1cblxuXHQvLyBXZWJLaXQgYnVnIC0gdHlwZWQgYXJyYXlzIGNvbnN0cnVjdG9ycyBwcm90b3R5cGUgaXMgT2JqZWN0LnByb3RvdHlwZVxuXHRpZiAoIU5BVElWRV9BUlJBWV9CVUZGRVJfVklFV1MgfHwgdHlwZW9mIFR5cGVkQXJyYXkgIT0gJ2Z1bmN0aW9uJyB8fCBUeXBlZEFycmF5ID09PSBGdW5jdGlvbi5wcm90b3R5cGUpIHtcblx0ICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2hhZG93XG5cdCAgVHlwZWRBcnJheSA9IGZ1bmN0aW9uIFR5cGVkQXJyYXkoKSB7XG5cdCAgICB0aHJvdyBUeXBlRXJyb3IoJ0luY29ycmVjdCBpbnZvY2F0aW9uJyk7XG5cdCAgfTtcblx0ICBpZiAoTkFUSVZFX0FSUkFZX0JVRkZFUl9WSUVXUykgZm9yIChOQU1FIGluIFR5cGVkQXJyYXlDb25zdHJ1Y3RvcnNMaXN0KSB7XG5cdCAgICBpZiAoZ2xvYmFsXzFbTkFNRV0pIG9iamVjdFNldFByb3RvdHlwZU9mKGdsb2JhbF8xW05BTUVdLCBUeXBlZEFycmF5KTtcblx0ICB9XG5cdH1cblxuXHRpZiAoIU5BVElWRV9BUlJBWV9CVUZGRVJfVklFV1MgfHwgIVR5cGVkQXJyYXlQcm90b3R5cGUgfHwgVHlwZWRBcnJheVByb3RvdHlwZSA9PT0gT2JqZWN0UHJvdG90eXBlJDIpIHtcblx0ICBUeXBlZEFycmF5UHJvdG90eXBlID0gVHlwZWRBcnJheS5wcm90b3R5cGU7XG5cdCAgaWYgKE5BVElWRV9BUlJBWV9CVUZGRVJfVklFV1MpIGZvciAoTkFNRSBpbiBUeXBlZEFycmF5Q29uc3RydWN0b3JzTGlzdCkge1xuXHQgICAgaWYgKGdsb2JhbF8xW05BTUVdKSBvYmplY3RTZXRQcm90b3R5cGVPZihnbG9iYWxfMVtOQU1FXS5wcm90b3R5cGUsIFR5cGVkQXJyYXlQcm90b3R5cGUpO1xuXHQgIH1cblx0fVxuXG5cdC8vIFdlYktpdCBidWcgLSBvbmUgbW9yZSBvYmplY3QgaW4gVWludDhDbGFtcGVkQXJyYXkgcHJvdG90eXBlIGNoYWluXG5cdGlmIChOQVRJVkVfQVJSQVlfQlVGRkVSX1ZJRVdTICYmIG9iamVjdEdldFByb3RvdHlwZU9mKFVpbnQ4Q2xhbXBlZEFycmF5UHJvdG90eXBlKSAhPT0gVHlwZWRBcnJheVByb3RvdHlwZSkge1xuXHQgIG9iamVjdFNldFByb3RvdHlwZU9mKFVpbnQ4Q2xhbXBlZEFycmF5UHJvdG90eXBlLCBUeXBlZEFycmF5UHJvdG90eXBlKTtcblx0fVxuXG5cdGlmIChkZXNjcmlwdG9ycyAmJiAhaGFzKFR5cGVkQXJyYXlQcm90b3R5cGUsIFRPX1NUUklOR19UQUckNCkpIHtcblx0ICBUWVBFRF9BUlJBWV9UQUdfUkVRSVJFRCA9IHRydWU7XG5cdCAgZGVmaW5lUHJvcGVydHkkMihUeXBlZEFycmF5UHJvdG90eXBlLCBUT19TVFJJTkdfVEFHJDQsIHsgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICByZXR1cm4gaXNPYmplY3QodGhpcykgPyB0aGlzW1RZUEVEX0FSUkFZX1RBR10gOiB1bmRlZmluZWQ7XG5cdCAgfSB9KTtcblx0ICBmb3IgKE5BTUUgaW4gVHlwZWRBcnJheUNvbnN0cnVjdG9yc0xpc3QpIGlmIChnbG9iYWxfMVtOQU1FXSkge1xuXHQgICAgaGlkZShnbG9iYWxfMVtOQU1FXSwgVFlQRURfQVJSQVlfVEFHLCBOQU1FKTtcblx0ICB9XG5cdH1cblxuXHQvLyBXZWJLaXQgYnVnIC0gdGhlIHNhbWUgcGFyZW50IHByb3RvdHlwZSBmb3IgdHlwZWQgYXJyYXlzIGFuZCBkYXRhIHZpZXdcblx0aWYgKE5BVElWRV9BUlJBWV9CVUZGRVIgJiYgb2JqZWN0U2V0UHJvdG90eXBlT2YgJiYgb2JqZWN0R2V0UHJvdG90eXBlT2YoRGF0YVZpZXdQcm90b3R5cGUpICE9PSBPYmplY3RQcm90b3R5cGUkMikge1xuXHQgIG9iamVjdFNldFByb3RvdHlwZU9mKERhdGFWaWV3UHJvdG90eXBlLCBPYmplY3RQcm90b3R5cGUkMik7XG5cdH1cblxuXHR2YXIgYXJyYXlCdWZmZXJWaWV3Q29yZSA9IHtcblx0ICBOQVRJVkVfQVJSQVlfQlVGRkVSOiBOQVRJVkVfQVJSQVlfQlVGRkVSLFxuXHQgIE5BVElWRV9BUlJBWV9CVUZGRVJfVklFV1M6IE5BVElWRV9BUlJBWV9CVUZGRVJfVklFV1MsXG5cdCAgVFlQRURfQVJSQVlfVEFHOiBUWVBFRF9BUlJBWV9UQUdfUkVRSVJFRCAmJiBUWVBFRF9BUlJBWV9UQUcsXG5cdCAgYVR5cGVkQXJyYXk6IGFUeXBlZEFycmF5LFxuXHQgIGFUeXBlZEFycmF5Q29uc3RydWN0b3I6IGFUeXBlZEFycmF5Q29uc3RydWN0b3IsXG5cdCAgZXhwb3J0UHJvdG86IGV4cG9ydFByb3RvLFxuXHQgIGV4cG9ydFN0YXRpYzogZXhwb3J0U3RhdGljLFxuXHQgIGlzVmlldzogaXNWaWV3LFxuXHQgIGlzVHlwZWRBcnJheTogaXNUeXBlZEFycmF5LFxuXHQgIFR5cGVkQXJyYXk6IFR5cGVkQXJyYXksXG5cdCAgVHlwZWRBcnJheVByb3RvdHlwZTogVHlwZWRBcnJheVByb3RvdHlwZVxuXHR9O1xuXG5cdHZhciAkZmluZCQxID0gYXJyYXlJdGVyYXRpb24uZmluZDtcblxuXHR2YXIgYVR5cGVkQXJyYXkkMSA9IGFycmF5QnVmZmVyVmlld0NvcmUuYVR5cGVkQXJyYXk7XG5cblx0Ly8gYCVUeXBlZEFycmF5JS5wcm90b3R5cGUuZmluZGAgbWV0aG9kXG5cdC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLSV0eXBlZGFycmF5JS5wcm90b3R5cGUuZmluZFxuXHRhcnJheUJ1ZmZlclZpZXdDb3JlLmV4cG9ydFByb3RvKCdmaW5kJywgZnVuY3Rpb24gZmluZChwcmVkaWNhdGUgLyogLCB0aGlzQXJnICovKSB7XG5cdCAgcmV0dXJuICRmaW5kJDEoYVR5cGVkQXJyYXkkMSh0aGlzKSwgcHJlZGljYXRlLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG5cdH0pO1xuXG5cdHZhciAkZmluZEluZGV4ID0gYXJyYXlJdGVyYXRpb24uZmluZEluZGV4O1xuXG5cblx0dmFyIEZJTkRfSU5ERVggPSAnZmluZEluZGV4Jztcblx0dmFyIFNLSVBTX0hPTEVTJDEgPSB0cnVlO1xuXG5cdC8vIFNob3VsZG4ndCBza2lwIGhvbGVzXG5cdGlmIChGSU5EX0lOREVYIGluIFtdKSBBcnJheSgxKVtGSU5EX0lOREVYXShmdW5jdGlvbiAoKSB7IFNLSVBTX0hPTEVTJDEgPSBmYWxzZTsgfSk7XG5cblx0Ly8gYEFycmF5LnByb3RvdHlwZS5maW5kSW5kZXhgIG1ldGhvZFxuXHQvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUuZmluZGluZGV4XG5cdF9leHBvcnQoeyB0YXJnZXQ6ICdBcnJheScsIHByb3RvOiB0cnVlLCBmb3JjZWQ6IFNLSVBTX0hPTEVTJDEgfSwge1xuXHQgIGZpbmRJbmRleDogZnVuY3Rpb24gZmluZEluZGV4KGNhbGxiYWNrZm4gLyogLCB0aGF0ID0gdW5kZWZpbmVkICovKSB7XG5cdCAgICByZXR1cm4gJGZpbmRJbmRleCh0aGlzLCBjYWxsYmFja2ZuLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG5cdCAgfVxuXHR9KTtcblxuXHQvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUtQEB1bnNjb3BhYmxlc1xuXHRhZGRUb1Vuc2NvcGFibGVzKEZJTkRfSU5ERVgpO1xuXG5cdHZhciBmaW5kSW5kZXgkMSA9IGVudHJ5VW5iaW5kKCdBcnJheScsICdmaW5kSW5kZXgnKTtcblxuXHR2YXIgJGZpbmRJbmRleCQxID0gYXJyYXlJdGVyYXRpb24uZmluZEluZGV4O1xuXG5cdHZhciBhVHlwZWRBcnJheSQyID0gYXJyYXlCdWZmZXJWaWV3Q29yZS5hVHlwZWRBcnJheTtcblxuXHQvLyBgJVR5cGVkQXJyYXklLnByb3RvdHlwZS5maW5kSW5kZXhgIG1ldGhvZFxuXHQvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy0ldHlwZWRhcnJheSUucHJvdG90eXBlLmZpbmRpbmRleFxuXHRhcnJheUJ1ZmZlclZpZXdDb3JlLmV4cG9ydFByb3RvKCdmaW5kSW5kZXgnLCBmdW5jdGlvbiBmaW5kSW5kZXgocHJlZGljYXRlIC8qICwgdGhpc0FyZyAqLykge1xuXHQgIHJldHVybiAkZmluZEluZGV4JDEoYVR5cGVkQXJyYXkkMih0aGlzKSwgcHJlZGljYXRlLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG5cdH0pO1xuXG5cdC8vIGBBcnJheS5wcm90b3R5cGUuZmlsbGAgbWV0aG9kIGltcGxlbWVudGF0aW9uXG5cdC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5maWxsXG5cdHZhciBhcnJheUZpbGwgPSBmdW5jdGlvbiBmaWxsKHZhbHVlIC8qICwgc3RhcnQgPSAwLCBlbmQgPSBAbGVuZ3RoICovKSB7XG5cdCAgdmFyIE8gPSB0b09iamVjdCh0aGlzKTtcblx0ICB2YXIgbGVuZ3RoID0gdG9MZW5ndGgoTy5sZW5ndGgpO1xuXHQgIHZhciBhcmd1bWVudHNMZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoO1xuXHQgIHZhciBpbmRleCA9IHRvQWJzb2x1dGVJbmRleChhcmd1bWVudHNMZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkLCBsZW5ndGgpO1xuXHQgIHZhciBlbmQgPSBhcmd1bWVudHNMZW5ndGggPiAyID8gYXJndW1lbnRzWzJdIDogdW5kZWZpbmVkO1xuXHQgIHZhciBlbmRQb3MgPSBlbmQgPT09IHVuZGVmaW5lZCA/IGxlbmd0aCA6IHRvQWJzb2x1dGVJbmRleChlbmQsIGxlbmd0aCk7XG5cdCAgd2hpbGUgKGVuZFBvcyA+IGluZGV4KSBPW2luZGV4KytdID0gdmFsdWU7XG5cdCAgcmV0dXJuIE87XG5cdH07XG5cblx0Ly8gYEFycmF5LnByb3RvdHlwZS5maWxsYCBtZXRob2Rcblx0Ly8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLmZpbGxcblx0X2V4cG9ydCh7IHRhcmdldDogJ0FycmF5JywgcHJvdG86IHRydWUgfSwge1xuXHQgIGZpbGw6IGFycmF5RmlsbFxuXHR9KTtcblxuXHQvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUtQEB1bnNjb3BhYmxlc1xuXHRhZGRUb1Vuc2NvcGFibGVzKCdmaWxsJyk7XG5cblx0dmFyIGZpbGwgPSBlbnRyeVVuYmluZCgnQXJyYXknLCAnZmlsbCcpO1xuXG5cdHZhciBhVHlwZWRBcnJheSQzID0gYXJyYXlCdWZmZXJWaWV3Q29yZS5hVHlwZWRBcnJheTtcblxuXHQvLyBgJVR5cGVkQXJyYXklLnByb3RvdHlwZS5maWxsYCBtZXRob2Rcblx0Ly8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtJXR5cGVkYXJyYXklLnByb3RvdHlwZS5maWxsXG5cdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtdmFyc1xuXHRhcnJheUJ1ZmZlclZpZXdDb3JlLmV4cG9ydFByb3RvKCdmaWxsJywgZnVuY3Rpb24gZmlsbCh2YWx1ZSAvKiAsIHN0YXJ0LCBlbmQgKi8pIHtcblx0ICByZXR1cm4gYXJyYXlGaWxsLmFwcGx5KGFUeXBlZEFycmF5JDModGhpcyksIGFyZ3VtZW50cyk7XG5cdH0pO1xuXG5cdHZhciBtaW4kMiA9IE1hdGgubWluO1xuXG5cdC8vIGBBcnJheS5wcm90b3R5cGUuY29weVdpdGhpbmAgbWV0aG9kIGltcGxlbWVudGF0aW9uXG5cdC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5jb3B5d2l0aGluXG5cdHZhciBhcnJheUNvcHlXaXRoaW4gPSBbXS5jb3B5V2l0aGluIHx8IGZ1bmN0aW9uIGNvcHlXaXRoaW4odGFyZ2V0IC8qID0gMCAqLywgc3RhcnQgLyogPSAwLCBlbmQgPSBAbGVuZ3RoICovKSB7XG5cdCAgdmFyIE8gPSB0b09iamVjdCh0aGlzKTtcblx0ICB2YXIgbGVuID0gdG9MZW5ndGgoTy5sZW5ndGgpO1xuXHQgIHZhciB0byA9IHRvQWJzb2x1dGVJbmRleCh0YXJnZXQsIGxlbik7XG5cdCAgdmFyIGZyb20gPSB0b0Fic29sdXRlSW5kZXgoc3RhcnQsIGxlbik7XG5cdCAgdmFyIGVuZCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyID8gYXJndW1lbnRzWzJdIDogdW5kZWZpbmVkO1xuXHQgIHZhciBjb3VudCA9IG1pbiQyKChlbmQgPT09IHVuZGVmaW5lZCA/IGxlbiA6IHRvQWJzb2x1dGVJbmRleChlbmQsIGxlbikpIC0gZnJvbSwgbGVuIC0gdG8pO1xuXHQgIHZhciBpbmMgPSAxO1xuXHQgIGlmIChmcm9tIDwgdG8gJiYgdG8gPCBmcm9tICsgY291bnQpIHtcblx0ICAgIGluYyA9IC0xO1xuXHQgICAgZnJvbSArPSBjb3VudCAtIDE7XG5cdCAgICB0byArPSBjb3VudCAtIDE7XG5cdCAgfVxuXHQgIHdoaWxlIChjb3VudC0tID4gMCkge1xuXHQgICAgaWYgKGZyb20gaW4gTykgT1t0b10gPSBPW2Zyb21dO1xuXHQgICAgZWxzZSBkZWxldGUgT1t0b107XG5cdCAgICB0byArPSBpbmM7XG5cdCAgICBmcm9tICs9IGluYztcblx0ICB9IHJldHVybiBPO1xuXHR9O1xuXG5cdC8vIGBBcnJheS5wcm90b3R5cGUuY29weVdpdGhpbmAgbWV0aG9kXG5cdC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5jb3B5d2l0aGluXG5cdF9leHBvcnQoeyB0YXJnZXQ6ICdBcnJheScsIHByb3RvOiB0cnVlIH0sIHtcblx0ICBjb3B5V2l0aGluOiBhcnJheUNvcHlXaXRoaW5cblx0fSk7XG5cblx0Ly8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLUBAdW5zY29wYWJsZXNcblx0YWRkVG9VbnNjb3BhYmxlcygnY29weVdpdGhpbicpO1xuXG5cdHZhciBjb3B5V2l0aGluID0gZW50cnlVbmJpbmQoJ0FycmF5JywgJ2NvcHlXaXRoaW4nKTtcblxuXHR2YXIgYVR5cGVkQXJyYXkkNCA9IGFycmF5QnVmZmVyVmlld0NvcmUuYVR5cGVkQXJyYXk7XG5cblx0Ly8gYCVUeXBlZEFycmF5JS5wcm90b3R5cGUuY29weVdpdGhpbmAgbWV0aG9kXG5cdC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLSV0eXBlZGFycmF5JS5wcm90b3R5cGUuY29weXdpdGhpblxuXHRhcnJheUJ1ZmZlclZpZXdDb3JlLmV4cG9ydFByb3RvKCdjb3B5V2l0aGluJywgZnVuY3Rpb24gY29weVdpdGhpbih0YXJnZXQsIHN0YXJ0IC8qICwgZW5kICovKSB7XG5cdCAgcmV0dXJuIGFycmF5Q29weVdpdGhpbi5jYWxsKGFUeXBlZEFycmF5JDQodGhpcyksIHRhcmdldCwgc3RhcnQsIGFyZ3VtZW50cy5sZW5ndGggPiAyID8gYXJndW1lbnRzWzJdIDogdW5kZWZpbmVkKTtcblx0fSk7XG5cblx0dmFyIGNyZWF0ZVByb3BlcnR5ID0gZnVuY3Rpb24gKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuXHQgIHZhciBwcm9wZXJ0eUtleSA9IHRvUHJpbWl0aXZlKGtleSk7XG5cdCAgaWYgKHByb3BlcnR5S2V5IGluIG9iamVjdCkgb2JqZWN0RGVmaW5lUHJvcGVydHkuZihvYmplY3QsIHByb3BlcnR5S2V5LCBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IoMCwgdmFsdWUpKTtcblx0ICBlbHNlIG9iamVjdFtwcm9wZXJ0eUtleV0gPSB2YWx1ZTtcblx0fTtcblxuXHQvLyBgQXJyYXkuZnJvbWAgbWV0aG9kIGltcGxlbWVudGF0aW9uXG5cdC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWFycmF5LmZyb21cblx0dmFyIGFycmF5RnJvbSA9IGZ1bmN0aW9uIGZyb20oYXJyYXlMaWtlIC8qICwgbWFwZm4gPSB1bmRlZmluZWQsIHRoaXNBcmcgPSB1bmRlZmluZWQgKi8pIHtcblx0ICB2YXIgTyA9IHRvT2JqZWN0KGFycmF5TGlrZSk7XG5cdCAgdmFyIEMgPSB0eXBlb2YgdGhpcyA9PSAnZnVuY3Rpb24nID8gdGhpcyA6IEFycmF5O1xuXHQgIHZhciBhcmd1bWVudHNMZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoO1xuXHQgIHZhciBtYXBmbiA9IGFyZ3VtZW50c0xlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQ7XG5cdCAgdmFyIG1hcHBpbmcgPSBtYXBmbiAhPT0gdW5kZWZpbmVkO1xuXHQgIHZhciBpbmRleCA9IDA7XG5cdCAgdmFyIGl0ZXJhdG9yTWV0aG9kID0gZ2V0SXRlcmF0b3JNZXRob2QoTyk7XG5cdCAgdmFyIGxlbmd0aCwgcmVzdWx0LCBzdGVwLCBpdGVyYXRvcjtcblx0ICBpZiAobWFwcGluZykgbWFwZm4gPSBiaW5kQ29udGV4dChtYXBmbiwgYXJndW1lbnRzTGVuZ3RoID4gMiA/IGFyZ3VtZW50c1syXSA6IHVuZGVmaW5lZCwgMik7XG5cdCAgLy8gaWYgdGhlIHRhcmdldCBpcyBub3QgaXRlcmFibGUgb3IgaXQncyBhbiBhcnJheSB3aXRoIHRoZSBkZWZhdWx0IGl0ZXJhdG9yIC0gdXNlIGEgc2ltcGxlIGNhc2Vcblx0ICBpZiAoaXRlcmF0b3JNZXRob2QgIT0gdW5kZWZpbmVkICYmICEoQyA9PSBBcnJheSAmJiBpc0FycmF5SXRlcmF0b3JNZXRob2QoaXRlcmF0b3JNZXRob2QpKSkge1xuXHQgICAgaXRlcmF0b3IgPSBpdGVyYXRvck1ldGhvZC5jYWxsKE8pO1xuXHQgICAgcmVzdWx0ID0gbmV3IEMoKTtcblx0ICAgIGZvciAoOyEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZTsgaW5kZXgrKykge1xuXHQgICAgICBjcmVhdGVQcm9wZXJ0eShyZXN1bHQsIGluZGV4LCBtYXBwaW5nXG5cdCAgICAgICAgPyBjYWxsV2l0aFNhZmVJdGVyYXRpb25DbG9zaW5nKGl0ZXJhdG9yLCBtYXBmbiwgW3N0ZXAudmFsdWUsIGluZGV4XSwgdHJ1ZSlcblx0ICAgICAgICA6IHN0ZXAudmFsdWVcblx0ICAgICAgKTtcblx0ICAgIH1cblx0ICB9IGVsc2Uge1xuXHQgICAgbGVuZ3RoID0gdG9MZW5ndGgoTy5sZW5ndGgpO1xuXHQgICAgcmVzdWx0ID0gbmV3IEMobGVuZ3RoKTtcblx0ICAgIGZvciAoO2xlbmd0aCA+IGluZGV4OyBpbmRleCsrKSB7XG5cdCAgICAgIGNyZWF0ZVByb3BlcnR5KHJlc3VsdCwgaW5kZXgsIG1hcHBpbmcgPyBtYXBmbihPW2luZGV4XSwgaW5kZXgpIDogT1tpbmRleF0pO1xuXHQgICAgfVxuXHQgIH1cblx0ICByZXN1bHQubGVuZ3RoID0gaW5kZXg7XG5cdCAgcmV0dXJuIHJlc3VsdDtcblx0fTtcblxuXHR2YXIgSU5DT1JSRUNUX0lURVJBVElPTiA9ICFjaGVja0NvcnJlY3RuZXNzT2ZJdGVyYXRpb24oZnVuY3Rpb24gKGl0ZXJhYmxlKSB7XG5cdCAgQXJyYXkuZnJvbShpdGVyYWJsZSk7XG5cdH0pO1xuXG5cdC8vIGBBcnJheS5mcm9tYCBtZXRob2Rcblx0Ly8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtYXJyYXkuZnJvbVxuXHRfZXhwb3J0KHsgdGFyZ2V0OiAnQXJyYXknLCBzdGF0OiB0cnVlLCBmb3JjZWQ6IElOQ09SUkVDVF9JVEVSQVRJT04gfSwge1xuXHQgIGZyb206IGFycmF5RnJvbVxuXHR9KTtcblxuXHR2YXIgZnJvbV8xID0gcGF0aC5BcnJheS5mcm9tO1xuXG5cdC8qIGVzbGludC1kaXNhYmxlIG5vLW5ldyAqL1xuXG5cblxuXHR2YXIgTkFUSVZFX0FSUkFZX0JVRkZFUl9WSUVXUyQxID0gYXJyYXlCdWZmZXJWaWV3Q29yZS5OQVRJVkVfQVJSQVlfQlVGRkVSX1ZJRVdTO1xuXG5cdHZhciBBcnJheUJ1ZmZlciA9IGdsb2JhbF8xLkFycmF5QnVmZmVyO1xuXHR2YXIgSW50OEFycmF5JDIgPSBnbG9iYWxfMS5JbnQ4QXJyYXk7XG5cblx0dmFyIHR5cGVkQXJyYXlzQ29uc3RydWN0b3JzUmVxdWlyZXNXcmFwcGVycyA9ICFOQVRJVkVfQVJSQVlfQlVGRkVSX1ZJRVdTJDEgfHwgIWZhaWxzKGZ1bmN0aW9uICgpIHtcblx0ICBJbnQ4QXJyYXkkMigxKTtcblx0fSkgfHwgIWZhaWxzKGZ1bmN0aW9uICgpIHtcblx0ICBuZXcgSW50OEFycmF5JDIoLTEpO1xuXHR9KSB8fCAhY2hlY2tDb3JyZWN0bmVzc09mSXRlcmF0aW9uKGZ1bmN0aW9uIChpdGVyYWJsZSkge1xuXHQgIG5ldyBJbnQ4QXJyYXkkMigpO1xuXHQgIG5ldyBJbnQ4QXJyYXkkMihudWxsKTtcblx0ICBuZXcgSW50OEFycmF5JDIoMS41KTtcblx0ICBuZXcgSW50OEFycmF5JDIoaXRlcmFibGUpO1xuXHR9LCB0cnVlKSB8fCBmYWlscyhmdW5jdGlvbiAoKSB7XG5cdCAgLy8gU2FmYXJpIDExIGJ1Z1xuXHQgIHJldHVybiBuZXcgSW50OEFycmF5JDIobmV3IEFycmF5QnVmZmVyKDIpLCAxLCB1bmRlZmluZWQpLmxlbmd0aCAhPT0gMTtcblx0fSk7XG5cblx0dmFyIGFUeXBlZEFycmF5Q29uc3RydWN0b3IkMSA9IGFycmF5QnVmZmVyVmlld0NvcmUuYVR5cGVkQXJyYXlDb25zdHJ1Y3RvcjtcblxuXHR2YXIgdHlwZWRBcnJheUZyb20gPSBmdW5jdGlvbiBmcm9tKHNvdXJjZSAvKiAsIG1hcGZuLCB0aGlzQXJnICovKSB7XG5cdCAgdmFyIE8gPSB0b09iamVjdChzb3VyY2UpO1xuXHQgIHZhciBhcmd1bWVudHNMZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoO1xuXHQgIHZhciBtYXBmbiA9IGFyZ3VtZW50c0xlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQ7XG5cdCAgdmFyIG1hcHBpbmcgPSBtYXBmbiAhPT0gdW5kZWZpbmVkO1xuXHQgIHZhciBpdGVyYXRvck1ldGhvZCA9IGdldEl0ZXJhdG9yTWV0aG9kKE8pO1xuXHQgIHZhciBpLCBsZW5ndGgsIHJlc3VsdCwgc3RlcCwgaXRlcmF0b3I7XG5cdCAgaWYgKGl0ZXJhdG9yTWV0aG9kICE9IHVuZGVmaW5lZCAmJiAhaXNBcnJheUl0ZXJhdG9yTWV0aG9kKGl0ZXJhdG9yTWV0aG9kKSkge1xuXHQgICAgaXRlcmF0b3IgPSBpdGVyYXRvck1ldGhvZC5jYWxsKE8pO1xuXHQgICAgTyA9IFtdO1xuXHQgICAgd2hpbGUgKCEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xuXHQgICAgICBPLnB1c2goc3RlcC52YWx1ZSk7XG5cdCAgICB9XG5cdCAgfVxuXHQgIGlmIChtYXBwaW5nICYmIGFyZ3VtZW50c0xlbmd0aCA+IDIpIHtcblx0ICAgIG1hcGZuID0gYmluZENvbnRleHQobWFwZm4sIGFyZ3VtZW50c1syXSwgMik7XG5cdCAgfVxuXHQgIGxlbmd0aCA9IHRvTGVuZ3RoKE8ubGVuZ3RoKTtcblx0ICByZXN1bHQgPSBuZXcgKGFUeXBlZEFycmF5Q29uc3RydWN0b3IkMSh0aGlzKSkobGVuZ3RoKTtcblx0ICBmb3IgKGkgPSAwOyBsZW5ndGggPiBpOyBpKyspIHtcblx0ICAgIHJlc3VsdFtpXSA9IG1hcHBpbmcgPyBtYXBmbihPW2ldLCBpKSA6IE9baV07XG5cdCAgfVxuXHQgIHJldHVybiByZXN1bHQ7XG5cdH07XG5cblx0Ly8gYCVUeXBlZEFycmF5JS5mcm9tYCBtZXRob2Rcblx0Ly8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtJXR5cGVkYXJyYXklLmZyb21cblx0YXJyYXlCdWZmZXJWaWV3Q29yZS5leHBvcnRTdGF0aWMoJ2Zyb20nLCB0eXBlZEFycmF5RnJvbSwgdHlwZWRBcnJheXNDb25zdHJ1Y3RvcnNSZXF1aXJlc1dyYXBwZXJzKTtcblxuXHR2YXIgSVNOVF9HRU5FUklDID0gZmFpbHMoZnVuY3Rpb24gKCkge1xuXHQgIGZ1bmN0aW9uIEYoKSB7IC8qIGVtcHR5ICovIH1cblx0ICByZXR1cm4gIShBcnJheS5vZi5jYWxsKEYpIGluc3RhbmNlb2YgRik7XG5cdH0pO1xuXG5cdC8vIGBBcnJheS5vZmAgbWV0aG9kXG5cdC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWFycmF5Lm9mXG5cdC8vIFdlYktpdCBBcnJheS5vZiBpc24ndCBnZW5lcmljXG5cdF9leHBvcnQoeyB0YXJnZXQ6ICdBcnJheScsIHN0YXQ6IHRydWUsIGZvcmNlZDogSVNOVF9HRU5FUklDIH0sIHtcblx0ICBvZjogZnVuY3Rpb24gb2YoLyogLi4uYXJncyAqLykge1xuXHQgICAgdmFyIGluZGV4ID0gMDtcblx0ICAgIHZhciBhcmd1bWVudHNMZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoO1xuXHQgICAgdmFyIHJlc3VsdCA9IG5ldyAodHlwZW9mIHRoaXMgPT0gJ2Z1bmN0aW9uJyA/IHRoaXMgOiBBcnJheSkoYXJndW1lbnRzTGVuZ3RoKTtcblx0ICAgIHdoaWxlIChhcmd1bWVudHNMZW5ndGggPiBpbmRleCkgY3JlYXRlUHJvcGVydHkocmVzdWx0LCBpbmRleCwgYXJndW1lbnRzW2luZGV4KytdKTtcblx0ICAgIHJlc3VsdC5sZW5ndGggPSBhcmd1bWVudHNMZW5ndGg7XG5cdCAgICByZXR1cm4gcmVzdWx0O1xuXHQgIH1cblx0fSk7XG5cblx0dmFyIG9mID0gcGF0aC5BcnJheS5vZjtcblxuXHR2YXIgYVR5cGVkQXJyYXlDb25zdHJ1Y3RvciQyID0gYXJyYXlCdWZmZXJWaWV3Q29yZS5hVHlwZWRBcnJheUNvbnN0cnVjdG9yO1xuXG5cdC8vIGAlVHlwZWRBcnJheSUub2ZgIG1ldGhvZFxuXHQvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy0ldHlwZWRhcnJheSUub2Zcblx0YXJyYXlCdWZmZXJWaWV3Q29yZS5leHBvcnRTdGF0aWMoJ29mJywgZnVuY3Rpb24gb2YoLyogLi4uaXRlbXMgKi8pIHtcblx0ICB2YXIgaW5kZXggPSAwO1xuXHQgIHZhciBsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoO1xuXHQgIHZhciByZXN1bHQgPSBuZXcgKGFUeXBlZEFycmF5Q29uc3RydWN0b3IkMih0aGlzKSkobGVuZ3RoKTtcblx0ICB3aGlsZSAobGVuZ3RoID4gaW5kZXgpIHJlc3VsdFtpbmRleF0gPSBhcmd1bWVudHNbaW5kZXgrK107XG5cdCAgcmV0dXJuIHJlc3VsdDtcblx0fSwgdHlwZWRBcnJheXNDb25zdHJ1Y3RvcnNSZXF1aXJlc1dyYXBwZXJzKTtcblxuXHR2YXIgZGVmaW5lUHJvcGVydHkkMyA9IG9iamVjdERlZmluZVByb3BlcnR5LmY7XG5cblx0dmFyIEZ1bmN0aW9uUHJvdG90eXBlID0gRnVuY3Rpb24ucHJvdG90eXBlO1xuXHR2YXIgRnVuY3Rpb25Qcm90b3R5cGVUb1N0cmluZyA9IEZ1bmN0aW9uUHJvdG90eXBlLnRvU3RyaW5nO1xuXHR2YXIgbmFtZVJFID0gL15cXHMqZnVuY3Rpb24gKFteIChdKikvO1xuXHR2YXIgTkFNRSQxID0gJ25hbWUnO1xuXG5cdC8vIEZ1bmN0aW9uIGluc3RhbmNlcyBgLm5hbWVgIHByb3BlcnR5XG5cdC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWZ1bmN0aW9uLWluc3RhbmNlcy1uYW1lXG5cdGlmIChkZXNjcmlwdG9ycyAmJiAhKE5BTUUkMSBpbiBGdW5jdGlvblByb3RvdHlwZSkpIHtcblx0ICBkZWZpbmVQcm9wZXJ0eSQzKEZ1bmN0aW9uUHJvdG90eXBlLCBOQU1FJDEsIHtcblx0ICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcblx0ICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICB0cnkge1xuXHQgICAgICAgIHJldHVybiBGdW5jdGlvblByb3RvdHlwZVRvU3RyaW5nLmNhbGwodGhpcykubWF0Y2gobmFtZVJFKVsxXTtcblx0ICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcblx0ICAgICAgICByZXR1cm4gJyc7XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICB9KTtcblx0fVxuXG5cdHZhciBmbG9vciQxID0gTWF0aC5mbG9vcjtcblx0dmFyIGxvZyA9IE1hdGgubG9nO1xuXHR2YXIgTE9HMkUgPSBNYXRoLkxPRzJFO1xuXG5cdC8vIGBNYXRoLmNsejMyYCBtZXRob2Rcblx0Ly8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtbWF0aC5jbHozMlxuXHRfZXhwb3J0KHsgdGFyZ2V0OiAnTWF0aCcsIHN0YXQ6IHRydWUgfSwge1xuXHQgIGNsejMyOiBmdW5jdGlvbiBjbHozMih4KSB7XG5cdCAgICByZXR1cm4gKHggPj4+PSAwKSA/IDMxIC0gZmxvb3IkMShsb2coeCArIDAuNSkgKiBMT0cyRSkgOiAzMjtcblx0ICB9XG5cdH0pO1xuXG5cdHZhciBjbHozMiA9IHBhdGguTWF0aC5jbHozMjtcblxuXHR2YXIgbmF0aXZlSW11bCA9IE1hdGguaW11bDtcblxuXHR2YXIgRk9SQ0VEID0gZmFpbHMoZnVuY3Rpb24gKCkge1xuXHQgIHJldHVybiBuYXRpdmVJbXVsKDB4RkZGRkZGRkYsIDUpICE9IC01IHx8IG5hdGl2ZUltdWwubGVuZ3RoICE9IDI7XG5cdH0pO1xuXG5cdC8vIGBNYXRoLmltdWxgIG1ldGhvZFxuXHQvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1tYXRoLmltdWxcblx0Ly8gc29tZSBXZWJLaXQgdmVyc2lvbnMgZmFpbHMgd2l0aCBiaWcgbnVtYmVycywgc29tZSBoYXMgd3JvbmcgYXJpdHlcblx0X2V4cG9ydCh7IHRhcmdldDogJ01hdGgnLCBzdGF0OiB0cnVlLCBmb3JjZWQ6IEZPUkNFRCB9LCB7XG5cdCAgaW11bDogZnVuY3Rpb24gaW11bCh4LCB5KSB7XG5cdCAgICB2YXIgVUlOVDE2ID0gMHhGRkZGO1xuXHQgICAgdmFyIHhuID0gK3g7XG5cdCAgICB2YXIgeW4gPSAreTtcblx0ICAgIHZhciB4bCA9IFVJTlQxNiAmIHhuO1xuXHQgICAgdmFyIHlsID0gVUlOVDE2ICYgeW47XG5cdCAgICByZXR1cm4gMCB8IHhsICogeWwgKyAoKFVJTlQxNiAmIHhuID4+PiAxNikgKiB5bCArIHhsICogKFVJTlQxNiAmIHluID4+PiAxNikgPDwgMTYgPj4+IDApO1xuXHQgIH1cblx0fSk7XG5cblx0dmFyIGltdWwgPSBwYXRoLk1hdGguaW11bDtcblxuXHQvLyBgTWF0aC5zaWduYCBtZXRob2QgaW1wbGVtZW50YXRpb25cblx0Ly8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtbWF0aC5zaWduXG5cdHZhciBtYXRoU2lnbiA9IE1hdGguc2lnbiB8fCBmdW5jdGlvbiBzaWduKHgpIHtcblx0ICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1jb21wYXJlXG5cdCAgcmV0dXJuICh4ID0gK3gpID09IDAgfHwgeCAhPSB4ID8geCA6IHggPCAwID8gLTEgOiAxO1xuXHR9O1xuXG5cdC8vIGBNYXRoLnNpZ25gIG1ldGhvZFxuXHQvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1tYXRoLnNpZ25cblx0X2V4cG9ydCh7IHRhcmdldDogJ01hdGgnLCBzdGF0OiB0cnVlIH0sIHtcblx0ICBzaWduOiBtYXRoU2lnblxuXHR9KTtcblxuXHR2YXIgc2lnbiA9IHBhdGguTWF0aC5zaWduO1xuXG5cdHZhciBsb2ckMSA9IE1hdGgubG9nO1xuXHR2YXIgTE9HMTBFID0gTWF0aC5MT0cxMEU7XG5cblx0Ly8gYE1hdGgubG9nMTBgIG1ldGhvZFxuXHQvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1tYXRoLmxvZzEwXG5cdF9leHBvcnQoeyB0YXJnZXQ6ICdNYXRoJywgc3RhdDogdHJ1ZSB9LCB7XG5cdCAgbG9nMTA6IGZ1bmN0aW9uIGxvZzEwKHgpIHtcblx0ICAgIHJldHVybiBsb2ckMSh4KSAqIExPRzEwRTtcblx0ICB9XG5cdH0pO1xuXG5cdHZhciBsb2cxMCA9IHBhdGguTWF0aC5sb2cxMDtcblxuXHR2YXIgbG9nJDIgPSBNYXRoLmxvZztcblx0dmFyIExOMiA9IE1hdGguTE4yO1xuXG5cdC8vIGBNYXRoLmxvZzJgIG1ldGhvZFxuXHQvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1tYXRoLmxvZzJcblx0X2V4cG9ydCh7IHRhcmdldDogJ01hdGgnLCBzdGF0OiB0cnVlIH0sIHtcblx0ICBsb2cyOiBmdW5jdGlvbiBsb2cyKHgpIHtcblx0ICAgIHJldHVybiBsb2ckMih4KSAvIExOMjtcblx0ICB9XG5cdH0pO1xuXG5cdHZhciBsb2cyID0gcGF0aC5NYXRoLmxvZzI7XG5cblx0dmFyIGxvZyQzID0gTWF0aC5sb2c7XG5cblx0Ly8gYE1hdGgubG9nMXBgIG1ldGhvZCBpbXBsZW1lbnRhdGlvblxuXHQvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1tYXRoLmxvZzFwXG5cdHZhciBtYXRoTG9nMXAgPSBNYXRoLmxvZzFwIHx8IGZ1bmN0aW9uIGxvZzFwKHgpIHtcblx0ICByZXR1cm4gKHggPSAreCkgPiAtMWUtOCAmJiB4IDwgMWUtOCA/IHggLSB4ICogeCAvIDIgOiBsb2ckMygxICsgeCk7XG5cdH07XG5cblx0Ly8gYE1hdGgubG9nMXBgIG1ldGhvZFxuXHQvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1tYXRoLmxvZzFwXG5cdF9leHBvcnQoeyB0YXJnZXQ6ICdNYXRoJywgc3RhdDogdHJ1ZSB9LCB7IGxvZzFwOiBtYXRoTG9nMXAgfSk7XG5cblx0dmFyIGxvZzFwID0gcGF0aC5NYXRoLmxvZzFwO1xuXG5cdHZhciBuYXRpdmVFeHBtMSA9IE1hdGguZXhwbTE7XG5cdHZhciBleHAgPSBNYXRoLmV4cDtcblxuXHQvLyBgTWF0aC5leHBtMWAgbWV0aG9kIGltcGxlbWVudGF0aW9uXG5cdC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLW1hdGguZXhwbTFcblx0dmFyIG1hdGhFeHBtMSA9ICghbmF0aXZlRXhwbTFcblx0ICAvLyBPbGQgRkYgYnVnXG5cdCAgfHwgbmF0aXZlRXhwbTEoMTApID4gMjIwMjUuNDY1Nzk0ODA2NzE5IHx8IG5hdGl2ZUV4cG0xKDEwKSA8IDIyMDI1LjQ2NTc5NDgwNjcxNjUxNjhcblx0ICAvLyBUb3IgQnJvd3NlciBidWdcblx0ICB8fCBuYXRpdmVFeHBtMSgtMmUtMTcpICE9IC0yZS0xN1xuXHQpID8gZnVuY3Rpb24gZXhwbTEoeCkge1xuXHQgIHJldHVybiAoeCA9ICt4KSA9PSAwID8geCA6IHggPiAtMWUtNiAmJiB4IDwgMWUtNiA/IHggKyB4ICogeCAvIDIgOiBleHAoeCkgLSAxO1xuXHR9IDogbmF0aXZlRXhwbTE7XG5cblx0Ly8gYE1hdGguZXhwbTFgIG1ldGhvZFxuXHQvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1tYXRoLmV4cG0xXG5cdF9leHBvcnQoeyB0YXJnZXQ6ICdNYXRoJywgc3RhdDogdHJ1ZSwgZm9yY2VkOiBtYXRoRXhwbTEgIT0gTWF0aC5leHBtMSB9LCB7IGV4cG0xOiBtYXRoRXhwbTEgfSk7XG5cblx0dmFyIGV4cG0xID0gcGF0aC5NYXRoLmV4cG0xO1xuXG5cdHZhciBuYXRpdmVDb3NoID0gTWF0aC5jb3NoO1xuXHR2YXIgYWJzID0gTWF0aC5hYnM7XG5cdHZhciBFID0gTWF0aC5FO1xuXG5cdC8vIGBNYXRoLmNvc2hgIG1ldGhvZFxuXHQvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1tYXRoLmNvc2hcblx0X2V4cG9ydCh7IHRhcmdldDogJ01hdGgnLCBzdGF0OiB0cnVlLCBmb3JjZWQ6ICFuYXRpdmVDb3NoIHx8IG5hdGl2ZUNvc2goNzEwKSA9PT0gSW5maW5pdHkgfSwge1xuXHQgIGNvc2g6IGZ1bmN0aW9uIGNvc2goeCkge1xuXHQgICAgdmFyIHQgPSBtYXRoRXhwbTEoYWJzKHgpIC0gMSkgKyAxO1xuXHQgICAgcmV0dXJuICh0ICsgMSAvICh0ICogRSAqIEUpKSAqIChFIC8gMik7XG5cdCAgfVxuXHR9KTtcblxuXHR2YXIgY29zaCA9IHBhdGguTWF0aC5jb3NoO1xuXG5cdHZhciBhYnMkMSA9IE1hdGguYWJzO1xuXHR2YXIgZXhwJDEgPSBNYXRoLmV4cDtcblx0dmFyIEUkMSA9IE1hdGguRTtcblxuXHR2YXIgRk9SQ0VEJDEgPSBmYWlscyhmdW5jdGlvbiAoKSB7XG5cdCAgcmV0dXJuIE1hdGguc2luaCgtMmUtMTcpICE9IC0yZS0xNztcblx0fSk7XG5cblx0Ly8gYE1hdGguc2luaGAgbWV0aG9kXG5cdC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLW1hdGguc2luaFxuXHQvLyBWOCBuZWFyIENocm9taXVtIDM4IGhhcyBhIHByb2JsZW0gd2l0aCB2ZXJ5IHNtYWxsIG51bWJlcnNcblx0X2V4cG9ydCh7IHRhcmdldDogJ01hdGgnLCBzdGF0OiB0cnVlLCBmb3JjZWQ6IEZPUkNFRCQxIH0sIHtcblx0ICBzaW5oOiBmdW5jdGlvbiBzaW5oKHgpIHtcblx0ICAgIHJldHVybiBhYnMkMSh4ID0gK3gpIDwgMSA/IChtYXRoRXhwbTEoeCkgLSBtYXRoRXhwbTEoLXgpKSAvIDIgOiAoZXhwJDEoeCAtIDEpIC0gZXhwJDEoLXggLSAxKSkgKiAoRSQxIC8gMik7XG5cdCAgfVxuXHR9KTtcblxuXHR2YXIgc2luaCA9IHBhdGguTWF0aC5zaW5oO1xuXG5cdHZhciBleHAkMiA9IE1hdGguZXhwO1xuXG5cdC8vIGBNYXRoLnRhbmhgIG1ldGhvZFxuXHQvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1tYXRoLnRhbmhcblx0X2V4cG9ydCh7IHRhcmdldDogJ01hdGgnLCBzdGF0OiB0cnVlIH0sIHtcblx0ICB0YW5oOiBmdW5jdGlvbiB0YW5oKHgpIHtcblx0ICAgIHZhciBhID0gbWF0aEV4cG0xKHggPSAreCk7XG5cdCAgICB2YXIgYiA9IG1hdGhFeHBtMSgteCk7XG5cdCAgICByZXR1cm4gYSA9PSBJbmZpbml0eSA/IDEgOiBiID09IEluZmluaXR5ID8gLTEgOiAoYSAtIGIpIC8gKGV4cCQyKHgpICsgZXhwJDIoLXgpKTtcblx0ICB9XG5cdH0pO1xuXG5cdHZhciB0YW5oID0gcGF0aC5NYXRoLnRhbmg7XG5cblx0dmFyIG5hdGl2ZUFjb3NoID0gTWF0aC5hY29zaDtcblx0dmFyIGxvZyQ0ID0gTWF0aC5sb2c7XG5cdHZhciBzcXJ0ID0gTWF0aC5zcXJ0O1xuXHR2YXIgTE4yJDEgPSBNYXRoLkxOMjtcblxuXHR2YXIgRk9SQ0VEJDIgPSAhbmF0aXZlQWNvc2hcblx0ICAvLyBWOCBidWc6IGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0zNTA5XG5cdCAgfHwgTWF0aC5mbG9vcihuYXRpdmVBY29zaChOdW1iZXIuTUFYX1ZBTFVFKSkgIT0gNzEwXG5cdCAgLy8gVG9yIEJyb3dzZXIgYnVnOiBNYXRoLmFjb3NoKEluZmluaXR5KSAtPiBOYU5cblx0ICB8fCBuYXRpdmVBY29zaChJbmZpbml0eSkgIT0gSW5maW5pdHk7XG5cblx0Ly8gYE1hdGguYWNvc2hgIG1ldGhvZFxuXHQvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1tYXRoLmFjb3NoXG5cdF9leHBvcnQoeyB0YXJnZXQ6ICdNYXRoJywgc3RhdDogdHJ1ZSwgZm9yY2VkOiBGT1JDRUQkMiB9LCB7XG5cdCAgYWNvc2g6IGZ1bmN0aW9uIGFjb3NoKHgpIHtcblx0ICAgIHJldHVybiAoeCA9ICt4KSA8IDEgPyBOYU4gOiB4ID4gOTQ5MDYyNjUuNjI0MjUxNTZcblx0ICAgICAgPyBsb2ckNCh4KSArIExOMiQxXG5cdCAgICAgIDogbWF0aExvZzFwKHggLSAxICsgc3FydCh4IC0gMSkgKiBzcXJ0KHggKyAxKSk7XG5cdCAgfVxuXHR9KTtcblxuXHR2YXIgYWNvc2ggPSBwYXRoLk1hdGguYWNvc2g7XG5cblx0dmFyIG5hdGl2ZUFzaW5oID0gTWF0aC5hc2luaDtcblx0dmFyIGxvZyQ1ID0gTWF0aC5sb2c7XG5cdHZhciBzcXJ0JDEgPSBNYXRoLnNxcnQ7XG5cblx0ZnVuY3Rpb24gYXNpbmgoeCkge1xuXHQgIHJldHVybiAhaXNGaW5pdGUoeCA9ICt4KSB8fCB4ID09IDAgPyB4IDogeCA8IDAgPyAtYXNpbmgoLXgpIDogbG9nJDUoeCArIHNxcnQkMSh4ICogeCArIDEpKTtcblx0fVxuXG5cdC8vIGBNYXRoLmFzaW5oYCBtZXRob2Rcblx0Ly8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtbWF0aC5hc2luaFxuXHQvLyBUb3IgQnJvd3NlciBidWc6IE1hdGguYXNpbmgoMCkgLT4gLTBcblx0X2V4cG9ydCh7IHRhcmdldDogJ01hdGgnLCBzdGF0OiB0cnVlLCBmb3JjZWQ6ICEobmF0aXZlQXNpbmggJiYgMSAvIG5hdGl2ZUFzaW5oKDApID4gMCkgfSwge1xuXHQgIGFzaW5oOiBhc2luaFxuXHR9KTtcblxuXHR2YXIgYXNpbmgkMSA9IHBhdGguTWF0aC5hc2luaDtcblxuXHR2YXIgbmF0aXZlQXRhbmggPSBNYXRoLmF0YW5oO1xuXHR2YXIgbG9nJDYgPSBNYXRoLmxvZztcblxuXHQvLyBgTWF0aC5hdGFuaGAgbWV0aG9kXG5cdC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLW1hdGguYXRhbmhcblx0Ly8gVG9yIEJyb3dzZXIgYnVnOiBNYXRoLmF0YW5oKC0wKSAtPiAwXG5cdF9leHBvcnQoeyB0YXJnZXQ6ICdNYXRoJywgc3RhdDogdHJ1ZSwgZm9yY2VkOiAhKG5hdGl2ZUF0YW5oICYmIDEgLyBuYXRpdmVBdGFuaCgtMCkgPCAwKSB9LCB7XG5cdCAgYXRhbmg6IGZ1bmN0aW9uIGF0YW5oKHgpIHtcblx0ICAgIHJldHVybiAoeCA9ICt4KSA9PSAwID8geCA6IGxvZyQ2KCgxICsgeCkgLyAoMSAtIHgpKSAvIDI7XG5cdCAgfVxuXHR9KTtcblxuXHR2YXIgYXRhbmggPSBwYXRoLk1hdGguYXRhbmg7XG5cblx0dmFyICRoeXBvdCA9IE1hdGguaHlwb3Q7XG5cdHZhciBhYnMkMiA9IE1hdGguYWJzO1xuXHR2YXIgc3FydCQyID0gTWF0aC5zcXJ0O1xuXG5cdC8vIENocm9tZSA3NyBidWdcblx0Ly8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9OTU0NlxuXHR2YXIgQlVHR1kgPSAhISRoeXBvdCAmJiAkaHlwb3QoSW5maW5pdHksIE5hTikgIT09IEluZmluaXR5O1xuXG5cdC8vIGBNYXRoLmh5cG90YCBtZXRob2Rcblx0Ly8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtbWF0aC5oeXBvdFxuXHRfZXhwb3J0KHsgdGFyZ2V0OiAnTWF0aCcsIHN0YXQ6IHRydWUsIGZvcmNlZDogQlVHR1kgfSwge1xuXHQgIGh5cG90OiBmdW5jdGlvbiBoeXBvdCh2YWx1ZTEsIHZhbHVlMikgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG5cdCAgICB2YXIgc3VtID0gMDtcblx0ICAgIHZhciBpID0gMDtcblx0ICAgIHZhciBhTGVuID0gYXJndW1lbnRzLmxlbmd0aDtcblx0ICAgIHZhciBsYXJnID0gMDtcblx0ICAgIHZhciBhcmcsIGRpdjtcblx0ICAgIHdoaWxlIChpIDwgYUxlbikge1xuXHQgICAgICBhcmcgPSBhYnMkMihhcmd1bWVudHNbaSsrXSk7XG5cdCAgICAgIGlmIChsYXJnIDwgYXJnKSB7XG5cdCAgICAgICAgZGl2ID0gbGFyZyAvIGFyZztcblx0ICAgICAgICBzdW0gPSBzdW0gKiBkaXYgKiBkaXYgKyAxO1xuXHQgICAgICAgIGxhcmcgPSBhcmc7XG5cdCAgICAgIH0gZWxzZSBpZiAoYXJnID4gMCkge1xuXHQgICAgICAgIGRpdiA9IGFyZyAvIGxhcmc7XG5cdCAgICAgICAgc3VtICs9IGRpdiAqIGRpdjtcblx0ICAgICAgfSBlbHNlIHN1bSArPSBhcmc7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gbGFyZyA9PT0gSW5maW5pdHkgPyBJbmZpbml0eSA6IGxhcmcgKiBzcXJ0JDIoc3VtKTtcblx0ICB9XG5cdH0pO1xuXG5cdHZhciBoeXBvdCA9IHBhdGguTWF0aC5oeXBvdDtcblxuXHR2YXIgY2VpbCQxID0gTWF0aC5jZWlsO1xuXHR2YXIgZmxvb3IkMiA9IE1hdGguZmxvb3I7XG5cblx0Ly8gYE1hdGgudHJ1bmNgIG1ldGhvZFxuXHQvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1tYXRoLnRydW5jXG5cdF9leHBvcnQoeyB0YXJnZXQ6ICdNYXRoJywgc3RhdDogdHJ1ZSB9LCB7XG5cdCAgdHJ1bmM6IGZ1bmN0aW9uIHRydW5jKGl0KSB7XG5cdCAgICByZXR1cm4gKGl0ID4gMCA/IGZsb29yJDIgOiBjZWlsJDEpKGl0KTtcblx0ICB9XG5cdH0pO1xuXG5cdHZhciB0cnVuYyA9IHBhdGguTWF0aC50cnVuYztcblxuXHR2YXIgYWJzJDMgPSBNYXRoLmFicztcblx0dmFyIHBvdyA9IE1hdGgucG93O1xuXHR2YXIgRVBTSUxPTiA9IHBvdygyLCAtNTIpO1xuXHR2YXIgRVBTSUxPTjMyID0gcG93KDIsIC0yMyk7XG5cdHZhciBNQVgzMiA9IHBvdygyLCAxMjcpICogKDIgLSBFUFNJTE9OMzIpO1xuXHR2YXIgTUlOMzIgPSBwb3coMiwgLTEyNik7XG5cblx0dmFyIHJvdW5kVGllc1RvRXZlbiA9IGZ1bmN0aW9uIChuKSB7XG5cdCAgcmV0dXJuIG4gKyAxIC8gRVBTSUxPTiAtIDEgLyBFUFNJTE9OO1xuXHR9O1xuXG5cdC8vIGBNYXRoLmZyb3VuZGAgbWV0aG9kIGltcGxlbWVudGF0aW9uXG5cdC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLW1hdGguZnJvdW5kXG5cdHZhciBtYXRoRnJvdW5kID0gTWF0aC5mcm91bmQgfHwgZnVuY3Rpb24gZnJvdW5kKHgpIHtcblx0ICB2YXIgJGFicyA9IGFicyQzKHgpO1xuXHQgIHZhciAkc2lnbiA9IG1hdGhTaWduKHgpO1xuXHQgIHZhciBhLCByZXN1bHQ7XG5cdCAgaWYgKCRhYnMgPCBNSU4zMikgcmV0dXJuICRzaWduICogcm91bmRUaWVzVG9FdmVuKCRhYnMgLyBNSU4zMiAvIEVQU0lMT04zMikgKiBNSU4zMiAqIEVQU0lMT04zMjtcblx0ICBhID0gKDEgKyBFUFNJTE9OMzIgLyBFUFNJTE9OKSAqICRhYnM7XG5cdCAgcmVzdWx0ID0gYSAtIChhIC0gJGFicyk7XG5cdCAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtY29tcGFyZVxuXHQgIGlmIChyZXN1bHQgPiBNQVgzMiB8fCByZXN1bHQgIT0gcmVzdWx0KSByZXR1cm4gJHNpZ24gKiBJbmZpbml0eTtcblx0ICByZXR1cm4gJHNpZ24gKiByZXN1bHQ7XG5cdH07XG5cblx0Ly8gYE1hdGguZnJvdW5kYCBtZXRob2Rcblx0Ly8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtbWF0aC5mcm91bmRcblx0X2V4cG9ydCh7IHRhcmdldDogJ01hdGgnLCBzdGF0OiB0cnVlIH0sIHsgZnJvdW5kOiBtYXRoRnJvdW5kIH0pO1xuXG5cdHZhciBmcm91bmQgPSBwYXRoLk1hdGguZnJvdW5kO1xuXG5cdHZhciBhYnMkNCA9IE1hdGguYWJzO1xuXHR2YXIgcG93JDEgPSBNYXRoLnBvdztcblxuXHQvLyBgTWF0aC5jYnJ0YCBtZXRob2Rcblx0Ly8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtbWF0aC5jYnJ0XG5cdF9leHBvcnQoeyB0YXJnZXQ6ICdNYXRoJywgc3RhdDogdHJ1ZSB9LCB7XG5cdCAgY2JydDogZnVuY3Rpb24gY2JydCh4KSB7XG5cdCAgICByZXR1cm4gbWF0aFNpZ24oeCA9ICt4KSAqIHBvdyQxKGFicyQ0KHgpLCAxIC8gMyk7XG5cdCAgfVxuXHR9KTtcblxuXHR2YXIgY2JydCA9IHBhdGguTWF0aC5jYnJ0O1xuXG5cdC8vIGBOdW1iZXIuRVBTSUxPTmAgY29uc3RhbnRcblx0Ly8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtbnVtYmVyLmVwc2lsb25cblx0X2V4cG9ydCh7IHRhcmdldDogJ051bWJlcicsIHN0YXQ6IHRydWUgfSwge1xuXHQgIEVQU0lMT046IE1hdGgucG93KDIsIC01Milcblx0fSk7XG5cblx0dmFyIGdsb2JhbElzRmluaXRlID0gZ2xvYmFsXzEuaXNGaW5pdGU7XG5cblx0Ly8gYE51bWJlci5pc0Zpbml0ZWAgbWV0aG9kXG5cdC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLW51bWJlci5pc2Zpbml0ZVxuXHR2YXIgbnVtYmVySXNGaW5pdGUgPSBOdW1iZXIuaXNGaW5pdGUgfHwgZnVuY3Rpb24gaXNGaW5pdGUoaXQpIHtcblx0ICByZXR1cm4gdHlwZW9mIGl0ID09ICdudW1iZXInICYmIGdsb2JhbElzRmluaXRlKGl0KTtcblx0fTtcblxuXHQvLyBgTnVtYmVyLmlzRmluaXRlYCBtZXRob2Rcblx0Ly8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtbnVtYmVyLmlzZmluaXRlXG5cdF9leHBvcnQoeyB0YXJnZXQ6ICdOdW1iZXInLCBzdGF0OiB0cnVlIH0sIHsgaXNGaW5pdGU6IG51bWJlcklzRmluaXRlIH0pO1xuXG5cdHZhciBfaXNGaW5pdGUgPSBwYXRoLk51bWJlci5pc0Zpbml0ZTtcblxuXHR2YXIgZmxvb3IkMyA9IE1hdGguZmxvb3I7XG5cblx0Ly8gYE51bWJlci5pc0ludGVnZXJgIG1ldGhvZCBpbXBsZW1lbnRhdGlvblxuXHQvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1udW1iZXIuaXNpbnRlZ2VyXG5cdHZhciBpc0ludGVnZXIgPSBmdW5jdGlvbiBpc0ludGVnZXIoaXQpIHtcblx0ICByZXR1cm4gIWlzT2JqZWN0KGl0KSAmJiBpc0Zpbml0ZShpdCkgJiYgZmxvb3IkMyhpdCkgPT09IGl0O1xuXHR9O1xuXG5cdC8vIGBOdW1iZXIuaXNJbnRlZ2VyYCBtZXRob2Rcblx0Ly8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtbnVtYmVyLmlzaW50ZWdlclxuXHRfZXhwb3J0KHsgdGFyZ2V0OiAnTnVtYmVyJywgc3RhdDogdHJ1ZSB9LCB7XG5cdCAgaXNJbnRlZ2VyOiBpc0ludGVnZXJcblx0fSk7XG5cblx0dmFyIGlzSW50ZWdlciQxID0gcGF0aC5OdW1iZXIuaXNJbnRlZ2VyO1xuXG5cdC8vIGBOdW1iZXIuaXNOYU5gIG1ldGhvZFxuXHQvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1udW1iZXIuaXNuYW5cblx0X2V4cG9ydCh7IHRhcmdldDogJ051bWJlcicsIHN0YXQ6IHRydWUgfSwge1xuXHQgIGlzTmFOOiBmdW5jdGlvbiBpc05hTihudW1iZXIpIHtcblx0ICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWNvbXBhcmVcblx0ICAgIHJldHVybiBudW1iZXIgIT0gbnVtYmVyO1xuXHQgIH1cblx0fSk7XG5cblx0dmFyIGlzTmFuID0gcGF0aC5OdW1iZXIuaXNOYU47XG5cblx0dmFyIGFicyQ1ID0gTWF0aC5hYnM7XG5cblx0Ly8gYE51bWJlci5pc1NhZmVJbnRlZ2VyYCBtZXRob2Rcblx0Ly8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtbnVtYmVyLmlzc2FmZWludGVnZXJcblx0X2V4cG9ydCh7IHRhcmdldDogJ051bWJlcicsIHN0YXQ6IHRydWUgfSwge1xuXHQgIGlzU2FmZUludGVnZXI6IGZ1bmN0aW9uIGlzU2FmZUludGVnZXIobnVtYmVyKSB7XG5cdCAgICByZXR1cm4gaXNJbnRlZ2VyKG51bWJlcikgJiYgYWJzJDUobnVtYmVyKSA8PSAweDFGRkZGRkZGRkZGRkZGO1xuXHQgIH1cblx0fSk7XG5cblx0dmFyIGlzU2FmZUludGVnZXIgPSBwYXRoLk51bWJlci5pc1NhZmVJbnRlZ2VyO1xuXG5cdC8vIGBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUmAgY29uc3RhbnRcblx0Ly8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtbnVtYmVyLm1heF9zYWZlX2ludGVnZXJcblx0X2V4cG9ydCh7IHRhcmdldDogJ051bWJlcicsIHN0YXQ6IHRydWUgfSwge1xuXHQgIE1BWF9TQUZFX0lOVEVHRVI6IDB4MUZGRkZGRkZGRkZGRkZcblx0fSk7XG5cblx0Ly8gYE51bWJlci5NSU5fU0FGRV9JTlRFR0VSYCBjb25zdGFudFxuXHQvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1udW1iZXIubWluX3NhZmVfaW50ZWdlclxuXHRfZXhwb3J0KHsgdGFyZ2V0OiAnTnVtYmVyJywgc3RhdDogdHJ1ZSB9LCB7XG5cdCAgTUlOX1NBRkVfSU5URUdFUjogLTB4MUZGRkZGRkZGRkZGRkZcblx0fSk7XG5cblx0Ly8gYSBzdHJpbmcgb2YgYWxsIHZhbGlkIHVuaWNvZGUgd2hpdGVzcGFjZXNcblx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG1heC1sZW5cblx0dmFyIHdoaXRlc3BhY2VzID0gJ1xcdTAwMDlcXHUwMDBBXFx1MDAwQlxcdTAwMENcXHUwMDBEXFx1MDAyMFxcdTAwQTBcXHUxNjgwXFx1MjAwMFxcdTIwMDFcXHUyMDAyXFx1MjAwM1xcdTIwMDRcXHUyMDA1XFx1MjAwNlxcdTIwMDdcXHUyMDA4XFx1MjAwOVxcdTIwMEFcXHUyMDJGXFx1MjA1RlxcdTMwMDBcXHUyMDI4XFx1MjAyOVxcdUZFRkYnO1xuXG5cdHZhciB3aGl0ZXNwYWNlID0gJ1snICsgd2hpdGVzcGFjZXMgKyAnXSc7XG5cdHZhciBsdHJpbSA9IFJlZ0V4cCgnXicgKyB3aGl0ZXNwYWNlICsgd2hpdGVzcGFjZSArICcqJyk7XG5cdHZhciBydHJpbSA9IFJlZ0V4cCh3aGl0ZXNwYWNlICsgd2hpdGVzcGFjZSArICcqJCcpO1xuXG5cdC8vIGBTdHJpbmcucHJvdG90eXBlLnsgdHJpbSwgdHJpbVN0YXJ0LCB0cmltRW5kLCB0cmltTGVmdCwgdHJpbVJpZ2h0IH1gIG1ldGhvZHMgaW1wbGVtZW50YXRpb25cblx0dmFyIGNyZWF0ZU1ldGhvZCQzID0gZnVuY3Rpb24gKFRZUEUpIHtcblx0ICByZXR1cm4gZnVuY3Rpb24gKCR0aGlzKSB7XG5cdCAgICB2YXIgc3RyaW5nID0gU3RyaW5nKHJlcXVpcmVPYmplY3RDb2VyY2libGUoJHRoaXMpKTtcblx0ICAgIGlmIChUWVBFICYgMSkgc3RyaW5nID0gc3RyaW5nLnJlcGxhY2UobHRyaW0sICcnKTtcblx0ICAgIGlmIChUWVBFICYgMikgc3RyaW5nID0gc3RyaW5nLnJlcGxhY2UocnRyaW0sICcnKTtcblx0ICAgIHJldHVybiBzdHJpbmc7XG5cdCAgfTtcblx0fTtcblxuXHR2YXIgc3RyaW5nVHJpbSA9IHtcblx0ICAvLyBgU3RyaW5nLnByb3RvdHlwZS57IHRyaW1MZWZ0LCB0cmltU3RhcnQgfWAgbWV0aG9kc1xuXHQgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXN0cmluZy5wcm90b3R5cGUudHJpbXN0YXJ0XG5cdCAgc3RhcnQ6IGNyZWF0ZU1ldGhvZCQzKDEpLFxuXHQgIC8vIGBTdHJpbmcucHJvdG90eXBlLnsgdHJpbVJpZ2h0LCB0cmltRW5kIH1gIG1ldGhvZHNcblx0ICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1zdHJpbmcucHJvdG90eXBlLnRyaW1lbmRcblx0ICBlbmQ6IGNyZWF0ZU1ldGhvZCQzKDIpLFxuXHQgIC8vIGBTdHJpbmcucHJvdG90eXBlLnRyaW1gIG1ldGhvZFxuXHQgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXN0cmluZy5wcm90b3R5cGUudHJpbVxuXHQgIHRyaW06IGNyZWF0ZU1ldGhvZCQzKDMpXG5cdH07XG5cblx0dmFyIHRyaW0gPSBzdHJpbmdUcmltLnRyaW07XG5cblxuXHR2YXIgbmF0aXZlUGFyc2VGbG9hdCA9IGdsb2JhbF8xLnBhcnNlRmxvYXQ7XG5cdHZhciBGT1JDRUQkMyA9IDEgLyBuYXRpdmVQYXJzZUZsb2F0KHdoaXRlc3BhY2VzICsgJy0wJykgIT09IC1JbmZpbml0eTtcblxuXHQvLyBgcGFyc2VGbG9hdGAgbWV0aG9kXG5cdC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXBhcnNlZmxvYXQtc3RyaW5nXG5cdHZhciBfcGFyc2VGbG9hdCA9IEZPUkNFRCQzID8gZnVuY3Rpb24gcGFyc2VGbG9hdChzdHJpbmcpIHtcblx0ICB2YXIgdHJpbW1lZFN0cmluZyA9IHRyaW0oU3RyaW5nKHN0cmluZykpO1xuXHQgIHZhciByZXN1bHQgPSBuYXRpdmVQYXJzZUZsb2F0KHRyaW1tZWRTdHJpbmcpO1xuXHQgIHJldHVybiByZXN1bHQgPT09IDAgJiYgdHJpbW1lZFN0cmluZy5jaGFyQXQoMCkgPT0gJy0nID8gLTAgOiByZXN1bHQ7XG5cdH0gOiBuYXRpdmVQYXJzZUZsb2F0O1xuXG5cdC8vIGBOdW1iZXIucGFyc2VGbG9hdGAgbWV0aG9kXG5cdC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLW51bWJlci5wYXJzZUZsb2F0XG5cdF9leHBvcnQoeyB0YXJnZXQ6ICdOdW1iZXInLCBzdGF0OiB0cnVlLCBmb3JjZWQ6IE51bWJlci5wYXJzZUZsb2F0ICE9IF9wYXJzZUZsb2F0IH0sIHtcblx0ICBwYXJzZUZsb2F0OiBfcGFyc2VGbG9hdFxuXHR9KTtcblxuXHR2YXIgX3BhcnNlRmxvYXQkMSA9IHBhdGguTnVtYmVyLnBhcnNlRmxvYXQ7XG5cblx0dmFyIHRyaW0kMSA9IHN0cmluZ1RyaW0udHJpbTtcblxuXG5cdHZhciBuYXRpdmVQYXJzZUludCA9IGdsb2JhbF8xLnBhcnNlSW50O1xuXHR2YXIgaGV4ID0gL15bKy1dPzBbWHhdLztcblx0dmFyIEZPUkNFRCQ0ID0gbmF0aXZlUGFyc2VJbnQod2hpdGVzcGFjZXMgKyAnMDgnKSAhPT0gOCB8fCBuYXRpdmVQYXJzZUludCh3aGl0ZXNwYWNlcyArICcweDE2JykgIT09IDIyO1xuXG5cdC8vIGBwYXJzZUludGAgbWV0aG9kXG5cdC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXBhcnNlaW50LXN0cmluZy1yYWRpeFxuXHR2YXIgX3BhcnNlSW50ID0gRk9SQ0VEJDQgPyBmdW5jdGlvbiBwYXJzZUludChzdHJpbmcsIHJhZGl4KSB7XG5cdCAgdmFyIFMgPSB0cmltJDEoU3RyaW5nKHN0cmluZykpO1xuXHQgIHJldHVybiBuYXRpdmVQYXJzZUludChTLCAocmFkaXggPj4+IDApIHx8IChoZXgudGVzdChTKSA/IDE2IDogMTApKTtcblx0fSA6IG5hdGl2ZVBhcnNlSW50O1xuXG5cdC8vIGBOdW1iZXIucGFyc2VJbnRgIG1ldGhvZFxuXHQvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1udW1iZXIucGFyc2VpbnRcblx0X2V4cG9ydCh7IHRhcmdldDogJ051bWJlcicsIHN0YXQ6IHRydWUsIGZvcmNlZDogTnVtYmVyLnBhcnNlSW50ICE9IF9wYXJzZUludCB9LCB7XG5cdCAgcGFyc2VJbnQ6IF9wYXJzZUludFxuXHR9KTtcblxuXHR2YXIgX3BhcnNlSW50JDEgPSBwYXRoLk51bWJlci5wYXJzZUludDtcblxuXHR2YXIgbmF0aXZlQXNzaWduID0gT2JqZWN0LmFzc2lnbjtcblxuXHQvLyBgT2JqZWN0LmFzc2lnbmAgbWV0aG9kXG5cdC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLW9iamVjdC5hc3NpZ25cblx0Ly8gc2hvdWxkIHdvcmsgd2l0aCBzeW1ib2xzIGFuZCBzaG91bGQgaGF2ZSBkZXRlcm1pbmlzdGljIHByb3BlcnR5IG9yZGVyIChWOCBidWcpXG5cdHZhciBvYmplY3RBc3NpZ24gPSAhbmF0aXZlQXNzaWduIHx8IGZhaWxzKGZ1bmN0aW9uICgpIHtcblx0ICB2YXIgQSA9IHt9O1xuXHQgIHZhciBCID0ge307XG5cdCAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmXG5cdCAgdmFyIHN5bWJvbCA9IFN5bWJvbCgpO1xuXHQgIHZhciBhbHBoYWJldCA9ICdhYmNkZWZnaGlqa2xtbm9wcXJzdCc7XG5cdCAgQVtzeW1ib2xdID0gNztcblx0ICBhbHBoYWJldC5zcGxpdCgnJykuZm9yRWFjaChmdW5jdGlvbiAoY2hyKSB7IEJbY2hyXSA9IGNocjsgfSk7XG5cdCAgcmV0dXJuIG5hdGl2ZUFzc2lnbih7fSwgQSlbc3ltYm9sXSAhPSA3IHx8IG9iamVjdEtleXMobmF0aXZlQXNzaWduKHt9LCBCKSkuam9pbignJykgIT0gYWxwaGFiZXQ7XG5cdH0pID8gZnVuY3Rpb24gYXNzaWduKHRhcmdldCwgc291cmNlKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcblx0ICB2YXIgVCA9IHRvT2JqZWN0KHRhcmdldCk7XG5cdCAgdmFyIGFyZ3VtZW50c0xlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGg7XG5cdCAgdmFyIGluZGV4ID0gMTtcblx0ICB2YXIgZ2V0T3duUHJvcGVydHlTeW1ib2xzID0gb2JqZWN0R2V0T3duUHJvcGVydHlTeW1ib2xzLmY7XG5cdCAgdmFyIHByb3BlcnR5SXNFbnVtZXJhYmxlID0gb2JqZWN0UHJvcGVydHlJc0VudW1lcmFibGUuZjtcblx0ICB3aGlsZSAoYXJndW1lbnRzTGVuZ3RoID4gaW5kZXgpIHtcblx0ICAgIHZhciBTID0gaW5kZXhlZE9iamVjdChhcmd1bWVudHNbaW5kZXgrK10pO1xuXHQgICAgdmFyIGtleXMgPSBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPyBvYmplY3RLZXlzKFMpLmNvbmNhdChnZXRPd25Qcm9wZXJ0eVN5bWJvbHMoUykpIDogb2JqZWN0S2V5cyhTKTtcblx0ICAgIHZhciBsZW5ndGggPSBrZXlzLmxlbmd0aDtcblx0ICAgIHZhciBqID0gMDtcblx0ICAgIHZhciBrZXk7XG5cdCAgICB3aGlsZSAobGVuZ3RoID4gaikge1xuXHQgICAgICBrZXkgPSBrZXlzW2orK107XG5cdCAgICAgIGlmICghZGVzY3JpcHRvcnMgfHwgcHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChTLCBrZXkpKSBUW2tleV0gPSBTW2tleV07XG5cdCAgICB9XG5cdCAgfSByZXR1cm4gVDtcblx0fSA6IG5hdGl2ZUFzc2lnbjtcblxuXHQvLyBgT2JqZWN0LmFzc2lnbmAgbWV0aG9kXG5cdC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLW9iamVjdC5hc3NpZ25cblx0X2V4cG9ydCh7IHRhcmdldDogJ09iamVjdCcsIHN0YXQ6IHRydWUsIGZvcmNlZDogT2JqZWN0LmFzc2lnbiAhPT0gb2JqZWN0QXNzaWduIH0sIHtcblx0ICBhc3NpZ246IG9iamVjdEFzc2lnblxuXHR9KTtcblxuXHR2YXIgYXNzaWduID0gcGF0aC5PYmplY3QuYXNzaWduO1xuXG5cdHZhciBuYXRpdmVHZXRPd25Qcm9wZXJ0eU5hbWVzID0gb2JqZWN0R2V0T3duUHJvcGVydHlOYW1lcy5mO1xuXG5cdHZhciB0b1N0cmluZyQxID0ge30udG9TdHJpbmc7XG5cblx0dmFyIHdpbmRvd05hbWVzID0gdHlwZW9mIHdpbmRvdyA9PSAnb2JqZWN0JyAmJiB3aW5kb3cgJiYgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXNcblx0ICA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHdpbmRvdykgOiBbXTtcblxuXHR2YXIgZ2V0V2luZG93TmFtZXMgPSBmdW5jdGlvbiAoaXQpIHtcblx0ICB0cnkge1xuXHQgICAgcmV0dXJuIG5hdGl2ZUdldE93blByb3BlcnR5TmFtZXMoaXQpO1xuXHQgIH0gY2F0Y2ggKGVycm9yKSB7XG5cdCAgICByZXR1cm4gd2luZG93TmFtZXMuc2xpY2UoKTtcblx0ICB9XG5cdH07XG5cblx0Ly8gZmFsbGJhY2sgZm9yIElFMTEgYnVnZ3kgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMgd2l0aCBpZnJhbWUgYW5kIHdpbmRvd1xuXHR2YXIgZiQ1ID0gZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlOYW1lcyhpdCkge1xuXHQgIHJldHVybiB3aW5kb3dOYW1lcyAmJiB0b1N0cmluZyQxLmNhbGwoaXQpID09ICdbb2JqZWN0IFdpbmRvd10nXG5cdCAgICA/IGdldFdpbmRvd05hbWVzKGl0KVxuXHQgICAgOiBuYXRpdmVHZXRPd25Qcm9wZXJ0eU5hbWVzKHRvSW5kZXhlZE9iamVjdChpdCkpO1xuXHR9O1xuXG5cdHZhciBvYmplY3RHZXRPd25Qcm9wZXJ0eU5hbWVzRXh0ZXJuYWwgPSB7XG5cdFx0ZjogZiQ1XG5cdH07XG5cblx0dmFyIGYkNiA9IHdlbGxLbm93blN5bWJvbDtcblxuXHR2YXIgd3JhcHBlZFdlbGxLbm93blN5bWJvbCA9IHtcblx0XHRmOiBmJDZcblx0fTtcblxuXHR2YXIgZGVmaW5lUHJvcGVydHkkNCA9IG9iamVjdERlZmluZVByb3BlcnR5LmY7XG5cblx0dmFyIGRlZmluZVdlbGxLbm93blN5bWJvbCA9IGZ1bmN0aW9uIChOQU1FKSB7XG5cdCAgdmFyIFN5bWJvbCA9IHBhdGguU3ltYm9sIHx8IChwYXRoLlN5bWJvbCA9IHt9KTtcblx0ICBpZiAoIWhhcyhTeW1ib2wsIE5BTUUpKSBkZWZpbmVQcm9wZXJ0eSQ0KFN5bWJvbCwgTkFNRSwge1xuXHQgICAgdmFsdWU6IHdyYXBwZWRXZWxsS25vd25TeW1ib2wuZihOQU1FKVxuXHQgIH0pO1xuXHR9O1xuXG5cdHZhciAkZm9yRWFjaCA9IGFycmF5SXRlcmF0aW9uLmZvckVhY2g7XG5cblx0dmFyIEhJRERFTiA9IHNoYXJlZEtleSgnaGlkZGVuJyk7XG5cdHZhciBTWU1CT0wgPSAnU3ltYm9sJztcblx0dmFyIFBST1RPVFlQRSQxID0gJ3Byb3RvdHlwZSc7XG5cdHZhciBUT19QUklNSVRJVkUgPSB3ZWxsS25vd25TeW1ib2woJ3RvUHJpbWl0aXZlJyk7XG5cdHZhciBzZXRJbnRlcm5hbFN0YXRlJDQgPSBpbnRlcm5hbFN0YXRlLnNldDtcblx0dmFyIGdldEludGVybmFsU3RhdGUkMiA9IGludGVybmFsU3RhdGUuZ2V0dGVyRm9yKFNZTUJPTCk7XG5cdHZhciBPYmplY3RQcm90b3R5cGUkMyA9IE9iamVjdFtQUk9UT1RZUEUkMV07XG5cdHZhciAkU3ltYm9sID0gZ2xvYmFsXzEuU3ltYm9sO1xuXHR2YXIgSlNPTiA9IGdsb2JhbF8xLkpTT047XG5cdHZhciBuYXRpdmVKU09OU3RyaW5naWZ5ID0gSlNPTiAmJiBKU09OLnN0cmluZ2lmeTtcblx0dmFyIG5hdGl2ZUdldE93blByb3BlcnR5RGVzY3JpcHRvciQxID0gb2JqZWN0R2V0T3duUHJvcGVydHlEZXNjcmlwdG9yLmY7XG5cdHZhciBuYXRpdmVEZWZpbmVQcm9wZXJ0eSQxID0gb2JqZWN0RGVmaW5lUHJvcGVydHkuZjtcblx0dmFyIG5hdGl2ZUdldE93blByb3BlcnR5TmFtZXMkMSA9IG9iamVjdEdldE93blByb3BlcnR5TmFtZXNFeHRlcm5hbC5mO1xuXHR2YXIgbmF0aXZlUHJvcGVydHlJc0VudW1lcmFibGUkMSA9IG9iamVjdFByb3BlcnR5SXNFbnVtZXJhYmxlLmY7XG5cdHZhciBBbGxTeW1ib2xzID0gc2hhcmVkKCdzeW1ib2xzJyk7XG5cdHZhciBPYmplY3RQcm90b3R5cGVTeW1ib2xzID0gc2hhcmVkKCdvcC1zeW1ib2xzJyk7XG5cdHZhciBTdHJpbmdUb1N5bWJvbFJlZ2lzdHJ5ID0gc2hhcmVkKCdzdHJpbmctdG8tc3ltYm9sLXJlZ2lzdHJ5Jyk7XG5cdHZhciBTeW1ib2xUb1N0cmluZ1JlZ2lzdHJ5ID0gc2hhcmVkKCdzeW1ib2wtdG8tc3RyaW5nLXJlZ2lzdHJ5Jyk7XG5cdHZhciBXZWxsS25vd25TeW1ib2xzU3RvcmUgPSBzaGFyZWQoJ3drcycpO1xuXHR2YXIgUU9iamVjdCA9IGdsb2JhbF8xLlFPYmplY3Q7XG5cdC8vIERvbid0IHVzZSBzZXR0ZXJzIGluIFF0IFNjcmlwdCwgaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzE3M1xuXHR2YXIgVVNFX1NFVFRFUiA9ICFRT2JqZWN0IHx8ICFRT2JqZWN0W1BST1RPVFlQRSQxXSB8fCAhUU9iamVjdFtQUk9UT1RZUEUkMV0uZmluZENoaWxkO1xuXG5cdC8vIGZhbGxiYWNrIGZvciBvbGQgQW5kcm9pZCwgaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTY4N1xuXHR2YXIgc2V0U3ltYm9sRGVzY3JpcHRvciA9IGRlc2NyaXB0b3JzICYmIGZhaWxzKGZ1bmN0aW9uICgpIHtcblx0ICByZXR1cm4gb2JqZWN0Q3JlYXRlKG5hdGl2ZURlZmluZVByb3BlcnR5JDEoe30sICdhJywge1xuXHQgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBuYXRpdmVEZWZpbmVQcm9wZXJ0eSQxKHRoaXMsICdhJywgeyB2YWx1ZTogNyB9KS5hOyB9XG5cdCAgfSkpLmEgIT0gNztcblx0fSkgPyBmdW5jdGlvbiAoTywgUCwgQXR0cmlidXRlcykge1xuXHQgIHZhciBPYmplY3RQcm90b3R5cGVEZXNjcmlwdG9yID0gbmF0aXZlR2V0T3duUHJvcGVydHlEZXNjcmlwdG9yJDEoT2JqZWN0UHJvdG90eXBlJDMsIFApO1xuXHQgIGlmIChPYmplY3RQcm90b3R5cGVEZXNjcmlwdG9yKSBkZWxldGUgT2JqZWN0UHJvdG90eXBlJDNbUF07XG5cdCAgbmF0aXZlRGVmaW5lUHJvcGVydHkkMShPLCBQLCBBdHRyaWJ1dGVzKTtcblx0ICBpZiAoT2JqZWN0UHJvdG90eXBlRGVzY3JpcHRvciAmJiBPICE9PSBPYmplY3RQcm90b3R5cGUkMykge1xuXHQgICAgbmF0aXZlRGVmaW5lUHJvcGVydHkkMShPYmplY3RQcm90b3R5cGUkMywgUCwgT2JqZWN0UHJvdG90eXBlRGVzY3JpcHRvcik7XG5cdCAgfVxuXHR9IDogbmF0aXZlRGVmaW5lUHJvcGVydHkkMTtcblxuXHR2YXIgd3JhcCA9IGZ1bmN0aW9uICh0YWcsIGRlc2NyaXB0aW9uKSB7XG5cdCAgdmFyIHN5bWJvbCA9IEFsbFN5bWJvbHNbdGFnXSA9IG9iamVjdENyZWF0ZSgkU3ltYm9sW1BST1RPVFlQRSQxXSk7XG5cdCAgc2V0SW50ZXJuYWxTdGF0ZSQ0KHN5bWJvbCwge1xuXHQgICAgdHlwZTogU1lNQk9MLFxuXHQgICAgdGFnOiB0YWcsXG5cdCAgICBkZXNjcmlwdGlvbjogZGVzY3JpcHRpb25cblx0ICB9KTtcblx0ICBpZiAoIWRlc2NyaXB0b3JzKSBzeW1ib2wuZGVzY3JpcHRpb24gPSBkZXNjcmlwdGlvbjtcblx0ICByZXR1cm4gc3ltYm9sO1xuXHR9O1xuXG5cdHZhciBpc1N5bWJvbCA9IG5hdGl2ZVN5bWJvbCAmJiB0eXBlb2YgJFN5bWJvbC5pdGVyYXRvciA9PSAnc3ltYm9sJyA/IGZ1bmN0aW9uIChpdCkge1xuXHQgIHJldHVybiB0eXBlb2YgaXQgPT0gJ3N5bWJvbCc7XG5cdH0gOiBmdW5jdGlvbiAoaXQpIHtcblx0ICByZXR1cm4gT2JqZWN0KGl0KSBpbnN0YW5jZW9mICRTeW1ib2w7XG5cdH07XG5cblx0dmFyICRkZWZpbmVQcm9wZXJ0eSA9IGZ1bmN0aW9uIGRlZmluZVByb3BlcnR5KE8sIFAsIEF0dHJpYnV0ZXMpIHtcblx0ICBpZiAoTyA9PT0gT2JqZWN0UHJvdG90eXBlJDMpICRkZWZpbmVQcm9wZXJ0eShPYmplY3RQcm90b3R5cGVTeW1ib2xzLCBQLCBBdHRyaWJ1dGVzKTtcblx0ICBhbk9iamVjdChPKTtcblx0ICB2YXIga2V5ID0gdG9QcmltaXRpdmUoUCwgdHJ1ZSk7XG5cdCAgYW5PYmplY3QoQXR0cmlidXRlcyk7XG5cdCAgaWYgKGhhcyhBbGxTeW1ib2xzLCBrZXkpKSB7XG5cdCAgICBpZiAoIUF0dHJpYnV0ZXMuZW51bWVyYWJsZSkge1xuXHQgICAgICBpZiAoIWhhcyhPLCBISURERU4pKSBuYXRpdmVEZWZpbmVQcm9wZXJ0eSQxKE8sIEhJRERFTiwgY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yKDEsIHt9KSk7XG5cdCAgICAgIE9bSElEREVOXVtrZXldID0gdHJ1ZTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIGlmIChoYXMoTywgSElEREVOKSAmJiBPW0hJRERFTl1ba2V5XSkgT1tISURERU5dW2tleV0gPSBmYWxzZTtcblx0ICAgICAgQXR0cmlidXRlcyA9IG9iamVjdENyZWF0ZShBdHRyaWJ1dGVzLCB7IGVudW1lcmFibGU6IGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvcigwLCBmYWxzZSkgfSk7XG5cdCAgICB9IHJldHVybiBzZXRTeW1ib2xEZXNjcmlwdG9yKE8sIGtleSwgQXR0cmlidXRlcyk7XG5cdCAgfSByZXR1cm4gbmF0aXZlRGVmaW5lUHJvcGVydHkkMShPLCBrZXksIEF0dHJpYnV0ZXMpO1xuXHR9O1xuXG5cdHZhciAkZGVmaW5lUHJvcGVydGllcyA9IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXMoTywgUHJvcGVydGllcykge1xuXHQgIGFuT2JqZWN0KE8pO1xuXHQgIHZhciBwcm9wZXJ0aWVzID0gdG9JbmRleGVkT2JqZWN0KFByb3BlcnRpZXMpO1xuXHQgIHZhciBrZXlzID0gb2JqZWN0S2V5cyhwcm9wZXJ0aWVzKS5jb25jYXQoJGdldE93blByb3BlcnR5U3ltYm9scyhwcm9wZXJ0aWVzKSk7XG5cdCAgJGZvckVhY2goa2V5cywgZnVuY3Rpb24gKGtleSkge1xuXHQgICAgaWYgKCFkZXNjcmlwdG9ycyB8fCAkcHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChwcm9wZXJ0aWVzLCBrZXkpKSAkZGVmaW5lUHJvcGVydHkoTywga2V5LCBwcm9wZXJ0aWVzW2tleV0pO1xuXHQgIH0pO1xuXHQgIHJldHVybiBPO1xuXHR9O1xuXG5cdHZhciAkY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKE8sIFByb3BlcnRpZXMpIHtcblx0ICByZXR1cm4gUHJvcGVydGllcyA9PT0gdW5kZWZpbmVkID8gb2JqZWN0Q3JlYXRlKE8pIDogJGRlZmluZVByb3BlcnRpZXMob2JqZWN0Q3JlYXRlKE8pLCBQcm9wZXJ0aWVzKTtcblx0fTtcblxuXHR2YXIgJHByb3BlcnR5SXNFbnVtZXJhYmxlID0gZnVuY3Rpb24gcHJvcGVydHlJc0VudW1lcmFibGUoVikge1xuXHQgIHZhciBQID0gdG9QcmltaXRpdmUoViwgdHJ1ZSk7XG5cdCAgdmFyIGVudW1lcmFibGUgPSBuYXRpdmVQcm9wZXJ0eUlzRW51bWVyYWJsZSQxLmNhbGwodGhpcywgUCk7XG5cdCAgaWYgKHRoaXMgPT09IE9iamVjdFByb3RvdHlwZSQzICYmIGhhcyhBbGxTeW1ib2xzLCBQKSAmJiAhaGFzKE9iamVjdFByb3RvdHlwZVN5bWJvbHMsIFApKSByZXR1cm4gZmFsc2U7XG5cdCAgcmV0dXJuIGVudW1lcmFibGUgfHwgIWhhcyh0aGlzLCBQKSB8fCAhaGFzKEFsbFN5bWJvbHMsIFApIHx8IGhhcyh0aGlzLCBISURERU4pICYmIHRoaXNbSElEREVOXVtQXSA/IGVudW1lcmFibGUgOiB0cnVlO1xuXHR9O1xuXG5cdHZhciAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE8sIFApIHtcblx0ICB2YXIgaXQgPSB0b0luZGV4ZWRPYmplY3QoTyk7XG5cdCAgdmFyIGtleSA9IHRvUHJpbWl0aXZlKFAsIHRydWUpO1xuXHQgIGlmIChpdCA9PT0gT2JqZWN0UHJvdG90eXBlJDMgJiYgaGFzKEFsbFN5bWJvbHMsIGtleSkgJiYgIWhhcyhPYmplY3RQcm90b3R5cGVTeW1ib2xzLCBrZXkpKSByZXR1cm47XG5cdCAgdmFyIGRlc2NyaXB0b3IgPSBuYXRpdmVHZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IkMShpdCwga2V5KTtcblx0ICBpZiAoZGVzY3JpcHRvciAmJiBoYXMoQWxsU3ltYm9scywga2V5KSAmJiAhKGhhcyhpdCwgSElEREVOKSAmJiBpdFtISURERU5dW2tleV0pKSB7XG5cdCAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSB0cnVlO1xuXHQgIH1cblx0ICByZXR1cm4gZGVzY3JpcHRvcjtcblx0fTtcblxuXHR2YXIgJGdldE93blByb3BlcnR5TmFtZXMgPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eU5hbWVzKE8pIHtcblx0ICB2YXIgbmFtZXMgPSBuYXRpdmVHZXRPd25Qcm9wZXJ0eU5hbWVzJDEodG9JbmRleGVkT2JqZWN0KE8pKTtcblx0ICB2YXIgcmVzdWx0ID0gW107XG5cdCAgJGZvckVhY2gobmFtZXMsIGZ1bmN0aW9uIChrZXkpIHtcblx0ICAgIGlmICghaGFzKEFsbFN5bWJvbHMsIGtleSkgJiYgIWhhcyhoaWRkZW5LZXlzLCBrZXkpKSByZXN1bHQucHVzaChrZXkpO1xuXHQgIH0pO1xuXHQgIHJldHVybiByZXN1bHQ7XG5cdH07XG5cblx0dmFyICRnZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMoTykge1xuXHQgIHZhciBJU19PQkpFQ1RfUFJPVE9UWVBFID0gTyA9PT0gT2JqZWN0UHJvdG90eXBlJDM7XG5cdCAgdmFyIG5hbWVzID0gbmF0aXZlR2V0T3duUHJvcGVydHlOYW1lcyQxKElTX09CSkVDVF9QUk9UT1RZUEUgPyBPYmplY3RQcm90b3R5cGVTeW1ib2xzIDogdG9JbmRleGVkT2JqZWN0KE8pKTtcblx0ICB2YXIgcmVzdWx0ID0gW107XG5cdCAgJGZvckVhY2gobmFtZXMsIGZ1bmN0aW9uIChrZXkpIHtcblx0ICAgIGlmIChoYXMoQWxsU3ltYm9scywga2V5KSAmJiAoIUlTX09CSkVDVF9QUk9UT1RZUEUgfHwgaGFzKE9iamVjdFByb3RvdHlwZSQzLCBrZXkpKSkge1xuXHQgICAgICByZXN1bHQucHVzaChBbGxTeW1ib2xzW2tleV0pO1xuXHQgICAgfVxuXHQgIH0pO1xuXHQgIHJldHVybiByZXN1bHQ7XG5cdH07XG5cblx0Ly8gYFN5bWJvbGAgY29uc3RydWN0b3Jcblx0Ly8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtc3ltYm9sLWNvbnN0cnVjdG9yXG5cdGlmICghbmF0aXZlU3ltYm9sKSB7XG5cdCAgJFN5bWJvbCA9IGZ1bmN0aW9uIFN5bWJvbCgpIHtcblx0ICAgIGlmICh0aGlzIGluc3RhbmNlb2YgJFN5bWJvbCkgdGhyb3cgVHlwZUVycm9yKCdTeW1ib2wgaXMgbm90IGEgY29uc3RydWN0b3InKTtcblx0ICAgIHZhciBkZXNjcmlwdGlvbiA9ICFhcmd1bWVudHMubGVuZ3RoIHx8IGFyZ3VtZW50c1swXSA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogU3RyaW5nKGFyZ3VtZW50c1swXSk7XG5cdCAgICB2YXIgdGFnID0gdWlkKGRlc2NyaXB0aW9uKTtcblx0ICAgIHZhciBzZXR0ZXIgPSBmdW5jdGlvbiAodmFsdWUpIHtcblx0ICAgICAgaWYgKHRoaXMgPT09IE9iamVjdFByb3RvdHlwZSQzKSBzZXR0ZXIuY2FsbChPYmplY3RQcm90b3R5cGVTeW1ib2xzLCB2YWx1ZSk7XG5cdCAgICAgIGlmIChoYXModGhpcywgSElEREVOKSAmJiBoYXModGhpc1tISURERU5dLCB0YWcpKSB0aGlzW0hJRERFTl1bdGFnXSA9IGZhbHNlO1xuXHQgICAgICBzZXRTeW1ib2xEZXNjcmlwdG9yKHRoaXMsIHRhZywgY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yKDEsIHZhbHVlKSk7XG5cdCAgICB9O1xuXHQgICAgaWYgKGRlc2NyaXB0b3JzICYmIFVTRV9TRVRURVIpIHNldFN5bWJvbERlc2NyaXB0b3IoT2JqZWN0UHJvdG90eXBlJDMsIHRhZywgeyBjb25maWd1cmFibGU6IHRydWUsIHNldDogc2V0dGVyIH0pO1xuXHQgICAgcmV0dXJuIHdyYXAodGFnLCBkZXNjcmlwdGlvbik7XG5cdCAgfTtcblxuXHQgIHJlZGVmaW5lKCRTeW1ib2xbUFJPVE9UWVBFJDFdLCAndG9TdHJpbmcnLCBmdW5jdGlvbiB0b1N0cmluZygpIHtcblx0ICAgIHJldHVybiBnZXRJbnRlcm5hbFN0YXRlJDIodGhpcykudGFnO1xuXHQgIH0pO1xuXG5cdCAgb2JqZWN0UHJvcGVydHlJc0VudW1lcmFibGUuZiA9ICRwcm9wZXJ0eUlzRW51bWVyYWJsZTtcblx0ICBvYmplY3REZWZpbmVQcm9wZXJ0eS5mID0gJGRlZmluZVByb3BlcnR5O1xuXHQgIG9iamVjdEdldE93blByb3BlcnR5RGVzY3JpcHRvci5mID0gJGdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcblx0ICBvYmplY3RHZXRPd25Qcm9wZXJ0eU5hbWVzLmYgPSBvYmplY3RHZXRPd25Qcm9wZXJ0eU5hbWVzRXh0ZXJuYWwuZiA9ICRnZXRPd25Qcm9wZXJ0eU5hbWVzO1xuXHQgIG9iamVjdEdldE93blByb3BlcnR5U3ltYm9scy5mID0gJGdldE93blByb3BlcnR5U3ltYm9scztcblxuXHQgIGlmIChkZXNjcmlwdG9ycykge1xuXHQgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtU3ltYm9sLWRlc2NyaXB0aW9uXG5cdCAgICBuYXRpdmVEZWZpbmVQcm9wZXJ0eSQxKCRTeW1ib2xbUFJPVE9UWVBFJDFdLCAnZGVzY3JpcHRpb24nLCB7XG5cdCAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcblx0ICAgICAgZ2V0OiBmdW5jdGlvbiBkZXNjcmlwdGlvbigpIHtcblx0ICAgICAgICByZXR1cm4gZ2V0SW50ZXJuYWxTdGF0ZSQyKHRoaXMpLmRlc2NyaXB0aW9uO1xuXHQgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIHtcblx0ICAgICAgcmVkZWZpbmUoT2JqZWN0UHJvdG90eXBlJDMsICdwcm9wZXJ0eUlzRW51bWVyYWJsZScsICRwcm9wZXJ0eUlzRW51bWVyYWJsZSwgeyB1bnNhZmU6IHRydWUgfSk7XG5cdCAgICB9XG5cdCAgfVxuXG5cdCAgd3JhcHBlZFdlbGxLbm93blN5bWJvbC5mID0gZnVuY3Rpb24gKG5hbWUpIHtcblx0ICAgIHJldHVybiB3cmFwKHdlbGxLbm93blN5bWJvbChuYW1lKSwgbmFtZSk7XG5cdCAgfTtcblx0fVxuXG5cdF9leHBvcnQoeyBnbG9iYWw6IHRydWUsIHdyYXA6IHRydWUsIGZvcmNlZDogIW5hdGl2ZVN5bWJvbCwgc2hhbTogIW5hdGl2ZVN5bWJvbCB9LCB7XG5cdCAgU3ltYm9sOiAkU3ltYm9sXG5cdH0pO1xuXG5cdCRmb3JFYWNoKG9iamVjdEtleXMoV2VsbEtub3duU3ltYm9sc1N0b3JlKSwgZnVuY3Rpb24gKG5hbWUpIHtcblx0ICBkZWZpbmVXZWxsS25vd25TeW1ib2wobmFtZSk7XG5cdH0pO1xuXG5cdF9leHBvcnQoeyB0YXJnZXQ6IFNZTUJPTCwgc3RhdDogdHJ1ZSwgZm9yY2VkOiAhbmF0aXZlU3ltYm9sIH0sIHtcblx0ICAvLyBgU3ltYm9sLmZvcmAgbWV0aG9kXG5cdCAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtc3ltYm9sLmZvclxuXHQgICdmb3InOiBmdW5jdGlvbiAoa2V5KSB7XG5cdCAgICB2YXIgc3RyaW5nID0gU3RyaW5nKGtleSk7XG5cdCAgICBpZiAoaGFzKFN0cmluZ1RvU3ltYm9sUmVnaXN0cnksIHN0cmluZykpIHJldHVybiBTdHJpbmdUb1N5bWJvbFJlZ2lzdHJ5W3N0cmluZ107XG5cdCAgICB2YXIgc3ltYm9sID0gJFN5bWJvbChzdHJpbmcpO1xuXHQgICAgU3RyaW5nVG9TeW1ib2xSZWdpc3RyeVtzdHJpbmddID0gc3ltYm9sO1xuXHQgICAgU3ltYm9sVG9TdHJpbmdSZWdpc3RyeVtzeW1ib2xdID0gc3RyaW5nO1xuXHQgICAgcmV0dXJuIHN5bWJvbDtcblx0ICB9LFxuXHQgIC8vIGBTeW1ib2wua2V5Rm9yYCBtZXRob2Rcblx0ICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1zeW1ib2wua2V5Zm9yXG5cdCAga2V5Rm9yOiBmdW5jdGlvbiBrZXlGb3Ioc3ltKSB7XG5cdCAgICBpZiAoIWlzU3ltYm9sKHN5bSkpIHRocm93IFR5cGVFcnJvcihzeW0gKyAnIGlzIG5vdCBhIHN5bWJvbCcpO1xuXHQgICAgaWYgKGhhcyhTeW1ib2xUb1N0cmluZ1JlZ2lzdHJ5LCBzeW0pKSByZXR1cm4gU3ltYm9sVG9TdHJpbmdSZWdpc3RyeVtzeW1dO1xuXHQgIH0sXG5cdCAgdXNlU2V0dGVyOiBmdW5jdGlvbiAoKSB7IFVTRV9TRVRURVIgPSB0cnVlOyB9LFxuXHQgIHVzZVNpbXBsZTogZnVuY3Rpb24gKCkgeyBVU0VfU0VUVEVSID0gZmFsc2U7IH1cblx0fSk7XG5cblx0X2V4cG9ydCh7IHRhcmdldDogJ09iamVjdCcsIHN0YXQ6IHRydWUsIGZvcmNlZDogIW5hdGl2ZVN5bWJvbCwgc2hhbTogIWRlc2NyaXB0b3JzIH0sIHtcblx0ICAvLyBgT2JqZWN0LmNyZWF0ZWAgbWV0aG9kXG5cdCAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtb2JqZWN0LmNyZWF0ZVxuXHQgIGNyZWF0ZTogJGNyZWF0ZSxcblx0ICAvLyBgT2JqZWN0LmRlZmluZVByb3BlcnR5YCBtZXRob2Rcblx0ICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1vYmplY3QuZGVmaW5lcHJvcGVydHlcblx0ICBkZWZpbmVQcm9wZXJ0eTogJGRlZmluZVByb3BlcnR5LFxuXHQgIC8vIGBPYmplY3QuZGVmaW5lUHJvcGVydGllc2AgbWV0aG9kXG5cdCAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtb2JqZWN0LmRlZmluZXByb3BlcnRpZXNcblx0ICBkZWZpbmVQcm9wZXJ0aWVzOiAkZGVmaW5lUHJvcGVydGllcyxcblx0ICAvLyBgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcmAgbWV0aG9kXG5cdCAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtb2JqZWN0LmdldG93bnByb3BlcnR5ZGVzY3JpcHRvcnNcblx0ICBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I6ICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Jcblx0fSk7XG5cblx0X2V4cG9ydCh7IHRhcmdldDogJ09iamVjdCcsIHN0YXQ6IHRydWUsIGZvcmNlZDogIW5hdGl2ZVN5bWJvbCB9LCB7XG5cdCAgLy8gYE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzYCBtZXRob2Rcblx0ICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1vYmplY3QuZ2V0b3ducHJvcGVydHluYW1lc1xuXHQgIGdldE93blByb3BlcnR5TmFtZXM6ICRnZXRPd25Qcm9wZXJ0eU5hbWVzLFxuXHQgIC8vIGBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzYCBtZXRob2Rcblx0ICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1vYmplY3QuZ2V0b3ducHJvcGVydHlzeW1ib2xzXG5cdCAgZ2V0T3duUHJvcGVydHlTeW1ib2xzOiAkZ2V0T3duUHJvcGVydHlTeW1ib2xzXG5cdH0pO1xuXG5cdC8vIENocm9tZSAzOCBhbmQgMzkgYE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHNgIGZhaWxzIG9uIHByaW1pdGl2ZXNcblx0Ly8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9MzQ0M1xuXHRfZXhwb3J0KHsgdGFyZ2V0OiAnT2JqZWN0Jywgc3RhdDogdHJ1ZSwgZm9yY2VkOiBmYWlscyhmdW5jdGlvbiAoKSB7IG9iamVjdEdldE93blByb3BlcnR5U3ltYm9scy5mKDEpOyB9KSB9LCB7XG5cdCAgZ2V0T3duUHJvcGVydHlTeW1ib2xzOiBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMoaXQpIHtcblx0ICAgIHJldHVybiBvYmplY3RHZXRPd25Qcm9wZXJ0eVN5bWJvbHMuZih0b09iamVjdChpdCkpO1xuXHQgIH1cblx0fSk7XG5cblx0Ly8gYEpTT04uc3RyaW5naWZ5YCBtZXRob2QgYmVoYXZpb3Igd2l0aCBzeW1ib2xzXG5cdC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWpzb24uc3RyaW5naWZ5XG5cdEpTT04gJiYgX2V4cG9ydCh7IHRhcmdldDogJ0pTT04nLCBzdGF0OiB0cnVlLCBmb3JjZWQ6ICFuYXRpdmVTeW1ib2wgfHwgZmFpbHMoZnVuY3Rpb24gKCkge1xuXHQgIHZhciBzeW1ib2wgPSAkU3ltYm9sKCk7XG5cdCAgLy8gTVMgRWRnZSBjb252ZXJ0cyBzeW1ib2wgdmFsdWVzIHRvIEpTT04gYXMge31cblx0ICByZXR1cm4gbmF0aXZlSlNPTlN0cmluZ2lmeShbc3ltYm9sXSkgIT0gJ1tudWxsXSdcblx0ICAgIC8vIFdlYktpdCBjb252ZXJ0cyBzeW1ib2wgdmFsdWVzIHRvIEpTT04gYXMgbnVsbFxuXHQgICAgfHwgbmF0aXZlSlNPTlN0cmluZ2lmeSh7IGE6IHN5bWJvbCB9KSAhPSAne30nXG5cdCAgICAvLyBWOCB0aHJvd3Mgb24gYm94ZWQgc3ltYm9sc1xuXHQgICAgfHwgbmF0aXZlSlNPTlN0cmluZ2lmeShPYmplY3Qoc3ltYm9sKSkgIT0gJ3t9Jztcblx0fSkgfSwge1xuXHQgIHN0cmluZ2lmeTogZnVuY3Rpb24gc3RyaW5naWZ5KGl0KSB7XG5cdCAgICB2YXIgYXJncyA9IFtpdF07XG5cdCAgICB2YXIgaW5kZXggPSAxO1xuXHQgICAgdmFyIHJlcGxhY2VyLCAkcmVwbGFjZXI7XG5cdCAgICB3aGlsZSAoYXJndW1lbnRzLmxlbmd0aCA+IGluZGV4KSBhcmdzLnB1c2goYXJndW1lbnRzW2luZGV4KytdKTtcblx0ICAgICRyZXBsYWNlciA9IHJlcGxhY2VyID0gYXJnc1sxXTtcblx0ICAgIGlmICghaXNPYmplY3QocmVwbGFjZXIpICYmIGl0ID09PSB1bmRlZmluZWQgfHwgaXNTeW1ib2woaXQpKSByZXR1cm47IC8vIElFOCByZXR1cm5zIHN0cmluZyBvbiB1bmRlZmluZWRcblx0ICAgIGlmICghaXNBcnJheShyZXBsYWNlcikpIHJlcGxhY2VyID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcblx0ICAgICAgaWYgKHR5cGVvZiAkcmVwbGFjZXIgPT0gJ2Z1bmN0aW9uJykgdmFsdWUgPSAkcmVwbGFjZXIuY2FsbCh0aGlzLCBrZXksIHZhbHVlKTtcblx0ICAgICAgaWYgKCFpc1N5bWJvbCh2YWx1ZSkpIHJldHVybiB2YWx1ZTtcblx0ICAgIH07XG5cdCAgICBhcmdzWzFdID0gcmVwbGFjZXI7XG5cdCAgICByZXR1cm4gbmF0aXZlSlNPTlN0cmluZ2lmeS5hcHBseShKU09OLCBhcmdzKTtcblx0ICB9XG5cdH0pO1xuXG5cdC8vIGBTeW1ib2wucHJvdG90eXBlW0BAdG9QcmltaXRpdmVdYCBtZXRob2Rcblx0Ly8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtc3ltYm9sLnByb3RvdHlwZS1AQHRvcHJpbWl0aXZlXG5cdGlmICghJFN5bWJvbFtQUk9UT1RZUEUkMV1bVE9fUFJJTUlUSVZFXSkgaGlkZSgkU3ltYm9sW1BST1RPVFlQRSQxXSwgVE9fUFJJTUlUSVZFLCAkU3ltYm9sW1BST1RPVFlQRSQxXS52YWx1ZU9mKTtcblx0Ly8gYFN5bWJvbC5wcm90b3R5cGVbQEB0b1N0cmluZ1RhZ11gIHByb3BlcnR5XG5cdC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXN5bWJvbC5wcm90b3R5cGUtQEB0b3N0cmluZ3RhZ1xuXHRzZXRUb1N0cmluZ1RhZygkU3ltYm9sLCBTWU1CT0wpO1xuXG5cdGhpZGRlbktleXNbSElEREVOXSA9IHRydWU7XG5cblx0dmFyIGdldE93blByb3BlcnR5U3ltYm9scyA9IHBhdGguT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcblxuXHQvLyBgU2FtZVZhbHVlYCBhYnN0cmFjdCBvcGVyYXRpb25cblx0Ly8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtc2FtZXZhbHVlXG5cdHZhciBzYW1lVmFsdWUgPSBPYmplY3QuaXMgfHwgZnVuY3Rpb24gaXMoeCwgeSkge1xuXHQgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWNvbXBhcmVcblx0ICByZXR1cm4geCA9PT0geSA/IHggIT09IDAgfHwgMSAvIHggPT09IDEgLyB5IDogeCAhPSB4ICYmIHkgIT0geTtcblx0fTtcblxuXHQvLyBgT2JqZWN0LmlzYCBtZXRob2Rcblx0Ly8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtb2JqZWN0LmlzXG5cdF9leHBvcnQoeyB0YXJnZXQ6ICdPYmplY3QnLCBzdGF0OiB0cnVlIH0sIHtcblx0ICBpczogc2FtZVZhbHVlXG5cdH0pO1xuXG5cdHZhciBpcyA9IHBhdGguT2JqZWN0LmlzO1xuXG5cdC8vIGBPYmplY3Quc2V0UHJvdG90eXBlT2ZgIG1ldGhvZFxuXHQvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1vYmplY3Quc2V0cHJvdG90eXBlb2Zcblx0X2V4cG9ydCh7IHRhcmdldDogJ09iamVjdCcsIHN0YXQ6IHRydWUgfSwge1xuXHQgIHNldFByb3RvdHlwZU9mOiBvYmplY3RTZXRQcm90b3R5cGVPZlxuXHR9KTtcblxuXHR2YXIgc2V0UHJvdG90eXBlT2YgPSBwYXRoLk9iamVjdC5zZXRQcm90b3R5cGVPZjtcblxuXHQvLyBgUmVnRXhwLnByb3RvdHlwZS5mbGFnc2AgZ2V0dGVyIGltcGxlbWVudGF0aW9uXG5cdC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWdldC1yZWdleHAucHJvdG90eXBlLmZsYWdzXG5cdHZhciByZWdleHBGbGFncyA9IGZ1bmN0aW9uICgpIHtcblx0ICB2YXIgdGhhdCA9IGFuT2JqZWN0KHRoaXMpO1xuXHQgIHZhciByZXN1bHQgPSAnJztcblx0ICBpZiAodGhhdC5nbG9iYWwpIHJlc3VsdCArPSAnZyc7XG5cdCAgaWYgKHRoYXQuaWdub3JlQ2FzZSkgcmVzdWx0ICs9ICdpJztcblx0ICBpZiAodGhhdC5tdWx0aWxpbmUpIHJlc3VsdCArPSAnbSc7XG5cdCAgaWYgKHRoYXQuZG90QWxsKSByZXN1bHQgKz0gJ3MnO1xuXHQgIGlmICh0aGF0LnVuaWNvZGUpIHJlc3VsdCArPSAndSc7XG5cdCAgaWYgKHRoYXQuc3RpY2t5KSByZXN1bHQgKz0gJ3knO1xuXHQgIHJldHVybiByZXN1bHQ7XG5cdH07XG5cblx0Ly8gYFJlZ0V4cC5wcm90b3R5cGUuZmxhZ3NgIGdldHRlclxuXHQvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1nZXQtcmVnZXhwLnByb3RvdHlwZS5mbGFnc1xuXHRpZiAoZGVzY3JpcHRvcnMgJiYgLy4vZy5mbGFncyAhPSAnZycpIHtcblx0ICBvYmplY3REZWZpbmVQcm9wZXJ0eS5mKFJlZ0V4cC5wcm90b3R5cGUsICdmbGFncycsIHtcblx0ICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcblx0ICAgIGdldDogcmVnZXhwRmxhZ3Ncblx0ICB9KTtcblx0fVxuXG5cdHZhciBNQVRDSCA9IHdlbGxLbm93blN5bWJvbCgnbWF0Y2gnKTtcblxuXHQvLyBgSXNSZWdFeHBgIGFic3RyYWN0IG9wZXJhdGlvblxuXHQvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1pc3JlZ2V4cFxuXHR2YXIgaXNSZWdleHAgPSBmdW5jdGlvbiAoaXQpIHtcblx0ICB2YXIgaXNSZWdFeHA7XG5cdCAgcmV0dXJuIGlzT2JqZWN0KGl0KSAmJiAoKGlzUmVnRXhwID0gaXRbTUFUQ0hdKSAhPT0gdW5kZWZpbmVkID8gISFpc1JlZ0V4cCA6IGNsYXNzb2ZSYXcoaXQpID09ICdSZWdFeHAnKTtcblx0fTtcblxuXHR2YXIgZGVmaW5lUHJvcGVydHkkNSA9IG9iamVjdERlZmluZVByb3BlcnR5LmY7XG5cdHZhciBnZXRPd25Qcm9wZXJ0eU5hbWVzID0gb2JqZWN0R2V0T3duUHJvcGVydHlOYW1lcy5mO1xuXG5cblxuXG5cblxuXG5cdHZhciBNQVRDSCQxID0gd2VsbEtub3duU3ltYm9sKCdtYXRjaCcpO1xuXHR2YXIgTmF0aXZlUmVnRXhwID0gZ2xvYmFsXzEuUmVnRXhwO1xuXHR2YXIgUmVnRXhwUHJvdG90eXBlID0gTmF0aXZlUmVnRXhwLnByb3RvdHlwZTtcblx0dmFyIHJlMSA9IC9hL2c7XG5cdHZhciByZTIgPSAvYS9nO1xuXG5cdC8vIFwibmV3XCIgc2hvdWxkIGNyZWF0ZSBhIG5ldyBvYmplY3QsIG9sZCB3ZWJraXQgYnVnXG5cdHZhciBDT1JSRUNUX05FVyA9IG5ldyBOYXRpdmVSZWdFeHAocmUxKSAhPT0gcmUxO1xuXG5cdHZhciBGT1JDRUQkNSA9IGRlc2NyaXB0b3JzICYmIGlzRm9yY2VkXzEoJ1JlZ0V4cCcsICghQ09SUkVDVF9ORVcgfHwgZmFpbHMoZnVuY3Rpb24gKCkge1xuXHQgIHJlMltNQVRDSCQxXSA9IGZhbHNlO1xuXHQgIC8vIFJlZ0V4cCBjb25zdHJ1Y3RvciBjYW4gYWx0ZXIgZmxhZ3MgYW5kIElzUmVnRXhwIHdvcmtzIGNvcnJlY3Qgd2l0aCBAQG1hdGNoXG5cdCAgcmV0dXJuIE5hdGl2ZVJlZ0V4cChyZTEpICE9IHJlMSB8fCBOYXRpdmVSZWdFeHAocmUyKSA9PSByZTIgfHwgTmF0aXZlUmVnRXhwKHJlMSwgJ2knKSAhPSAnL2EvaSc7XG5cdH0pKSk7XG5cblx0Ly8gYFJlZ0V4cGAgY29uc3RydWN0b3Jcblx0Ly8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtcmVnZXhwLWNvbnN0cnVjdG9yXG5cdGlmIChGT1JDRUQkNSkge1xuXHQgIHZhciBSZWdFeHBXcmFwcGVyID0gZnVuY3Rpb24gUmVnRXhwKHBhdHRlcm4sIGZsYWdzKSB7XG5cdCAgICB2YXIgdGhpc0lzUmVnRXhwID0gdGhpcyBpbnN0YW5jZW9mIFJlZ0V4cFdyYXBwZXI7XG5cdCAgICB2YXIgcGF0dGVybklzUmVnRXhwID0gaXNSZWdleHAocGF0dGVybik7XG5cdCAgICB2YXIgZmxhZ3NBcmVVbmRlZmluZWQgPSBmbGFncyA9PT0gdW5kZWZpbmVkO1xuXHQgICAgcmV0dXJuICF0aGlzSXNSZWdFeHAgJiYgcGF0dGVybklzUmVnRXhwICYmIHBhdHRlcm4uY29uc3RydWN0b3IgPT09IFJlZ0V4cFdyYXBwZXIgJiYgZmxhZ3NBcmVVbmRlZmluZWQgPyBwYXR0ZXJuXG5cdCAgICAgIDogaW5oZXJpdElmUmVxdWlyZWQoQ09SUkVDVF9ORVdcblx0ICAgICAgICA/IG5ldyBOYXRpdmVSZWdFeHAocGF0dGVybklzUmVnRXhwICYmICFmbGFnc0FyZVVuZGVmaW5lZCA/IHBhdHRlcm4uc291cmNlIDogcGF0dGVybiwgZmxhZ3MpXG5cdCAgICAgICAgOiBOYXRpdmVSZWdFeHAoKHBhdHRlcm5Jc1JlZ0V4cCA9IHBhdHRlcm4gaW5zdGFuY2VvZiBSZWdFeHBXcmFwcGVyKVxuXHQgICAgICAgICAgPyBwYXR0ZXJuLnNvdXJjZVxuXHQgICAgICAgICAgOiBwYXR0ZXJuLCBwYXR0ZXJuSXNSZWdFeHAgJiYgZmxhZ3NBcmVVbmRlZmluZWQgPyByZWdleHBGbGFncy5jYWxsKHBhdHRlcm4pIDogZmxhZ3MpXG5cdCAgICAgICwgdGhpc0lzUmVnRXhwID8gdGhpcyA6IFJlZ0V4cFByb3RvdHlwZSwgUmVnRXhwV3JhcHBlcik7XG5cdCAgfTtcblx0ICB2YXIgcHJveHkgPSBmdW5jdGlvbiAoa2V5KSB7XG5cdCAgICBrZXkgaW4gUmVnRXhwV3JhcHBlciB8fCBkZWZpbmVQcm9wZXJ0eSQ1KFJlZ0V4cFdyYXBwZXIsIGtleSwge1xuXHQgICAgICBjb25maWd1cmFibGU6IHRydWUsXG5cdCAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gTmF0aXZlUmVnRXhwW2tleV07IH0sXG5cdCAgICAgIHNldDogZnVuY3Rpb24gKGl0KSB7IE5hdGl2ZVJlZ0V4cFtrZXldID0gaXQ7IH1cblx0ICAgIH0pO1xuXHQgIH07XG5cdCAgdmFyIGtleXMkMSA9IGdldE93blByb3BlcnR5TmFtZXMoTmF0aXZlUmVnRXhwKTtcblx0ICB2YXIgaW5kZXggPSAwO1xuXHQgIHdoaWxlIChrZXlzJDEubGVuZ3RoID4gaW5kZXgpIHByb3h5KGtleXMkMVtpbmRleCsrXSk7XG5cdCAgUmVnRXhwUHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUmVnRXhwV3JhcHBlcjtcblx0ICBSZWdFeHBXcmFwcGVyLnByb3RvdHlwZSA9IFJlZ0V4cFByb3RvdHlwZTtcblx0ICByZWRlZmluZShnbG9iYWxfMSwgJ1JlZ0V4cCcsIFJlZ0V4cFdyYXBwZXIpO1xuXHR9XG5cblx0Ly8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtZ2V0LXJlZ2V4cC1AQHNwZWNpZXNcblx0c2V0U3BlY2llcygnUmVnRXhwJyk7XG5cblx0dmFyIGNvZGVBdCA9IHN0cmluZ011bHRpYnl0ZS5jb2RlQXQ7XG5cblx0Ly8gYFN0cmluZy5wcm90b3R5cGUuY29kZVBvaW50QXRgIG1ldGhvZFxuXHQvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1zdHJpbmcucHJvdG90eXBlLmNvZGVwb2ludGF0XG5cdF9leHBvcnQoeyB0YXJnZXQ6ICdTdHJpbmcnLCBwcm90bzogdHJ1ZSB9LCB7XG5cdCAgY29kZVBvaW50QXQ6IGZ1bmN0aW9uIGNvZGVQb2ludEF0KHBvcykge1xuXHQgICAgcmV0dXJuIGNvZGVBdCh0aGlzLCBwb3MpO1xuXHQgIH1cblx0fSk7XG5cblx0dmFyIGNvZGVQb2ludEF0ID0gZW50cnlVbmJpbmQoJ1N0cmluZycsICdjb2RlUG9pbnRBdCcpO1xuXG5cdHZhciBub3RBUmVnZXhwID0gZnVuY3Rpb24gKGl0KSB7XG5cdCAgaWYgKGlzUmVnZXhwKGl0KSkge1xuXHQgICAgdGhyb3cgVHlwZUVycm9yKFwiVGhlIG1ldGhvZCBkb2Vzbid0IGFjY2VwdCByZWd1bGFyIGV4cHJlc3Npb25zXCIpO1xuXHQgIH0gcmV0dXJuIGl0O1xuXHR9O1xuXG5cdHZhciBNQVRDSCQyID0gd2VsbEtub3duU3ltYm9sKCdtYXRjaCcpO1xuXG5cdHZhciBjb3JyZWN0SXNSZWdleHBMb2dpYyA9IGZ1bmN0aW9uIChNRVRIT0RfTkFNRSkge1xuXHQgIHZhciByZWdleHAgPSAvLi87XG5cdCAgdHJ5IHtcblx0ICAgICcvLi8nW01FVEhPRF9OQU1FXShyZWdleHApO1xuXHQgIH0gY2F0Y2ggKGUpIHtcblx0ICAgIHRyeSB7XG5cdCAgICAgIHJlZ2V4cFtNQVRDSCQyXSA9IGZhbHNlO1xuXHQgICAgICByZXR1cm4gJy8uLydbTUVUSE9EX05BTUVdKHJlZ2V4cCk7XG5cdCAgICB9IGNhdGNoIChmKSB7IC8qIGVtcHR5ICovIH1cblx0ICB9IHJldHVybiBmYWxzZTtcblx0fTtcblxuXHQvLyBgU3RyaW5nLnByb3RvdHlwZS5pbmNsdWRlc2AgbWV0aG9kXG5cdC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXN0cmluZy5wcm90b3R5cGUuaW5jbHVkZXNcblx0X2V4cG9ydCh7IHRhcmdldDogJ1N0cmluZycsIHByb3RvOiB0cnVlLCBmb3JjZWQ6ICFjb3JyZWN0SXNSZWdleHBMb2dpYygnaW5jbHVkZXMnKSB9LCB7XG5cdCAgaW5jbHVkZXM6IGZ1bmN0aW9uIGluY2x1ZGVzKHNlYXJjaFN0cmluZyAvKiAsIHBvc2l0aW9uID0gMCAqLykge1xuXHQgICAgcmV0dXJuICEhflN0cmluZyhyZXF1aXJlT2JqZWN0Q29lcmNpYmxlKHRoaXMpKVxuXHQgICAgICAuaW5kZXhPZihub3RBUmVnZXhwKHNlYXJjaFN0cmluZyksIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKTtcblx0ICB9XG5cdH0pO1xuXG5cdHZhciBpbmNsdWRlcyA9IGVudHJ5VW5iaW5kKCdTdHJpbmcnLCAnaW5jbHVkZXMnKTtcblxuXHR2YXIgbmF0aXZlRW5kc1dpdGggPSAnJy5lbmRzV2l0aDtcblx0dmFyIG1pbiQzID0gTWF0aC5taW47XG5cblx0Ly8gYFN0cmluZy5wcm90b3R5cGUuZW5kc1dpdGhgIG1ldGhvZFxuXHQvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1zdHJpbmcucHJvdG90eXBlLmVuZHN3aXRoXG5cdF9leHBvcnQoeyB0YXJnZXQ6ICdTdHJpbmcnLCBwcm90bzogdHJ1ZSwgZm9yY2VkOiAhY29ycmVjdElzUmVnZXhwTG9naWMoJ2VuZHNXaXRoJykgfSwge1xuXHQgIGVuZHNXaXRoOiBmdW5jdGlvbiBlbmRzV2l0aChzZWFyY2hTdHJpbmcgLyogLCBlbmRQb3NpdGlvbiA9IEBsZW5ndGggKi8pIHtcblx0ICAgIHZhciB0aGF0ID0gU3RyaW5nKHJlcXVpcmVPYmplY3RDb2VyY2libGUodGhpcykpO1xuXHQgICAgbm90QVJlZ2V4cChzZWFyY2hTdHJpbmcpO1xuXHQgICAgdmFyIGVuZFBvc2l0aW9uID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQ7XG5cdCAgICB2YXIgbGVuID0gdG9MZW5ndGgodGhhdC5sZW5ndGgpO1xuXHQgICAgdmFyIGVuZCA9IGVuZFBvc2l0aW9uID09PSB1bmRlZmluZWQgPyBsZW4gOiBtaW4kMyh0b0xlbmd0aChlbmRQb3NpdGlvbiksIGxlbik7XG5cdCAgICB2YXIgc2VhcmNoID0gU3RyaW5nKHNlYXJjaFN0cmluZyk7XG5cdCAgICByZXR1cm4gbmF0aXZlRW5kc1dpdGhcblx0ICAgICAgPyBuYXRpdmVFbmRzV2l0aC5jYWxsKHRoYXQsIHNlYXJjaCwgZW5kKVxuXHQgICAgICA6IHRoYXQuc2xpY2UoZW5kIC0gc2VhcmNoLmxlbmd0aCwgZW5kKSA9PT0gc2VhcmNoO1xuXHQgIH1cblx0fSk7XG5cblx0dmFyIGVuZHNXaXRoID0gZW50cnlVbmJpbmQoJ1N0cmluZycsICdlbmRzV2l0aCcpO1xuXG5cdC8vIGBTdHJpbmcucHJvdG90eXBlLnJlcGVhdGAgbWV0aG9kIGltcGxlbWVudGF0aW9uXG5cdC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXN0cmluZy5wcm90b3R5cGUucmVwZWF0XG5cdHZhciBzdHJpbmdSZXBlYXQgPSAnJy5yZXBlYXQgfHwgZnVuY3Rpb24gcmVwZWF0KGNvdW50KSB7XG5cdCAgdmFyIHN0ciA9IFN0cmluZyhyZXF1aXJlT2JqZWN0Q29lcmNpYmxlKHRoaXMpKTtcblx0ICB2YXIgcmVzdWx0ID0gJyc7XG5cdCAgdmFyIG4gPSB0b0ludGVnZXIoY291bnQpO1xuXHQgIGlmIChuIDwgMCB8fCBuID09IEluZmluaXR5KSB0aHJvdyBSYW5nZUVycm9yKCdXcm9uZyBudW1iZXIgb2YgcmVwZXRpdGlvbnMnKTtcblx0ICBmb3IgKDtuID4gMDsgKG4gPj4+PSAxKSAmJiAoc3RyICs9IHN0cikpIGlmIChuICYgMSkgcmVzdWx0ICs9IHN0cjtcblx0ICByZXR1cm4gcmVzdWx0O1xuXHR9O1xuXG5cdC8vIGBTdHJpbmcucHJvdG90eXBlLnJlcGVhdGAgbWV0aG9kXG5cdC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXN0cmluZy5wcm90b3R5cGUucmVwZWF0XG5cdF9leHBvcnQoeyB0YXJnZXQ6ICdTdHJpbmcnLCBwcm90bzogdHJ1ZSB9LCB7XG5cdCAgcmVwZWF0OiBzdHJpbmdSZXBlYXRcblx0fSk7XG5cblx0dmFyIHJlcGVhdCA9IGVudHJ5VW5iaW5kKCdTdHJpbmcnLCAncmVwZWF0Jyk7XG5cblx0dmFyIG5hdGl2ZVN0YXJ0c1dpdGggPSAnJy5zdGFydHNXaXRoO1xuXHR2YXIgbWluJDQgPSBNYXRoLm1pbjtcblxuXHQvLyBgU3RyaW5nLnByb3RvdHlwZS5zdGFydHNXaXRoYCBtZXRob2Rcblx0Ly8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtc3RyaW5nLnByb3RvdHlwZS5zdGFydHN3aXRoXG5cdF9leHBvcnQoeyB0YXJnZXQ6ICdTdHJpbmcnLCBwcm90bzogdHJ1ZSwgZm9yY2VkOiAhY29ycmVjdElzUmVnZXhwTG9naWMoJ3N0YXJ0c1dpdGgnKSB9LCB7XG5cdCAgc3RhcnRzV2l0aDogZnVuY3Rpb24gc3RhcnRzV2l0aChzZWFyY2hTdHJpbmcgLyogLCBwb3NpdGlvbiA9IDAgKi8pIHtcblx0ICAgIHZhciB0aGF0ID0gU3RyaW5nKHJlcXVpcmVPYmplY3RDb2VyY2libGUodGhpcykpO1xuXHQgICAgbm90QVJlZ2V4cChzZWFyY2hTdHJpbmcpO1xuXHQgICAgdmFyIGluZGV4ID0gdG9MZW5ndGgobWluJDQoYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQsIHRoYXQubGVuZ3RoKSk7XG5cdCAgICB2YXIgc2VhcmNoID0gU3RyaW5nKHNlYXJjaFN0cmluZyk7XG5cdCAgICByZXR1cm4gbmF0aXZlU3RhcnRzV2l0aFxuXHQgICAgICA/IG5hdGl2ZVN0YXJ0c1dpdGguY2FsbCh0aGF0LCBzZWFyY2gsIGluZGV4KVxuXHQgICAgICA6IHRoYXQuc2xpY2UoaW5kZXgsIGluZGV4ICsgc2VhcmNoLmxlbmd0aCkgPT09IHNlYXJjaDtcblx0ICB9XG5cdH0pO1xuXG5cdHZhciBzdGFydHNXaXRoID0gZW50cnlVbmJpbmQoJ1N0cmluZycsICdzdGFydHNXaXRoJyk7XG5cblx0dmFyIHF1b3QgPSAvXCIvZztcblxuXHQvLyBCLjIuMy4yLjEgQ3JlYXRlSFRNTChzdHJpbmcsIHRhZywgYXR0cmlidXRlLCB2YWx1ZSlcblx0Ly8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtY3JlYXRlaHRtbFxuXHR2YXIgY3JlYXRlSHRtbCA9IGZ1bmN0aW9uIChzdHJpbmcsIHRhZywgYXR0cmlidXRlLCB2YWx1ZSkge1xuXHQgIHZhciBTID0gU3RyaW5nKHJlcXVpcmVPYmplY3RDb2VyY2libGUoc3RyaW5nKSk7XG5cdCAgdmFyIHAxID0gJzwnICsgdGFnO1xuXHQgIGlmIChhdHRyaWJ1dGUgIT09ICcnKSBwMSArPSAnICcgKyBhdHRyaWJ1dGUgKyAnPVwiJyArIFN0cmluZyh2YWx1ZSkucmVwbGFjZShxdW90LCAnJnF1b3Q7JykgKyAnXCInO1xuXHQgIHJldHVybiBwMSArICc+JyArIFMgKyAnPC8nICsgdGFnICsgJz4nO1xuXHR9O1xuXG5cdC8vIGNoZWNrIHRoZSBleGlzdGVuY2Ugb2YgYSBtZXRob2QsIGxvd2VyY2FzZVxuXHQvLyBvZiBhIHRhZyBhbmQgZXNjYXBpbmcgcXVvdGVzIGluIGFyZ3VtZW50c1xuXHR2YXIgZm9yY2VkU3RyaW5nSHRtbE1ldGhvZCA9IGZ1bmN0aW9uIChNRVRIT0RfTkFNRSkge1xuXHQgIHJldHVybiBmYWlscyhmdW5jdGlvbiAoKSB7XG5cdCAgICB2YXIgdGVzdCA9ICcnW01FVEhPRF9OQU1FXSgnXCInKTtcblx0ICAgIHJldHVybiB0ZXN0ICE9PSB0ZXN0LnRvTG93ZXJDYXNlKCkgfHwgdGVzdC5zcGxpdCgnXCInKS5sZW5ndGggPiAzO1xuXHQgIH0pO1xuXHR9O1xuXG5cdC8vIGBTdHJpbmcucHJvdG90eXBlLmFuY2hvcmAgbWV0aG9kXG5cdC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXN0cmluZy5wcm90b3R5cGUuYW5jaG9yXG5cdF9leHBvcnQoeyB0YXJnZXQ6ICdTdHJpbmcnLCBwcm90bzogdHJ1ZSwgZm9yY2VkOiBmb3JjZWRTdHJpbmdIdG1sTWV0aG9kKCdhbmNob3InKSB9LCB7XG5cdCAgYW5jaG9yOiBmdW5jdGlvbiBhbmNob3IobmFtZSkge1xuXHQgICAgcmV0dXJuIGNyZWF0ZUh0bWwodGhpcywgJ2EnLCAnbmFtZScsIG5hbWUpO1xuXHQgIH1cblx0fSk7XG5cblx0dmFyIGFuY2hvciA9IGVudHJ5VW5iaW5kKCdTdHJpbmcnLCAnYW5jaG9yJyk7XG5cblx0Ly8gYFN0cmluZy5wcm90b3R5cGUuYmxpbmtgIG1ldGhvZFxuXHQvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1zdHJpbmcucHJvdG90eXBlLmJsaW5rXG5cdF9leHBvcnQoeyB0YXJnZXQ6ICdTdHJpbmcnLCBwcm90bzogdHJ1ZSwgZm9yY2VkOiBmb3JjZWRTdHJpbmdIdG1sTWV0aG9kKCdibGluaycpIH0sIHtcblx0ICBibGluazogZnVuY3Rpb24gYmxpbmsoKSB7XG5cdCAgICByZXR1cm4gY3JlYXRlSHRtbCh0aGlzLCAnYmxpbmsnLCAnJywgJycpO1xuXHQgIH1cblx0fSk7XG5cblx0dmFyIGJsaW5rID0gZW50cnlVbmJpbmQoJ1N0cmluZycsICdibGluaycpO1xuXG5cdC8vIGBTdHJpbmcucHJvdG90eXBlLmJvbGRgIG1ldGhvZFxuXHQvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1zdHJpbmcucHJvdG90eXBlLmJvbGRcblx0X2V4cG9ydCh7IHRhcmdldDogJ1N0cmluZycsIHByb3RvOiB0cnVlLCBmb3JjZWQ6IGZvcmNlZFN0cmluZ0h0bWxNZXRob2QoJ2JvbGQnKSB9LCB7XG5cdCAgYm9sZDogZnVuY3Rpb24gYm9sZCgpIHtcblx0ICAgIHJldHVybiBjcmVhdGVIdG1sKHRoaXMsICdiJywgJycsICcnKTtcblx0ICB9XG5cdH0pO1xuXG5cdHZhciBib2xkID0gZW50cnlVbmJpbmQoJ1N0cmluZycsICdib2xkJyk7XG5cblx0Ly8gYFN0cmluZy5wcm90b3R5cGUuZml4ZWRgIG1ldGhvZFxuXHQvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1zdHJpbmcucHJvdG90eXBlLmZpeGVkXG5cdF9leHBvcnQoeyB0YXJnZXQ6ICdTdHJpbmcnLCBwcm90bzogdHJ1ZSwgZm9yY2VkOiBmb3JjZWRTdHJpbmdIdG1sTWV0aG9kKCdmaXhlZCcpIH0sIHtcblx0ICBmaXhlZDogZnVuY3Rpb24gZml4ZWQoKSB7XG5cdCAgICByZXR1cm4gY3JlYXRlSHRtbCh0aGlzLCAndHQnLCAnJywgJycpO1xuXHQgIH1cblx0fSk7XG5cblx0dmFyIGZpeGVkID0gZW50cnlVbmJpbmQoJ1N0cmluZycsICdmaXhlZCcpO1xuXG5cdC8vIGBTdHJpbmcucHJvdG90eXBlLmZvbnRjb2xvcmAgbWV0aG9kXG5cdC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXN0cmluZy5wcm90b3R5cGUuZm9udGNvbG9yXG5cdF9leHBvcnQoeyB0YXJnZXQ6ICdTdHJpbmcnLCBwcm90bzogdHJ1ZSwgZm9yY2VkOiBmb3JjZWRTdHJpbmdIdG1sTWV0aG9kKCdmb250Y29sb3InKSB9LCB7XG5cdCAgZm9udGNvbG9yOiBmdW5jdGlvbiBmb250Y29sb3IoY29sb3IpIHtcblx0ICAgIHJldHVybiBjcmVhdGVIdG1sKHRoaXMsICdmb250JywgJ2NvbG9yJywgY29sb3IpO1xuXHQgIH1cblx0fSk7XG5cblx0dmFyIGZvbnRjb2xvciA9IGVudHJ5VW5iaW5kKCdTdHJpbmcnLCAnZm9udGNvbG9yJyk7XG5cblx0Ly8gYFN0cmluZy5wcm90b3R5cGUuZm9udHNpemVgIG1ldGhvZFxuXHQvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1zdHJpbmcucHJvdG90eXBlLmZvbnRzaXplXG5cdF9leHBvcnQoeyB0YXJnZXQ6ICdTdHJpbmcnLCBwcm90bzogdHJ1ZSwgZm9yY2VkOiBmb3JjZWRTdHJpbmdIdG1sTWV0aG9kKCdmb250c2l6ZScpIH0sIHtcblx0ICBmb250c2l6ZTogZnVuY3Rpb24gZm9udHNpemUoc2l6ZSkge1xuXHQgICAgcmV0dXJuIGNyZWF0ZUh0bWwodGhpcywgJ2ZvbnQnLCAnc2l6ZScsIHNpemUpO1xuXHQgIH1cblx0fSk7XG5cblx0dmFyIGZvbnRzaXplID0gZW50cnlVbmJpbmQoJ1N0cmluZycsICdmb250c2l6ZScpO1xuXG5cdC8vIGBTdHJpbmcucHJvdG90eXBlLml0YWxpY3NgIG1ldGhvZFxuXHQvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1zdHJpbmcucHJvdG90eXBlLml0YWxpY3Ncblx0X2V4cG9ydCh7IHRhcmdldDogJ1N0cmluZycsIHByb3RvOiB0cnVlLCBmb3JjZWQ6IGZvcmNlZFN0cmluZ0h0bWxNZXRob2QoJ2l0YWxpY3MnKSB9LCB7XG5cdCAgaXRhbGljczogZnVuY3Rpb24gaXRhbGljcygpIHtcblx0ICAgIHJldHVybiBjcmVhdGVIdG1sKHRoaXMsICdpJywgJycsICcnKTtcblx0ICB9XG5cdH0pO1xuXG5cdHZhciBpdGFsaWNzID0gZW50cnlVbmJpbmQoJ1N0cmluZycsICdpdGFsaWNzJyk7XG5cblx0Ly8gYFN0cmluZy5wcm90b3R5cGUubGlua2AgbWV0aG9kXG5cdC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXN0cmluZy5wcm90b3R5cGUubGlua1xuXHRfZXhwb3J0KHsgdGFyZ2V0OiAnU3RyaW5nJywgcHJvdG86IHRydWUsIGZvcmNlZDogZm9yY2VkU3RyaW5nSHRtbE1ldGhvZCgnbGluaycpIH0sIHtcblx0ICBsaW5rOiBmdW5jdGlvbiBsaW5rKHVybCkge1xuXHQgICAgcmV0dXJuIGNyZWF0ZUh0bWwodGhpcywgJ2EnLCAnaHJlZicsIHVybCk7XG5cdCAgfVxuXHR9KTtcblxuXHR2YXIgbGluayA9IGVudHJ5VW5iaW5kKCdTdHJpbmcnLCAnbGluaycpO1xuXG5cdC8vIGBTdHJpbmcucHJvdG90eXBlLnNtYWxsYCBtZXRob2Rcblx0Ly8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtc3RyaW5nLnByb3RvdHlwZS5zbWFsbFxuXHRfZXhwb3J0KHsgdGFyZ2V0OiAnU3RyaW5nJywgcHJvdG86IHRydWUsIGZvcmNlZDogZm9yY2VkU3RyaW5nSHRtbE1ldGhvZCgnc21hbGwnKSB9LCB7XG5cdCAgc21hbGw6IGZ1bmN0aW9uIHNtYWxsKCkge1xuXHQgICAgcmV0dXJuIGNyZWF0ZUh0bWwodGhpcywgJ3NtYWxsJywgJycsICcnKTtcblx0ICB9XG5cdH0pO1xuXG5cdHZhciBzbWFsbCA9IGVudHJ5VW5iaW5kKCdTdHJpbmcnLCAnc21hbGwnKTtcblxuXHQvLyBgU3RyaW5nLnByb3RvdHlwZS5zdHJpa2VgIG1ldGhvZFxuXHQvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1zdHJpbmcucHJvdG90eXBlLnN0cmlrZVxuXHRfZXhwb3J0KHsgdGFyZ2V0OiAnU3RyaW5nJywgcHJvdG86IHRydWUsIGZvcmNlZDogZm9yY2VkU3RyaW5nSHRtbE1ldGhvZCgnc3RyaWtlJykgfSwge1xuXHQgIHN0cmlrZTogZnVuY3Rpb24gc3RyaWtlKCkge1xuXHQgICAgcmV0dXJuIGNyZWF0ZUh0bWwodGhpcywgJ3N0cmlrZScsICcnLCAnJyk7XG5cdCAgfVxuXHR9KTtcblxuXHR2YXIgc3RyaWtlID0gZW50cnlVbmJpbmQoJ1N0cmluZycsICdzdHJpa2UnKTtcblxuXHQvLyBgU3RyaW5nLnByb3RvdHlwZS5zdWJgIG1ldGhvZFxuXHQvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1zdHJpbmcucHJvdG90eXBlLnN1YlxuXHRfZXhwb3J0KHsgdGFyZ2V0OiAnU3RyaW5nJywgcHJvdG86IHRydWUsIGZvcmNlZDogZm9yY2VkU3RyaW5nSHRtbE1ldGhvZCgnc3ViJykgfSwge1xuXHQgIHN1YjogZnVuY3Rpb24gc3ViKCkge1xuXHQgICAgcmV0dXJuIGNyZWF0ZUh0bWwodGhpcywgJ3N1YicsICcnLCAnJyk7XG5cdCAgfVxuXHR9KTtcblxuXHR2YXIgc3ViID0gZW50cnlVbmJpbmQoJ1N0cmluZycsICdzdWInKTtcblxuXHQvLyBgU3RyaW5nLnByb3RvdHlwZS5zdXBgIG1ldGhvZFxuXHQvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1zdHJpbmcucHJvdG90eXBlLnN1cFxuXHRfZXhwb3J0KHsgdGFyZ2V0OiAnU3RyaW5nJywgcHJvdG86IHRydWUsIGZvcmNlZDogZm9yY2VkU3RyaW5nSHRtbE1ldGhvZCgnc3VwJykgfSwge1xuXHQgIHN1cDogZnVuY3Rpb24gc3VwKCkge1xuXHQgICAgcmV0dXJuIGNyZWF0ZUh0bWwodGhpcywgJ3N1cCcsICcnLCAnJyk7XG5cdCAgfVxuXHR9KTtcblxuXHR2YXIgc3VwID0gZW50cnlVbmJpbmQoJ1N0cmluZycsICdzdXAnKTtcblxuXHR2YXIgZnJvbUNoYXJDb2RlID0gU3RyaW5nLmZyb21DaGFyQ29kZTtcblx0dmFyIG5hdGl2ZUZyb21Db2RlUG9pbnQgPSBTdHJpbmcuZnJvbUNvZGVQb2ludDtcblxuXHQvLyBsZW5ndGggc2hvdWxkIGJlIDEsIG9sZCBGRiBwcm9ibGVtXG5cdHZhciBJTkNPUlJFQ1RfTEVOR1RIID0gISFuYXRpdmVGcm9tQ29kZVBvaW50ICYmIG5hdGl2ZUZyb21Db2RlUG9pbnQubGVuZ3RoICE9IDE7XG5cblx0Ly8gYFN0cmluZy5mcm9tQ29kZVBvaW50YCBtZXRob2Rcblx0Ly8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtc3RyaW5nLmZyb21jb2RlcG9pbnRcblx0X2V4cG9ydCh7IHRhcmdldDogJ1N0cmluZycsIHN0YXQ6IHRydWUsIGZvcmNlZDogSU5DT1JSRUNUX0xFTkdUSCB9LCB7XG5cdCAgZnJvbUNvZGVQb2ludDogZnVuY3Rpb24gZnJvbUNvZGVQb2ludCh4KSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcblx0ICAgIHZhciBlbGVtZW50cyA9IFtdO1xuXHQgICAgdmFyIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGg7XG5cdCAgICB2YXIgaSA9IDA7XG5cdCAgICB2YXIgY29kZTtcblx0ICAgIHdoaWxlIChsZW5ndGggPiBpKSB7XG5cdCAgICAgIGNvZGUgPSArYXJndW1lbnRzW2krK107XG5cdCAgICAgIGlmICh0b0Fic29sdXRlSW5kZXgoY29kZSwgMHgxMEZGRkYpICE9PSBjb2RlKSB0aHJvdyBSYW5nZUVycm9yKGNvZGUgKyAnIGlzIG5vdCBhIHZhbGlkIGNvZGUgcG9pbnQnKTtcblx0ICAgICAgZWxlbWVudHMucHVzaChjb2RlIDwgMHgxMDAwMFxuXHQgICAgICAgID8gZnJvbUNoYXJDb2RlKGNvZGUpXG5cdCAgICAgICAgOiBmcm9tQ2hhckNvZGUoKChjb2RlIC09IDB4MTAwMDApID4+IDEwKSArIDB4RDgwMCwgY29kZSAlIDB4NDAwICsgMHhEQzAwKVxuXHQgICAgICApO1xuXHQgICAgfSByZXR1cm4gZWxlbWVudHMuam9pbignJyk7XG5cdCAgfVxuXHR9KTtcblxuXHR2YXIgZnJvbUNvZGVQb2ludCA9IHBhdGguU3RyaW5nLmZyb21Db2RlUG9pbnQ7XG5cblx0Ly8gYFN0cmluZy5yYXdgIG1ldGhvZFxuXHQvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1zdHJpbmcucmF3XG5cdF9leHBvcnQoeyB0YXJnZXQ6ICdTdHJpbmcnLCBzdGF0OiB0cnVlIH0sIHtcblx0ICByYXc6IGZ1bmN0aW9uIHJhdyh0ZW1wbGF0ZSkge1xuXHQgICAgdmFyIHJhd1RlbXBsYXRlID0gdG9JbmRleGVkT2JqZWN0KHRlbXBsYXRlLnJhdyk7XG5cdCAgICB2YXIgbGl0ZXJhbFNlZ21lbnRzID0gdG9MZW5ndGgocmF3VGVtcGxhdGUubGVuZ3RoKTtcblx0ICAgIHZhciBhcmd1bWVudHNMZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoO1xuXHQgICAgdmFyIGVsZW1lbnRzID0gW107XG5cdCAgICB2YXIgaSA9IDA7XG5cdCAgICB3aGlsZSAobGl0ZXJhbFNlZ21lbnRzID4gaSkge1xuXHQgICAgICBlbGVtZW50cy5wdXNoKFN0cmluZyhyYXdUZW1wbGF0ZVtpKytdKSk7XG5cdCAgICAgIGlmIChpIDwgYXJndW1lbnRzTGVuZ3RoKSBlbGVtZW50cy5wdXNoKFN0cmluZyhhcmd1bWVudHNbaV0pKTtcblx0ICAgIH0gcmV0dXJuIGVsZW1lbnRzLmpvaW4oJycpO1xuXHQgIH1cblx0fSk7XG5cblx0dmFyIHJhdyA9IHBhdGguU3RyaW5nLnJhdztcblxuXHR2YXIgZXMyMDE1Q29yZSA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuXHR9KTtcblxuXHR1bndyYXBFeHBvcnRzKGVzMjAxNUNvcmUpO1xuXG5cdC8vIGBTeW1ib2wuaXRlcmF0b3JgIHdlbGwta25vd24gc3ltYm9sXG5cdC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXN5bWJvbC5pdGVyYXRvclxuXHRkZWZpbmVXZWxsS25vd25TeW1ib2woJ2l0ZXJhdG9yJyk7XG5cblx0dmFyIGl0ZXJhdG9yID0gd3JhcHBlZFdlbGxLbm93blN5bWJvbC5mKCdpdGVyYXRvcicpO1xuXG5cdHZhciBpdGVyYXRvciQxID0gZW50cnlVbmJpbmQoJ0FycmF5JywgJ3ZhbHVlcycpO1xuXG5cdHZhciBlbnRyaWVzID0gZW50cnlVbmJpbmQoJ0FycmF5JywgJ2VudHJpZXMnKTtcblxuXHR2YXIga2V5cyQyID0gZW50cnlVbmJpbmQoJ0FycmF5JywgJ2tleXMnKTtcblxuXHR2YXIgdmFsdWVzID0gZW50cnlVbmJpbmQoJ0FycmF5JywgJ3ZhbHVlcycpO1xuXG5cdHZhciBJVEVSQVRPUiQ2ID0gd2VsbEtub3duU3ltYm9sKCdpdGVyYXRvcicpO1xuXHR2YXIgVWludDhBcnJheSA9IGdsb2JhbF8xLlVpbnQ4QXJyYXk7XG5cdHZhciBhcnJheVZhbHVlcyA9IGVzX2FycmF5X2l0ZXJhdG9yLnZhbHVlcztcblx0dmFyIGFycmF5S2V5cyA9IGVzX2FycmF5X2l0ZXJhdG9yLmtleXM7XG5cdHZhciBhcnJheUVudHJpZXMgPSBlc19hcnJheV9pdGVyYXRvci5lbnRyaWVzO1xuXHR2YXIgYVR5cGVkQXJyYXkkNSA9IGFycmF5QnVmZmVyVmlld0NvcmUuYVR5cGVkQXJyYXk7XG5cdHZhciBleHBvcnRQcm90byQxID0gYXJyYXlCdWZmZXJWaWV3Q29yZS5leHBvcnRQcm90bztcblx0dmFyIG5hdGl2ZVR5cGVkQXJyYXlJdGVyYXRvciA9IFVpbnQ4QXJyYXkgJiYgVWludDhBcnJheS5wcm90b3R5cGVbSVRFUkFUT1IkNl07XG5cblx0dmFyIENPUlJFQ1RfSVRFUl9OQU1FID0gISFuYXRpdmVUeXBlZEFycmF5SXRlcmF0b3Jcblx0ICAmJiAobmF0aXZlVHlwZWRBcnJheUl0ZXJhdG9yLm5hbWUgPT0gJ3ZhbHVlcycgfHwgbmF0aXZlVHlwZWRBcnJheUl0ZXJhdG9yLm5hbWUgPT0gdW5kZWZpbmVkKTtcblxuXHR2YXIgdHlwZWRBcnJheVZhbHVlcyA9IGZ1bmN0aW9uIHZhbHVlcygpIHtcblx0ICByZXR1cm4gYXJyYXlWYWx1ZXMuY2FsbChhVHlwZWRBcnJheSQ1KHRoaXMpKTtcblx0fTtcblxuXHQvLyBgJVR5cGVkQXJyYXklLnByb3RvdHlwZS5lbnRyaWVzYCBtZXRob2Rcblx0Ly8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtJXR5cGVkYXJyYXklLnByb3RvdHlwZS5lbnRyaWVzXG5cdGV4cG9ydFByb3RvJDEoJ2VudHJpZXMnLCBmdW5jdGlvbiBlbnRyaWVzKCkge1xuXHQgIHJldHVybiBhcnJheUVudHJpZXMuY2FsbChhVHlwZWRBcnJheSQ1KHRoaXMpKTtcblx0fSk7XG5cdC8vIGAlVHlwZWRBcnJheSUucHJvdG90eXBlLmtleXNgIG1ldGhvZFxuXHQvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy0ldHlwZWRhcnJheSUucHJvdG90eXBlLmtleXNcblx0ZXhwb3J0UHJvdG8kMSgna2V5cycsIGZ1bmN0aW9uIGtleXMoKSB7XG5cdCAgcmV0dXJuIGFycmF5S2V5cy5jYWxsKGFUeXBlZEFycmF5JDUodGhpcykpO1xuXHR9KTtcblx0Ly8gYCVUeXBlZEFycmF5JS5wcm90b3R5cGUudmFsdWVzYCBtZXRob2Rcblx0Ly8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtJXR5cGVkYXJyYXklLnByb3RvdHlwZS52YWx1ZXNcblx0ZXhwb3J0UHJvdG8kMSgndmFsdWVzJywgdHlwZWRBcnJheVZhbHVlcywgIUNPUlJFQ1RfSVRFUl9OQU1FKTtcblx0Ly8gYCVUeXBlZEFycmF5JS5wcm90b3R5cGVbQEBpdGVyYXRvcl1gIG1ldGhvZFxuXHQvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy0ldHlwZWRhcnJheSUucHJvdG90eXBlLUBAaXRlcmF0b3Jcblx0ZXhwb3J0UHJvdG8kMShJVEVSQVRPUiQ2LCB0eXBlZEFycmF5VmFsdWVzLCAhQ09SUkVDVF9JVEVSX05BTUUpO1xuXG5cdHZhciBlczIwMTVJdGVyYWJsZSA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuXHR9KTtcblxuXHR1bndyYXBFeHBvcnRzKGVzMjAxNUl0ZXJhYmxlKTtcblxuXHR2YXIgbmF0aXZlUHJvbWlzZUNvbnN0cnVjdG9yID0gZ2xvYmFsXzEuUHJvbWlzZTtcblxuXHR2YXIgU1BFQ0lFUyQyID0gd2VsbEtub3duU3ltYm9sKCdzcGVjaWVzJyk7XG5cblx0Ly8gYFNwZWNpZXNDb25zdHJ1Y3RvcmAgYWJzdHJhY3Qgb3BlcmF0aW9uXG5cdC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXNwZWNpZXNjb25zdHJ1Y3RvclxuXHR2YXIgc3BlY2llc0NvbnN0cnVjdG9yID0gZnVuY3Rpb24gKE8sIGRlZmF1bHRDb25zdHJ1Y3Rvcikge1xuXHQgIHZhciBDID0gYW5PYmplY3QoTykuY29uc3RydWN0b3I7XG5cdCAgdmFyIFM7XG5cdCAgcmV0dXJuIEMgPT09IHVuZGVmaW5lZCB8fCAoUyA9IGFuT2JqZWN0KEMpW1NQRUNJRVMkMl0pID09IHVuZGVmaW5lZCA/IGRlZmF1bHRDb25zdHJ1Y3RvciA6IGFGdW5jdGlvbiQxKFMpO1xuXHR9O1xuXG5cdHZhciBsb2NhdGlvbiA9IGdsb2JhbF8xLmxvY2F0aW9uO1xuXHR2YXIgc2V0JDIgPSBnbG9iYWxfMS5zZXRJbW1lZGlhdGU7XG5cdHZhciBjbGVhciA9IGdsb2JhbF8xLmNsZWFySW1tZWRpYXRlO1xuXHR2YXIgcHJvY2VzcyA9IGdsb2JhbF8xLnByb2Nlc3M7XG5cdHZhciBNZXNzYWdlQ2hhbm5lbCA9IGdsb2JhbF8xLk1lc3NhZ2VDaGFubmVsO1xuXHR2YXIgRGlzcGF0Y2ggPSBnbG9iYWxfMS5EaXNwYXRjaDtcblx0dmFyIGNvdW50ZXIgPSAwO1xuXHR2YXIgcXVldWUgPSB7fTtcblx0dmFyIE9OUkVBRFlTVEFURUNIQU5HRSA9ICdvbnJlYWR5c3RhdGVjaGFuZ2UnO1xuXHR2YXIgZGVmZXIsIGNoYW5uZWwsIHBvcnQ7XG5cblx0dmFyIHJ1biA9IGZ1bmN0aW9uIChpZCkge1xuXHQgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wcm90b3R5cGUtYnVpbHRpbnNcblx0ICBpZiAocXVldWUuaGFzT3duUHJvcGVydHkoaWQpKSB7XG5cdCAgICB2YXIgZm4gPSBxdWV1ZVtpZF07XG5cdCAgICBkZWxldGUgcXVldWVbaWRdO1xuXHQgICAgZm4oKTtcblx0ICB9XG5cdH07XG5cblx0dmFyIHJ1bm5lciA9IGZ1bmN0aW9uIChpZCkge1xuXHQgIHJldHVybiBmdW5jdGlvbiAoKSB7XG5cdCAgICBydW4oaWQpO1xuXHQgIH07XG5cdH07XG5cblx0dmFyIGxpc3RlbmVyID0gZnVuY3Rpb24gKGV2ZW50KSB7XG5cdCAgcnVuKGV2ZW50LmRhdGEpO1xuXHR9O1xuXG5cdHZhciBwb3N0ID0gZnVuY3Rpb24gKGlkKSB7XG5cdCAgLy8gb2xkIGVuZ2luZXMgaGF2ZSBub3QgbG9jYXRpb24ub3JpZ2luXG5cdCAgZ2xvYmFsXzEucG9zdE1lc3NhZ2UoaWQgKyAnJywgbG9jYXRpb24ucHJvdG9jb2wgKyAnLy8nICsgbG9jYXRpb24uaG9zdCk7XG5cdH07XG5cblx0Ly8gTm9kZS5qcyAwLjkrICYgSUUxMCsgaGFzIHNldEltbWVkaWF0ZSwgb3RoZXJ3aXNlOlxuXHRpZiAoIXNldCQyIHx8ICFjbGVhcikge1xuXHQgIHNldCQyID0gZnVuY3Rpb24gc2V0SW1tZWRpYXRlKGZuKSB7XG5cdCAgICB2YXIgYXJncyA9IFtdO1xuXHQgICAgdmFyIGkgPSAxO1xuXHQgICAgd2hpbGUgKGFyZ3VtZW50cy5sZW5ndGggPiBpKSBhcmdzLnB1c2goYXJndW1lbnRzW2krK10pO1xuXHQgICAgcXVldWVbKytjb3VudGVyXSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLW5ldy1mdW5jXG5cdCAgICAgICh0eXBlb2YgZm4gPT0gJ2Z1bmN0aW9uJyA/IGZuIDogRnVuY3Rpb24oZm4pKS5hcHBseSh1bmRlZmluZWQsIGFyZ3MpO1xuXHQgICAgfTtcblx0ICAgIGRlZmVyKGNvdW50ZXIpO1xuXHQgICAgcmV0dXJuIGNvdW50ZXI7XG5cdCAgfTtcblx0ICBjbGVhciA9IGZ1bmN0aW9uIGNsZWFySW1tZWRpYXRlKGlkKSB7XG5cdCAgICBkZWxldGUgcXVldWVbaWRdO1xuXHQgIH07XG5cdCAgLy8gTm9kZS5qcyAwLjgtXG5cdCAgaWYgKGNsYXNzb2ZSYXcocHJvY2VzcykgPT0gJ3Byb2Nlc3MnKSB7XG5cdCAgICBkZWZlciA9IGZ1bmN0aW9uIChpZCkge1xuXHQgICAgICBwcm9jZXNzLm5leHRUaWNrKHJ1bm5lcihpZCkpO1xuXHQgICAgfTtcblx0ICAvLyBTcGhlcmUgKEpTIGdhbWUgZW5naW5lKSBEaXNwYXRjaCBBUElcblx0ICB9IGVsc2UgaWYgKERpc3BhdGNoICYmIERpc3BhdGNoLm5vdykge1xuXHQgICAgZGVmZXIgPSBmdW5jdGlvbiAoaWQpIHtcblx0ICAgICAgRGlzcGF0Y2gubm93KHJ1bm5lcihpZCkpO1xuXHQgICAgfTtcblx0ICAvLyBCcm93c2VycyB3aXRoIE1lc3NhZ2VDaGFubmVsLCBpbmNsdWRlcyBXZWJXb3JrZXJzXG5cdCAgfSBlbHNlIGlmIChNZXNzYWdlQ2hhbm5lbCkge1xuXHQgICAgY2hhbm5lbCA9IG5ldyBNZXNzYWdlQ2hhbm5lbCgpO1xuXHQgICAgcG9ydCA9IGNoYW5uZWwucG9ydDI7XG5cdCAgICBjaGFubmVsLnBvcnQxLm9ubWVzc2FnZSA9IGxpc3RlbmVyO1xuXHQgICAgZGVmZXIgPSBiaW5kQ29udGV4dChwb3J0LnBvc3RNZXNzYWdlLCBwb3J0LCAxKTtcblx0ICAvLyBCcm93c2VycyB3aXRoIHBvc3RNZXNzYWdlLCBza2lwIFdlYldvcmtlcnNcblx0ICAvLyBJRTggaGFzIHBvc3RNZXNzYWdlLCBidXQgaXQncyBzeW5jICYgdHlwZW9mIGl0cyBwb3N0TWVzc2FnZSBpcyAnb2JqZWN0J1xuXHQgIH0gZWxzZSBpZiAoZ2xvYmFsXzEuYWRkRXZlbnRMaXN0ZW5lciAmJiB0eXBlb2YgcG9zdE1lc3NhZ2UgPT0gJ2Z1bmN0aW9uJyAmJiAhZ2xvYmFsXzEuaW1wb3J0U2NyaXB0cyAmJiAhZmFpbHMocG9zdCkpIHtcblx0ICAgIGRlZmVyID0gcG9zdDtcblx0ICAgIGdsb2JhbF8xLmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBsaXN0ZW5lciwgZmFsc2UpO1xuXHQgIC8vIElFOC1cblx0ICB9IGVsc2UgaWYgKE9OUkVBRFlTVEFURUNIQU5HRSBpbiBkb2N1bWVudENyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpKSB7XG5cdCAgICBkZWZlciA9IGZ1bmN0aW9uIChpZCkge1xuXHQgICAgICBodG1sLmFwcGVuZENoaWxkKGRvY3VtZW50Q3JlYXRlRWxlbWVudCgnc2NyaXB0JykpW09OUkVBRFlTVEFURUNIQU5HRV0gPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgaHRtbC5yZW1vdmVDaGlsZCh0aGlzKTtcblx0ICAgICAgICBydW4oaWQpO1xuXHQgICAgICB9O1xuXHQgICAgfTtcblx0ICAvLyBSZXN0IG9sZCBicm93c2Vyc1xuXHQgIH0gZWxzZSB7XG5cdCAgICBkZWZlciA9IGZ1bmN0aW9uIChpZCkge1xuXHQgICAgICBzZXRUaW1lb3V0KHJ1bm5lcihpZCksIDApO1xuXHQgICAgfTtcblx0ICB9XG5cdH1cblxuXHR2YXIgdGFzayA9IHtcblx0ICBzZXQ6IHNldCQyLFxuXHQgIGNsZWFyOiBjbGVhclxuXHR9O1xuXG5cdHZhciB1c2VyQWdlbnQgPSBnZXRCdWlsdEluKCduYXZpZ2F0b3InLCAndXNlckFnZW50JykgfHwgJyc7XG5cblx0dmFyIGdldE93blByb3BlcnR5RGVzY3JpcHRvciQyID0gb2JqZWN0R2V0T3duUHJvcGVydHlEZXNjcmlwdG9yLmY7XG5cblx0dmFyIG1hY3JvdGFzayA9IHRhc2suc2V0O1xuXG5cblx0dmFyIE11dGF0aW9uT2JzZXJ2ZXIgPSBnbG9iYWxfMS5NdXRhdGlvbk9ic2VydmVyIHx8IGdsb2JhbF8xLldlYktpdE11dGF0aW9uT2JzZXJ2ZXI7XG5cdHZhciBwcm9jZXNzJDEgPSBnbG9iYWxfMS5wcm9jZXNzO1xuXHR2YXIgUHJvbWlzZSA9IGdsb2JhbF8xLlByb21pc2U7XG5cdHZhciBJU19OT0RFID0gY2xhc3NvZlJhdyhwcm9jZXNzJDEpID09ICdwcm9jZXNzJztcblx0Ly8gTm9kZS5qcyAxMSBzaG93cyBFeHBlcmltZW50YWxXYXJuaW5nIG9uIGdldHRpbmcgYHF1ZXVlTWljcm90YXNrYFxuXHR2YXIgcXVldWVNaWNyb3Rhc2tEZXNjcmlwdG9yID0gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yJDIoZ2xvYmFsXzEsICdxdWV1ZU1pY3JvdGFzaycpO1xuXHR2YXIgcXVldWVNaWNyb3Rhc2sgPSBxdWV1ZU1pY3JvdGFza0Rlc2NyaXB0b3IgJiYgcXVldWVNaWNyb3Rhc2tEZXNjcmlwdG9yLnZhbHVlO1xuXG5cdHZhciBmbHVzaCwgaGVhZCwgbGFzdCwgbm90aWZ5LCB0b2dnbGUsIG5vZGUsIHByb21pc2UsIHRoZW47XG5cblx0Ly8gbW9kZXJuIGVuZ2luZXMgaGF2ZSBxdWV1ZU1pY3JvdGFzayBtZXRob2Rcblx0aWYgKCFxdWV1ZU1pY3JvdGFzaykge1xuXHQgIGZsdXNoID0gZnVuY3Rpb24gKCkge1xuXHQgICAgdmFyIHBhcmVudCwgZm47XG5cdCAgICBpZiAoSVNfTk9ERSAmJiAocGFyZW50ID0gcHJvY2VzcyQxLmRvbWFpbikpIHBhcmVudC5leGl0KCk7XG5cdCAgICB3aGlsZSAoaGVhZCkge1xuXHQgICAgICBmbiA9IGhlYWQuZm47XG5cdCAgICAgIGhlYWQgPSBoZWFkLm5leHQ7XG5cdCAgICAgIHRyeSB7XG5cdCAgICAgICAgZm4oKTtcblx0ICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcblx0ICAgICAgICBpZiAoaGVhZCkgbm90aWZ5KCk7XG5cdCAgICAgICAgZWxzZSBsYXN0ID0gdW5kZWZpbmVkO1xuXHQgICAgICAgIHRocm93IGVycm9yO1xuXHQgICAgICB9XG5cdCAgICB9IGxhc3QgPSB1bmRlZmluZWQ7XG5cdCAgICBpZiAocGFyZW50KSBwYXJlbnQuZW50ZXIoKTtcblx0ICB9O1xuXG5cdCAgLy8gTm9kZS5qc1xuXHQgIGlmIChJU19OT0RFKSB7XG5cdCAgICBub3RpZnkgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgIHByb2Nlc3MkMS5uZXh0VGljayhmbHVzaCk7XG5cdCAgICB9O1xuXHQgIC8vIGJyb3dzZXJzIHdpdGggTXV0YXRpb25PYnNlcnZlciwgZXhjZXB0IGlPUyAtIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy8zMzlcblx0ICB9IGVsc2UgaWYgKE11dGF0aW9uT2JzZXJ2ZXIgJiYgIS8oaXBob25lfGlwb2R8aXBhZCkuKmFwcGxld2Via2l0L2kudGVzdCh1c2VyQWdlbnQpKSB7XG5cdCAgICB0b2dnbGUgPSB0cnVlO1xuXHQgICAgbm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcnKTtcblx0ICAgIG5ldyBNdXRhdGlvbk9ic2VydmVyKGZsdXNoKS5vYnNlcnZlKG5vZGUsIHsgY2hhcmFjdGVyRGF0YTogdHJ1ZSB9KTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXdcblx0ICAgIG5vdGlmeSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgbm9kZS5kYXRhID0gdG9nZ2xlID0gIXRvZ2dsZTtcblx0ICAgIH07XG5cdCAgLy8gZW52aXJvbm1lbnRzIHdpdGggbWF5YmUgbm9uLWNvbXBsZXRlbHkgY29ycmVjdCwgYnV0IGV4aXN0ZW50IFByb21pc2Vcblx0ICB9IGVsc2UgaWYgKFByb21pc2UgJiYgUHJvbWlzZS5yZXNvbHZlKSB7XG5cdCAgICAvLyBQcm9taXNlLnJlc29sdmUgd2l0aG91dCBhbiBhcmd1bWVudCB0aHJvd3MgYW4gZXJyb3IgaW4gTEcgV2ViT1MgMlxuXHQgICAgcHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZSh1bmRlZmluZWQpO1xuXHQgICAgdGhlbiA9IHByb21pc2UudGhlbjtcblx0ICAgIG5vdGlmeSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgdGhlbi5jYWxsKHByb21pc2UsIGZsdXNoKTtcblx0ICAgIH07XG5cdCAgLy8gZm9yIG90aGVyIGVudmlyb25tZW50cyAtIG1hY3JvdGFzayBiYXNlZCBvbjpcblx0ICAvLyAtIHNldEltbWVkaWF0ZVxuXHQgIC8vIC0gTWVzc2FnZUNoYW5uZWxcblx0ICAvLyAtIHdpbmRvdy5wb3N0TWVzc2FnXG5cdCAgLy8gLSBvbnJlYWR5c3RhdGVjaGFuZ2Vcblx0ICAvLyAtIHNldFRpbWVvdXRcblx0ICB9IGVsc2Uge1xuXHQgICAgbm90aWZ5ID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAvLyBzdHJhbmdlIElFICsgd2VicGFjayBkZXYgc2VydmVyIGJ1ZyAtIHVzZSAuY2FsbChnbG9iYWwpXG5cdCAgICAgIG1hY3JvdGFzay5jYWxsKGdsb2JhbF8xLCBmbHVzaCk7XG5cdCAgICB9O1xuXHQgIH1cblx0fVxuXG5cdHZhciBtaWNyb3Rhc2sgPSBxdWV1ZU1pY3JvdGFzayB8fCBmdW5jdGlvbiAoZm4pIHtcblx0ICB2YXIgdGFzayA9IHsgZm46IGZuLCBuZXh0OiB1bmRlZmluZWQgfTtcblx0ICBpZiAobGFzdCkgbGFzdC5uZXh0ID0gdGFzaztcblx0ICBpZiAoIWhlYWQpIHtcblx0ICAgIGhlYWQgPSB0YXNrO1xuXHQgICAgbm90aWZ5KCk7XG5cdCAgfSBsYXN0ID0gdGFzaztcblx0fTtcblxuXHR2YXIgUHJvbWlzZUNhcGFiaWxpdHkgPSBmdW5jdGlvbiAoQykge1xuXHQgIHZhciByZXNvbHZlLCByZWplY3Q7XG5cdCAgdGhpcy5wcm9taXNlID0gbmV3IEMoZnVuY3Rpb24gKCQkcmVzb2x2ZSwgJCRyZWplY3QpIHtcblx0ICAgIGlmIChyZXNvbHZlICE9PSB1bmRlZmluZWQgfHwgcmVqZWN0ICE9PSB1bmRlZmluZWQpIHRocm93IFR5cGVFcnJvcignQmFkIFByb21pc2UgY29uc3RydWN0b3InKTtcblx0ICAgIHJlc29sdmUgPSAkJHJlc29sdmU7XG5cdCAgICByZWplY3QgPSAkJHJlamVjdDtcblx0ICB9KTtcblx0ICB0aGlzLnJlc29sdmUgPSBhRnVuY3Rpb24kMShyZXNvbHZlKTtcblx0ICB0aGlzLnJlamVjdCA9IGFGdW5jdGlvbiQxKHJlamVjdCk7XG5cdH07XG5cblx0Ly8gMjUuNC4xLjUgTmV3UHJvbWlzZUNhcGFiaWxpdHkoQylcblx0dmFyIGYkNyA9IGZ1bmN0aW9uIChDKSB7XG5cdCAgcmV0dXJuIG5ldyBQcm9taXNlQ2FwYWJpbGl0eShDKTtcblx0fTtcblxuXHR2YXIgbmV3UHJvbWlzZUNhcGFiaWxpdHkgPSB7XG5cdFx0ZjogZiQ3XG5cdH07XG5cblx0dmFyIHByb21pc2VSZXNvbHZlID0gZnVuY3Rpb24gKEMsIHgpIHtcblx0ICBhbk9iamVjdChDKTtcblx0ICBpZiAoaXNPYmplY3QoeCkgJiYgeC5jb25zdHJ1Y3RvciA9PT0gQykgcmV0dXJuIHg7XG5cdCAgdmFyIHByb21pc2VDYXBhYmlsaXR5ID0gbmV3UHJvbWlzZUNhcGFiaWxpdHkuZihDKTtcblx0ICB2YXIgcmVzb2x2ZSA9IHByb21pc2VDYXBhYmlsaXR5LnJlc29sdmU7XG5cdCAgcmVzb2x2ZSh4KTtcblx0ICByZXR1cm4gcHJvbWlzZUNhcGFiaWxpdHkucHJvbWlzZTtcblx0fTtcblxuXHR2YXIgaG9zdFJlcG9ydEVycm9ycyA9IGZ1bmN0aW9uIChhLCBiKSB7XG5cdCAgdmFyIGNvbnNvbGUgPSBnbG9iYWxfMS5jb25zb2xlO1xuXHQgIGlmIChjb25zb2xlICYmIGNvbnNvbGUuZXJyb3IpIHtcblx0ICAgIGFyZ3VtZW50cy5sZW5ndGggPT09IDEgPyBjb25zb2xlLmVycm9yKGEpIDogY29uc29sZS5lcnJvcihhLCBiKTtcblx0ICB9XG5cdH07XG5cblx0dmFyIHBlcmZvcm0gPSBmdW5jdGlvbiAoZXhlYykge1xuXHQgIHRyeSB7XG5cdCAgICByZXR1cm4geyBlcnJvcjogZmFsc2UsIHZhbHVlOiBleGVjKCkgfTtcblx0ICB9IGNhdGNoIChlcnJvcikge1xuXHQgICAgcmV0dXJuIHsgZXJyb3I6IHRydWUsIHZhbHVlOiBlcnJvciB9O1xuXHQgIH1cblx0fTtcblxuXHR2YXIgdGFzayQxID0gdGFzay5zZXQ7XG5cblxuXG5cblxuXG5cblxuXG5cblx0dmFyIFNQRUNJRVMkMyA9IHdlbGxLbm93blN5bWJvbCgnc3BlY2llcycpO1xuXHR2YXIgUFJPTUlTRSA9ICdQcm9taXNlJztcblx0dmFyIGdldEludGVybmFsU3RhdGUkMyA9IGludGVybmFsU3RhdGUuZ2V0O1xuXHR2YXIgc2V0SW50ZXJuYWxTdGF0ZSQ1ID0gaW50ZXJuYWxTdGF0ZS5zZXQ7XG5cdHZhciBnZXRJbnRlcm5hbFByb21pc2VTdGF0ZSA9IGludGVybmFsU3RhdGUuZ2V0dGVyRm9yKFBST01JU0UpO1xuXHR2YXIgUHJvbWlzZUNvbnN0cnVjdG9yID0gbmF0aXZlUHJvbWlzZUNvbnN0cnVjdG9yO1xuXHR2YXIgVHlwZUVycm9yJDEgPSBnbG9iYWxfMS5UeXBlRXJyb3I7XG5cdHZhciBkb2N1bWVudCQyID0gZ2xvYmFsXzEuZG9jdW1lbnQ7XG5cdHZhciBwcm9jZXNzJDIgPSBnbG9iYWxfMS5wcm9jZXNzO1xuXHR2YXIgJGZldGNoID0gZ2xvYmFsXzEuZmV0Y2g7XG5cdHZhciB2ZXJzaW9ucyA9IHByb2Nlc3MkMiAmJiBwcm9jZXNzJDIudmVyc2lvbnM7XG5cdHZhciB2OCA9IHZlcnNpb25zICYmIHZlcnNpb25zLnY4IHx8ICcnO1xuXHR2YXIgbmV3UHJvbWlzZUNhcGFiaWxpdHkkMSA9IG5ld1Byb21pc2VDYXBhYmlsaXR5LmY7XG5cdHZhciBuZXdHZW5lcmljUHJvbWlzZUNhcGFiaWxpdHkgPSBuZXdQcm9taXNlQ2FwYWJpbGl0eSQxO1xuXHR2YXIgSVNfTk9ERSQxID0gY2xhc3NvZlJhdyhwcm9jZXNzJDIpID09ICdwcm9jZXNzJztcblx0dmFyIERJU1BBVENIX0VWRU5UID0gISEoZG9jdW1lbnQkMiAmJiBkb2N1bWVudCQyLmNyZWF0ZUV2ZW50ICYmIGdsb2JhbF8xLmRpc3BhdGNoRXZlbnQpO1xuXHR2YXIgVU5IQU5ETEVEX1JFSkVDVElPTiA9ICd1bmhhbmRsZWRyZWplY3Rpb24nO1xuXHR2YXIgUkVKRUNUSU9OX0hBTkRMRUQgPSAncmVqZWN0aW9uaGFuZGxlZCc7XG5cdHZhciBQRU5ESU5HID0gMDtcblx0dmFyIEZVTEZJTExFRCA9IDE7XG5cdHZhciBSRUpFQ1RFRCA9IDI7XG5cdHZhciBIQU5ETEVEID0gMTtcblx0dmFyIFVOSEFORExFRCA9IDI7XG5cdHZhciBJbnRlcm5hbCwgT3duUHJvbWlzZUNhcGFiaWxpdHksIFByb21pc2VXcmFwcGVyLCBuYXRpdmVUaGVuO1xuXG5cdHZhciBGT1JDRUQkNiA9IGlzRm9yY2VkXzEoUFJPTUlTRSwgZnVuY3Rpb24gKCkge1xuXHQgIC8vIGNvcnJlY3Qgc3ViY2xhc3Npbmcgd2l0aCBAQHNwZWNpZXMgc3VwcG9ydFxuXHQgIHZhciBwcm9taXNlID0gUHJvbWlzZUNvbnN0cnVjdG9yLnJlc29sdmUoMSk7XG5cdCAgdmFyIGVtcHR5ID0gZnVuY3Rpb24gKCkgeyAvKiBlbXB0eSAqLyB9O1xuXHQgIHZhciBGYWtlUHJvbWlzZSA9IChwcm9taXNlLmNvbnN0cnVjdG9yID0ge30pW1NQRUNJRVMkM10gPSBmdW5jdGlvbiAoZXhlYykge1xuXHQgICAgZXhlYyhlbXB0eSwgZW1wdHkpO1xuXHQgIH07XG5cdCAgLy8gdW5oYW5kbGVkIHJlamVjdGlvbnMgdHJhY2tpbmcgc3VwcG9ydCwgTm9kZUpTIFByb21pc2Ugd2l0aG91dCBpdCBmYWlscyBAQHNwZWNpZXMgdGVzdFxuXHQgIHJldHVybiAhKChJU19OT0RFJDEgfHwgdHlwZW9mIFByb21pc2VSZWplY3Rpb25FdmVudCA9PSAnZnVuY3Rpb24nKVxuXHQgICAgJiYgKCFpc1B1cmUgfHwgcHJvbWlzZVsnZmluYWxseSddKVxuXHQgICAgJiYgcHJvbWlzZS50aGVuKGVtcHR5KSBpbnN0YW5jZW9mIEZha2VQcm9taXNlXG5cdCAgICAvLyB2OCA2LjYgKE5vZGUgMTAgYW5kIENocm9tZSA2NikgaGF2ZSBhIGJ1ZyB3aXRoIHJlc29sdmluZyBjdXN0b20gdGhlbmFibGVzXG5cdCAgICAvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD04MzA1NjVcblx0ICAgIC8vIHdlIGNhbid0IGRldGVjdCBpdCBzeW5jaHJvbm91c2x5LCBzbyBqdXN0IGNoZWNrIHZlcnNpb25zXG5cdCAgICAmJiB2OC5pbmRleE9mKCc2LjYnKSAhPT0gMFxuXHQgICAgJiYgdXNlckFnZW50LmluZGV4T2YoJ0Nocm9tZS82NicpID09PSAtMSk7XG5cdH0pO1xuXG5cdHZhciBJTkNPUlJFQ1RfSVRFUkFUSU9OJDEgPSBGT1JDRUQkNiB8fCAhY2hlY2tDb3JyZWN0bmVzc09mSXRlcmF0aW9uKGZ1bmN0aW9uIChpdGVyYWJsZSkge1xuXHQgIFByb21pc2VDb25zdHJ1Y3Rvci5hbGwoaXRlcmFibGUpWydjYXRjaCddKGZ1bmN0aW9uICgpIHsgLyogZW1wdHkgKi8gfSk7XG5cdH0pO1xuXG5cdC8vIGhlbHBlcnNcblx0dmFyIGlzVGhlbmFibGUgPSBmdW5jdGlvbiAoaXQpIHtcblx0ICB2YXIgdGhlbjtcblx0ICByZXR1cm4gaXNPYmplY3QoaXQpICYmIHR5cGVvZiAodGhlbiA9IGl0LnRoZW4pID09ICdmdW5jdGlvbicgPyB0aGVuIDogZmFsc2U7XG5cdH07XG5cblx0dmFyIG5vdGlmeSQxID0gZnVuY3Rpb24gKHByb21pc2UsIHN0YXRlLCBpc1JlamVjdCkge1xuXHQgIGlmIChzdGF0ZS5ub3RpZmllZCkgcmV0dXJuO1xuXHQgIHN0YXRlLm5vdGlmaWVkID0gdHJ1ZTtcblx0ICB2YXIgY2hhaW4gPSBzdGF0ZS5yZWFjdGlvbnM7XG5cdCAgbWljcm90YXNrKGZ1bmN0aW9uICgpIHtcblx0ICAgIHZhciB2YWx1ZSA9IHN0YXRlLnZhbHVlO1xuXHQgICAgdmFyIG9rID0gc3RhdGUuc3RhdGUgPT0gRlVMRklMTEVEO1xuXHQgICAgdmFyIGluZGV4ID0gMDtcblx0ICAgIC8vIHZhcmlhYmxlIGxlbmd0aCAtIGNhbid0IHVzZSBmb3JFYWNoXG5cdCAgICB3aGlsZSAoY2hhaW4ubGVuZ3RoID4gaW5kZXgpIHtcblx0ICAgICAgdmFyIHJlYWN0aW9uID0gY2hhaW5baW5kZXgrK107XG5cdCAgICAgIHZhciBoYW5kbGVyID0gb2sgPyByZWFjdGlvbi5vayA6IHJlYWN0aW9uLmZhaWw7XG5cdCAgICAgIHZhciByZXNvbHZlID0gcmVhY3Rpb24ucmVzb2x2ZTtcblx0ICAgICAgdmFyIHJlamVjdCA9IHJlYWN0aW9uLnJlamVjdDtcblx0ICAgICAgdmFyIGRvbWFpbiA9IHJlYWN0aW9uLmRvbWFpbjtcblx0ICAgICAgdmFyIHJlc3VsdCwgdGhlbiwgZXhpdGVkO1xuXHQgICAgICB0cnkge1xuXHQgICAgICAgIGlmIChoYW5kbGVyKSB7XG5cdCAgICAgICAgICBpZiAoIW9rKSB7XG5cdCAgICAgICAgICAgIGlmIChzdGF0ZS5yZWplY3Rpb24gPT09IFVOSEFORExFRCkgb25IYW5kbGVVbmhhbmRsZWQocHJvbWlzZSwgc3RhdGUpO1xuXHQgICAgICAgICAgICBzdGF0ZS5yZWplY3Rpb24gPSBIQU5ETEVEO1xuXHQgICAgICAgICAgfVxuXHQgICAgICAgICAgaWYgKGhhbmRsZXIgPT09IHRydWUpIHJlc3VsdCA9IHZhbHVlO1xuXHQgICAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgIGlmIChkb21haW4pIGRvbWFpbi5lbnRlcigpO1xuXHQgICAgICAgICAgICByZXN1bHQgPSBoYW5kbGVyKHZhbHVlKTsgLy8gY2FuIHRocm93XG5cdCAgICAgICAgICAgIGlmIChkb21haW4pIHtcblx0ICAgICAgICAgICAgICBkb21haW4uZXhpdCgpO1xuXHQgICAgICAgICAgICAgIGV4aXRlZCA9IHRydWU7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgIH1cblx0ICAgICAgICAgIGlmIChyZXN1bHQgPT09IHJlYWN0aW9uLnByb21pc2UpIHtcblx0ICAgICAgICAgICAgcmVqZWN0KFR5cGVFcnJvciQxKCdQcm9taXNlLWNoYWluIGN5Y2xlJykpO1xuXHQgICAgICAgICAgfSBlbHNlIGlmICh0aGVuID0gaXNUaGVuYWJsZShyZXN1bHQpKSB7XG5cdCAgICAgICAgICAgIHRoZW4uY2FsbChyZXN1bHQsIHJlc29sdmUsIHJlamVjdCk7XG5cdCAgICAgICAgICB9IGVsc2UgcmVzb2x2ZShyZXN1bHQpO1xuXHQgICAgICAgIH0gZWxzZSByZWplY3QodmFsdWUpO1xuXHQgICAgICB9IGNhdGNoIChlcnJvcikge1xuXHQgICAgICAgIGlmIChkb21haW4gJiYgIWV4aXRlZCkgZG9tYWluLmV4aXQoKTtcblx0ICAgICAgICByZWplY3QoZXJyb3IpO1xuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgICBzdGF0ZS5yZWFjdGlvbnMgPSBbXTtcblx0ICAgIHN0YXRlLm5vdGlmaWVkID0gZmFsc2U7XG5cdCAgICBpZiAoaXNSZWplY3QgJiYgIXN0YXRlLnJlamVjdGlvbikgb25VbmhhbmRsZWQocHJvbWlzZSwgc3RhdGUpO1xuXHQgIH0pO1xuXHR9O1xuXG5cdHZhciBkaXNwYXRjaEV2ZW50ID0gZnVuY3Rpb24gKG5hbWUsIHByb21pc2UsIHJlYXNvbikge1xuXHQgIHZhciBldmVudCwgaGFuZGxlcjtcblx0ICBpZiAoRElTUEFUQ0hfRVZFTlQpIHtcblx0ICAgIGV2ZW50ID0gZG9jdW1lbnQkMi5jcmVhdGVFdmVudCgnRXZlbnQnKTtcblx0ICAgIGV2ZW50LnByb21pc2UgPSBwcm9taXNlO1xuXHQgICAgZXZlbnQucmVhc29uID0gcmVhc29uO1xuXHQgICAgZXZlbnQuaW5pdEV2ZW50KG5hbWUsIGZhbHNlLCB0cnVlKTtcblx0ICAgIGdsb2JhbF8xLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuXHQgIH0gZWxzZSBldmVudCA9IHsgcHJvbWlzZTogcHJvbWlzZSwgcmVhc29uOiByZWFzb24gfTtcblx0ICBpZiAoaGFuZGxlciA9IGdsb2JhbF8xWydvbicgKyBuYW1lXSkgaGFuZGxlcihldmVudCk7XG5cdCAgZWxzZSBpZiAobmFtZSA9PT0gVU5IQU5ETEVEX1JFSkVDVElPTikgaG9zdFJlcG9ydEVycm9ycygnVW5oYW5kbGVkIHByb21pc2UgcmVqZWN0aW9uJywgcmVhc29uKTtcblx0fTtcblxuXHR2YXIgb25VbmhhbmRsZWQgPSBmdW5jdGlvbiAocHJvbWlzZSwgc3RhdGUpIHtcblx0ICB0YXNrJDEuY2FsbChnbG9iYWxfMSwgZnVuY3Rpb24gKCkge1xuXHQgICAgdmFyIHZhbHVlID0gc3RhdGUudmFsdWU7XG5cdCAgICB2YXIgSVNfVU5IQU5ETEVEID0gaXNVbmhhbmRsZWQoc3RhdGUpO1xuXHQgICAgdmFyIHJlc3VsdDtcblx0ICAgIGlmIChJU19VTkhBTkRMRUQpIHtcblx0ICAgICAgcmVzdWx0ID0gcGVyZm9ybShmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgaWYgKElTX05PREUkMSkge1xuXHQgICAgICAgICAgcHJvY2VzcyQyLmVtaXQoJ3VuaGFuZGxlZFJlamVjdGlvbicsIHZhbHVlLCBwcm9taXNlKTtcblx0ICAgICAgICB9IGVsc2UgZGlzcGF0Y2hFdmVudChVTkhBTkRMRURfUkVKRUNUSU9OLCBwcm9taXNlLCB2YWx1ZSk7XG5cdCAgICAgIH0pO1xuXHQgICAgICAvLyBCcm93c2VycyBzaG91bGQgbm90IHRyaWdnZXIgYHJlamVjdGlvbkhhbmRsZWRgIGV2ZW50IGlmIGl0IHdhcyBoYW5kbGVkIGhlcmUsIE5vZGVKUyAtIHNob3VsZFxuXHQgICAgICBzdGF0ZS5yZWplY3Rpb24gPSBJU19OT0RFJDEgfHwgaXNVbmhhbmRsZWQoc3RhdGUpID8gVU5IQU5ETEVEIDogSEFORExFRDtcblx0ICAgICAgaWYgKHJlc3VsdC5lcnJvcikgdGhyb3cgcmVzdWx0LnZhbHVlO1xuXHQgICAgfVxuXHQgIH0pO1xuXHR9O1xuXG5cdHZhciBpc1VuaGFuZGxlZCA9IGZ1bmN0aW9uIChzdGF0ZSkge1xuXHQgIHJldHVybiBzdGF0ZS5yZWplY3Rpb24gIT09IEhBTkRMRUQgJiYgIXN0YXRlLnBhcmVudDtcblx0fTtcblxuXHR2YXIgb25IYW5kbGVVbmhhbmRsZWQgPSBmdW5jdGlvbiAocHJvbWlzZSwgc3RhdGUpIHtcblx0ICB0YXNrJDEuY2FsbChnbG9iYWxfMSwgZnVuY3Rpb24gKCkge1xuXHQgICAgaWYgKElTX05PREUkMSkge1xuXHQgICAgICBwcm9jZXNzJDIuZW1pdCgncmVqZWN0aW9uSGFuZGxlZCcsIHByb21pc2UpO1xuXHQgICAgfSBlbHNlIGRpc3BhdGNoRXZlbnQoUkVKRUNUSU9OX0hBTkRMRUQsIHByb21pc2UsIHN0YXRlLnZhbHVlKTtcblx0ICB9KTtcblx0fTtcblxuXHR2YXIgYmluZCA9IGZ1bmN0aW9uIChmbiwgcHJvbWlzZSwgc3RhdGUsIHVud3JhcCkge1xuXHQgIHJldHVybiBmdW5jdGlvbiAodmFsdWUpIHtcblx0ICAgIGZuKHByb21pc2UsIHN0YXRlLCB2YWx1ZSwgdW53cmFwKTtcblx0ICB9O1xuXHR9O1xuXG5cdHZhciBpbnRlcm5hbFJlamVjdCA9IGZ1bmN0aW9uIChwcm9taXNlLCBzdGF0ZSwgdmFsdWUsIHVud3JhcCkge1xuXHQgIGlmIChzdGF0ZS5kb25lKSByZXR1cm47XG5cdCAgc3RhdGUuZG9uZSA9IHRydWU7XG5cdCAgaWYgKHVud3JhcCkgc3RhdGUgPSB1bndyYXA7XG5cdCAgc3RhdGUudmFsdWUgPSB2YWx1ZTtcblx0ICBzdGF0ZS5zdGF0ZSA9IFJFSkVDVEVEO1xuXHQgIG5vdGlmeSQxKHByb21pc2UsIHN0YXRlLCB0cnVlKTtcblx0fTtcblxuXHR2YXIgaW50ZXJuYWxSZXNvbHZlID0gZnVuY3Rpb24gKHByb21pc2UsIHN0YXRlLCB2YWx1ZSwgdW53cmFwKSB7XG5cdCAgaWYgKHN0YXRlLmRvbmUpIHJldHVybjtcblx0ICBzdGF0ZS5kb25lID0gdHJ1ZTtcblx0ICBpZiAodW53cmFwKSBzdGF0ZSA9IHVud3JhcDtcblx0ICB0cnkge1xuXHQgICAgaWYgKHByb21pc2UgPT09IHZhbHVlKSB0aHJvdyBUeXBlRXJyb3IkMShcIlByb21pc2UgY2FuJ3QgYmUgcmVzb2x2ZWQgaXRzZWxmXCIpO1xuXHQgICAgdmFyIHRoZW4gPSBpc1RoZW5hYmxlKHZhbHVlKTtcblx0ICAgIGlmICh0aGVuKSB7XG5cdCAgICAgIG1pY3JvdGFzayhmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdmFyIHdyYXBwZXIgPSB7IGRvbmU6IGZhbHNlIH07XG5cdCAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgIHRoZW4uY2FsbCh2YWx1ZSxcblx0ICAgICAgICAgICAgYmluZChpbnRlcm5hbFJlc29sdmUsIHByb21pc2UsIHdyYXBwZXIsIHN0YXRlKSxcblx0ICAgICAgICAgICAgYmluZChpbnRlcm5hbFJlamVjdCwgcHJvbWlzZSwgd3JhcHBlciwgc3RhdGUpXG5cdCAgICAgICAgICApO1xuXHQgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG5cdCAgICAgICAgICBpbnRlcm5hbFJlamVjdChwcm9taXNlLCB3cmFwcGVyLCBlcnJvciwgc3RhdGUpO1xuXHQgICAgICAgIH1cblx0ICAgICAgfSk7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICBzdGF0ZS52YWx1ZSA9IHZhbHVlO1xuXHQgICAgICBzdGF0ZS5zdGF0ZSA9IEZVTEZJTExFRDtcblx0ICAgICAgbm90aWZ5JDEocHJvbWlzZSwgc3RhdGUsIGZhbHNlKTtcblx0ICAgIH1cblx0ICB9IGNhdGNoIChlcnJvcikge1xuXHQgICAgaW50ZXJuYWxSZWplY3QocHJvbWlzZSwgeyBkb25lOiBmYWxzZSB9LCBlcnJvciwgc3RhdGUpO1xuXHQgIH1cblx0fTtcblxuXHQvLyBjb25zdHJ1Y3RvciBwb2x5ZmlsbFxuXHRpZiAoRk9SQ0VEJDYpIHtcblx0ICAvLyAyNS40LjMuMSBQcm9taXNlKGV4ZWN1dG9yKVxuXHQgIFByb21pc2VDb25zdHJ1Y3RvciA9IGZ1bmN0aW9uIFByb21pc2UoZXhlY3V0b3IpIHtcblx0ICAgIGFuSW5zdGFuY2UodGhpcywgUHJvbWlzZUNvbnN0cnVjdG9yLCBQUk9NSVNFKTtcblx0ICAgIGFGdW5jdGlvbiQxKGV4ZWN1dG9yKTtcblx0ICAgIEludGVybmFsLmNhbGwodGhpcyk7XG5cdCAgICB2YXIgc3RhdGUgPSBnZXRJbnRlcm5hbFN0YXRlJDModGhpcyk7XG5cdCAgICB0cnkge1xuXHQgICAgICBleGVjdXRvcihiaW5kKGludGVybmFsUmVzb2x2ZSwgdGhpcywgc3RhdGUpLCBiaW5kKGludGVybmFsUmVqZWN0LCB0aGlzLCBzdGF0ZSkpO1xuXHQgICAgfSBjYXRjaCAoZXJyb3IpIHtcblx0ICAgICAgaW50ZXJuYWxSZWplY3QodGhpcywgc3RhdGUsIGVycm9yKTtcblx0ICAgIH1cblx0ICB9O1xuXHQgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtdmFyc1xuXHQgIEludGVybmFsID0gZnVuY3Rpb24gUHJvbWlzZShleGVjdXRvcikge1xuXHQgICAgc2V0SW50ZXJuYWxTdGF0ZSQ1KHRoaXMsIHtcblx0ICAgICAgdHlwZTogUFJPTUlTRSxcblx0ICAgICAgZG9uZTogZmFsc2UsXG5cdCAgICAgIG5vdGlmaWVkOiBmYWxzZSxcblx0ICAgICAgcGFyZW50OiBmYWxzZSxcblx0ICAgICAgcmVhY3Rpb25zOiBbXSxcblx0ICAgICAgcmVqZWN0aW9uOiBmYWxzZSxcblx0ICAgICAgc3RhdGU6IFBFTkRJTkcsXG5cdCAgICAgIHZhbHVlOiB1bmRlZmluZWRcblx0ICAgIH0pO1xuXHQgIH07XG5cdCAgSW50ZXJuYWwucHJvdG90eXBlID0gcmVkZWZpbmVBbGwoUHJvbWlzZUNvbnN0cnVjdG9yLnByb3RvdHlwZSwge1xuXHQgICAgLy8gYFByb21pc2UucHJvdG90eXBlLnRoZW5gIG1ldGhvZFxuXHQgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtcHJvbWlzZS5wcm90b3R5cGUudGhlblxuXHQgICAgdGhlbjogZnVuY3Rpb24gdGhlbihvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCkge1xuXHQgICAgICB2YXIgc3RhdGUgPSBnZXRJbnRlcm5hbFByb21pc2VTdGF0ZSh0aGlzKTtcblx0ICAgICAgdmFyIHJlYWN0aW9uID0gbmV3UHJvbWlzZUNhcGFiaWxpdHkkMShzcGVjaWVzQ29uc3RydWN0b3IodGhpcywgUHJvbWlzZUNvbnN0cnVjdG9yKSk7XG5cdCAgICAgIHJlYWN0aW9uLm9rID0gdHlwZW9mIG9uRnVsZmlsbGVkID09ICdmdW5jdGlvbicgPyBvbkZ1bGZpbGxlZCA6IHRydWU7XG5cdCAgICAgIHJlYWN0aW9uLmZhaWwgPSB0eXBlb2Ygb25SZWplY3RlZCA9PSAnZnVuY3Rpb24nICYmIG9uUmVqZWN0ZWQ7XG5cdCAgICAgIHJlYWN0aW9uLmRvbWFpbiA9IElTX05PREUkMSA/IHByb2Nlc3MkMi5kb21haW4gOiB1bmRlZmluZWQ7XG5cdCAgICAgIHN0YXRlLnBhcmVudCA9IHRydWU7XG5cdCAgICAgIHN0YXRlLnJlYWN0aW9ucy5wdXNoKHJlYWN0aW9uKTtcblx0ICAgICAgaWYgKHN0YXRlLnN0YXRlICE9IFBFTkRJTkcpIG5vdGlmeSQxKHRoaXMsIHN0YXRlLCBmYWxzZSk7XG5cdCAgICAgIHJldHVybiByZWFjdGlvbi5wcm9taXNlO1xuXHQgICAgfSxcblx0ICAgIC8vIGBQcm9taXNlLnByb3RvdHlwZS5jYXRjaGAgbWV0aG9kXG5cdCAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1wcm9taXNlLnByb3RvdHlwZS5jYXRjaFxuXHQgICAgJ2NhdGNoJzogZnVuY3Rpb24gKG9uUmVqZWN0ZWQpIHtcblx0ICAgICAgcmV0dXJuIHRoaXMudGhlbih1bmRlZmluZWQsIG9uUmVqZWN0ZWQpO1xuXHQgICAgfVxuXHQgIH0pO1xuXHQgIE93blByb21pc2VDYXBhYmlsaXR5ID0gZnVuY3Rpb24gKCkge1xuXHQgICAgdmFyIHByb21pc2UgPSBuZXcgSW50ZXJuYWwoKTtcblx0ICAgIHZhciBzdGF0ZSA9IGdldEludGVybmFsU3RhdGUkMyhwcm9taXNlKTtcblx0ICAgIHRoaXMucHJvbWlzZSA9IHByb21pc2U7XG5cdCAgICB0aGlzLnJlc29sdmUgPSBiaW5kKGludGVybmFsUmVzb2x2ZSwgcHJvbWlzZSwgc3RhdGUpO1xuXHQgICAgdGhpcy5yZWplY3QgPSBiaW5kKGludGVybmFsUmVqZWN0LCBwcm9taXNlLCBzdGF0ZSk7XG5cdCAgfTtcblx0ICBuZXdQcm9taXNlQ2FwYWJpbGl0eS5mID0gbmV3UHJvbWlzZUNhcGFiaWxpdHkkMSA9IGZ1bmN0aW9uIChDKSB7XG5cdCAgICByZXR1cm4gQyA9PT0gUHJvbWlzZUNvbnN0cnVjdG9yIHx8IEMgPT09IFByb21pc2VXcmFwcGVyXG5cdCAgICAgID8gbmV3IE93blByb21pc2VDYXBhYmlsaXR5KEMpXG5cdCAgICAgIDogbmV3R2VuZXJpY1Byb21pc2VDYXBhYmlsaXR5KEMpO1xuXHQgIH07XG5cblx0ICBpZiAoIHR5cGVvZiBuYXRpdmVQcm9taXNlQ29uc3RydWN0b3IgPT0gJ2Z1bmN0aW9uJykge1xuXHQgICAgbmF0aXZlVGhlbiA9IG5hdGl2ZVByb21pc2VDb25zdHJ1Y3Rvci5wcm90b3R5cGUudGhlbjtcblxuXHQgICAgLy8gd3JhcCBuYXRpdmUgUHJvbWlzZSN0aGVuIGZvciBuYXRpdmUgYXN5bmMgZnVuY3Rpb25zXG5cdCAgICByZWRlZmluZShuYXRpdmVQcm9taXNlQ29uc3RydWN0b3IucHJvdG90eXBlLCAndGhlbicsIGZ1bmN0aW9uIHRoZW4ob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQpIHtcblx0ICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuXHQgICAgICByZXR1cm4gbmV3IFByb21pc2VDb25zdHJ1Y3RvcihmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG5cdCAgICAgICAgbmF0aXZlVGhlbi5jYWxsKHRoYXQsIHJlc29sdmUsIHJlamVjdCk7XG5cdCAgICAgIH0pLnRoZW4ob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQpO1xuXHQgICAgfSk7XG5cblx0ICAgIC8vIHdyYXAgZmV0Y2ggcmVzdWx0XG5cdCAgICBpZiAodHlwZW9mICRmZXRjaCA9PSAnZnVuY3Rpb24nKSBfZXhwb3J0KHsgZ2xvYmFsOiB0cnVlLCBlbnVtZXJhYmxlOiB0cnVlLCBmb3JjZWQ6IHRydWUgfSwge1xuXHQgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLXZhcnNcblx0ICAgICAgZmV0Y2g6IGZ1bmN0aW9uIGZldGNoKGlucHV0KSB7XG5cdCAgICAgICAgcmV0dXJuIHByb21pc2VSZXNvbHZlKFByb21pc2VDb25zdHJ1Y3RvciwgJGZldGNoLmFwcGx5KGdsb2JhbF8xLCBhcmd1bWVudHMpKTtcblx0ICAgICAgfVxuXHQgICAgfSk7XG5cdCAgfVxuXHR9XG5cblx0X2V4cG9ydCh7IGdsb2JhbDogdHJ1ZSwgd3JhcDogdHJ1ZSwgZm9yY2VkOiBGT1JDRUQkNiB9LCB7XG5cdCAgUHJvbWlzZTogUHJvbWlzZUNvbnN0cnVjdG9yXG5cdH0pO1xuXG5cdHNldFRvU3RyaW5nVGFnKFByb21pc2VDb25zdHJ1Y3RvciwgUFJPTUlTRSwgZmFsc2UpO1xuXHRzZXRTcGVjaWVzKFBST01JU0UpO1xuXG5cdFByb21pc2VXcmFwcGVyID0gcGF0aFtQUk9NSVNFXTtcblxuXHQvLyBzdGF0aWNzXG5cdF9leHBvcnQoeyB0YXJnZXQ6IFBST01JU0UsIHN0YXQ6IHRydWUsIGZvcmNlZDogRk9SQ0VEJDYgfSwge1xuXHQgIC8vIGBQcm9taXNlLnJlamVjdGAgbWV0aG9kXG5cdCAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtcHJvbWlzZS5yZWplY3Rcblx0ICByZWplY3Q6IGZ1bmN0aW9uIHJlamVjdChyKSB7XG5cdCAgICB2YXIgY2FwYWJpbGl0eSA9IG5ld1Byb21pc2VDYXBhYmlsaXR5JDEodGhpcyk7XG5cdCAgICBjYXBhYmlsaXR5LnJlamVjdC5jYWxsKHVuZGVmaW5lZCwgcik7XG5cdCAgICByZXR1cm4gY2FwYWJpbGl0eS5wcm9taXNlO1xuXHQgIH1cblx0fSk7XG5cblx0X2V4cG9ydCh7IHRhcmdldDogUFJPTUlTRSwgc3RhdDogdHJ1ZSwgZm9yY2VkOiAgRk9SQ0VEJDYgfSwge1xuXHQgIC8vIGBQcm9taXNlLnJlc29sdmVgIG1ldGhvZFxuXHQgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXByb21pc2UucmVzb2x2ZVxuXHQgIHJlc29sdmU6IGZ1bmN0aW9uIHJlc29sdmUoeCkge1xuXHQgICAgcmV0dXJuIHByb21pc2VSZXNvbHZlKCB0aGlzLCB4KTtcblx0ICB9XG5cdH0pO1xuXG5cdF9leHBvcnQoeyB0YXJnZXQ6IFBST01JU0UsIHN0YXQ6IHRydWUsIGZvcmNlZDogSU5DT1JSRUNUX0lURVJBVElPTiQxIH0sIHtcblx0ICAvLyBgUHJvbWlzZS5hbGxgIG1ldGhvZFxuXHQgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXByb21pc2UuYWxsXG5cdCAgYWxsOiBmdW5jdGlvbiBhbGwoaXRlcmFibGUpIHtcblx0ICAgIHZhciBDID0gdGhpcztcblx0ICAgIHZhciBjYXBhYmlsaXR5ID0gbmV3UHJvbWlzZUNhcGFiaWxpdHkkMShDKTtcblx0ICAgIHZhciByZXNvbHZlID0gY2FwYWJpbGl0eS5yZXNvbHZlO1xuXHQgICAgdmFyIHJlamVjdCA9IGNhcGFiaWxpdHkucmVqZWN0O1xuXHQgICAgdmFyIHJlc3VsdCA9IHBlcmZvcm0oZnVuY3Rpb24gKCkge1xuXHQgICAgICB2YXIgJHByb21pc2VSZXNvbHZlID0gYUZ1bmN0aW9uJDEoQy5yZXNvbHZlKTtcblx0ICAgICAgdmFyIHZhbHVlcyA9IFtdO1xuXHQgICAgICB2YXIgY291bnRlciA9IDA7XG5cdCAgICAgIHZhciByZW1haW5pbmcgPSAxO1xuXHQgICAgICBpdGVyYXRlXzEoaXRlcmFibGUsIGZ1bmN0aW9uIChwcm9taXNlKSB7XG5cdCAgICAgICAgdmFyIGluZGV4ID0gY291bnRlcisrO1xuXHQgICAgICAgIHZhciBhbHJlYWR5Q2FsbGVkID0gZmFsc2U7XG5cdCAgICAgICAgdmFsdWVzLnB1c2godW5kZWZpbmVkKTtcblx0ICAgICAgICByZW1haW5pbmcrKztcblx0ICAgICAgICAkcHJvbWlzZVJlc29sdmUuY2FsbChDLCBwcm9taXNlKS50aGVuKGZ1bmN0aW9uICh2YWx1ZSkge1xuXHQgICAgICAgICAgaWYgKGFscmVhZHlDYWxsZWQpIHJldHVybjtcblx0ICAgICAgICAgIGFscmVhZHlDYWxsZWQgPSB0cnVlO1xuXHQgICAgICAgICAgdmFsdWVzW2luZGV4XSA9IHZhbHVlO1xuXHQgICAgICAgICAgLS1yZW1haW5pbmcgfHwgcmVzb2x2ZSh2YWx1ZXMpO1xuXHQgICAgICAgIH0sIHJlamVjdCk7XG5cdCAgICAgIH0pO1xuXHQgICAgICAtLXJlbWFpbmluZyB8fCByZXNvbHZlKHZhbHVlcyk7XG5cdCAgICB9KTtcblx0ICAgIGlmIChyZXN1bHQuZXJyb3IpIHJlamVjdChyZXN1bHQudmFsdWUpO1xuXHQgICAgcmV0dXJuIGNhcGFiaWxpdHkucHJvbWlzZTtcblx0ICB9LFxuXHQgIC8vIGBQcm9taXNlLnJhY2VgIG1ldGhvZFxuXHQgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXByb21pc2UucmFjZVxuXHQgIHJhY2U6IGZ1bmN0aW9uIHJhY2UoaXRlcmFibGUpIHtcblx0ICAgIHZhciBDID0gdGhpcztcblx0ICAgIHZhciBjYXBhYmlsaXR5ID0gbmV3UHJvbWlzZUNhcGFiaWxpdHkkMShDKTtcblx0ICAgIHZhciByZWplY3QgPSBjYXBhYmlsaXR5LnJlamVjdDtcblx0ICAgIHZhciByZXN1bHQgPSBwZXJmb3JtKGZ1bmN0aW9uICgpIHtcblx0ICAgICAgdmFyICRwcm9taXNlUmVzb2x2ZSA9IGFGdW5jdGlvbiQxKEMucmVzb2x2ZSk7XG5cdCAgICAgIGl0ZXJhdGVfMShpdGVyYWJsZSwgZnVuY3Rpb24gKHByb21pc2UpIHtcblx0ICAgICAgICAkcHJvbWlzZVJlc29sdmUuY2FsbChDLCBwcm9taXNlKS50aGVuKGNhcGFiaWxpdHkucmVzb2x2ZSwgcmVqZWN0KTtcblx0ICAgICAgfSk7XG5cdCAgICB9KTtcblx0ICAgIGlmIChyZXN1bHQuZXJyb3IpIHJlamVjdChyZXN1bHQudmFsdWUpO1xuXHQgICAgcmV0dXJuIGNhcGFiaWxpdHkucHJvbWlzZTtcblx0ICB9XG5cdH0pO1xuXG5cdC8vIGBQcm9taXNlLmFsbFNldHRsZWRgIG1ldGhvZFxuXHQvLyBodHRwczovL2dpdGh1Yi5jb20vdGMzOS9wcm9wb3NhbC1wcm9taXNlLWFsbFNldHRsZWRcblx0X2V4cG9ydCh7IHRhcmdldDogJ1Byb21pc2UnLCBzdGF0OiB0cnVlIH0sIHtcblx0ICBhbGxTZXR0bGVkOiBmdW5jdGlvbiBhbGxTZXR0bGVkKGl0ZXJhYmxlKSB7XG5cdCAgICB2YXIgQyA9IHRoaXM7XG5cdCAgICB2YXIgY2FwYWJpbGl0eSA9IG5ld1Byb21pc2VDYXBhYmlsaXR5LmYoQyk7XG5cdCAgICB2YXIgcmVzb2x2ZSA9IGNhcGFiaWxpdHkucmVzb2x2ZTtcblx0ICAgIHZhciByZWplY3QgPSBjYXBhYmlsaXR5LnJlamVjdDtcblx0ICAgIHZhciByZXN1bHQgPSBwZXJmb3JtKGZ1bmN0aW9uICgpIHtcblx0ICAgICAgdmFyIHByb21pc2VSZXNvbHZlID0gYUZ1bmN0aW9uJDEoQy5yZXNvbHZlKTtcblx0ICAgICAgdmFyIHZhbHVlcyA9IFtdO1xuXHQgICAgICB2YXIgY291bnRlciA9IDA7XG5cdCAgICAgIHZhciByZW1haW5pbmcgPSAxO1xuXHQgICAgICBpdGVyYXRlXzEoaXRlcmFibGUsIGZ1bmN0aW9uIChwcm9taXNlKSB7XG5cdCAgICAgICAgdmFyIGluZGV4ID0gY291bnRlcisrO1xuXHQgICAgICAgIHZhciBhbHJlYWR5Q2FsbGVkID0gZmFsc2U7XG5cdCAgICAgICAgdmFsdWVzLnB1c2godW5kZWZpbmVkKTtcblx0ICAgICAgICByZW1haW5pbmcrKztcblx0ICAgICAgICBwcm9taXNlUmVzb2x2ZS5jYWxsKEMsIHByb21pc2UpLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7XG5cdCAgICAgICAgICBpZiAoYWxyZWFkeUNhbGxlZCkgcmV0dXJuO1xuXHQgICAgICAgICAgYWxyZWFkeUNhbGxlZCA9IHRydWU7XG5cdCAgICAgICAgICB2YWx1ZXNbaW5kZXhdID0geyBzdGF0dXM6ICdmdWxmaWxsZWQnLCB2YWx1ZTogdmFsdWUgfTtcblx0ICAgICAgICAgIC0tcmVtYWluaW5nIHx8IHJlc29sdmUodmFsdWVzKTtcblx0ICAgICAgICB9LCBmdW5jdGlvbiAoZSkge1xuXHQgICAgICAgICAgaWYgKGFscmVhZHlDYWxsZWQpIHJldHVybjtcblx0ICAgICAgICAgIGFscmVhZHlDYWxsZWQgPSB0cnVlO1xuXHQgICAgICAgICAgdmFsdWVzW2luZGV4XSA9IHsgc3RhdHVzOiAncmVqZWN0ZWQnLCByZWFzb246IGUgfTtcblx0ICAgICAgICAgIC0tcmVtYWluaW5nIHx8IHJlc29sdmUodmFsdWVzKTtcblx0ICAgICAgICB9KTtcblx0ICAgICAgfSk7XG5cdCAgICAgIC0tcmVtYWluaW5nIHx8IHJlc29sdmUodmFsdWVzKTtcblx0ICAgIH0pO1xuXHQgICAgaWYgKHJlc3VsdC5lcnJvcikgcmVqZWN0KHJlc3VsdC52YWx1ZSk7XG5cdCAgICByZXR1cm4gY2FwYWJpbGl0eS5wcm9taXNlO1xuXHQgIH1cblx0fSk7XG5cblx0Ly8gYFByb21pc2UucHJvdG90eXBlLmZpbmFsbHlgIG1ldGhvZFxuXHQvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1wcm9taXNlLnByb3RvdHlwZS5maW5hbGx5XG5cdF9leHBvcnQoeyB0YXJnZXQ6ICdQcm9taXNlJywgcHJvdG86IHRydWUsIHJlYWw6IHRydWUgfSwge1xuXHQgICdmaW5hbGx5JzogZnVuY3Rpb24gKG9uRmluYWxseSkge1xuXHQgICAgdmFyIEMgPSBzcGVjaWVzQ29uc3RydWN0b3IodGhpcywgZ2V0QnVpbHRJbignUHJvbWlzZScpKTtcblx0ICAgIHZhciBpc0Z1bmN0aW9uID0gdHlwZW9mIG9uRmluYWxseSA9PSAnZnVuY3Rpb24nO1xuXHQgICAgcmV0dXJuIHRoaXMudGhlbihcblx0ICAgICAgaXNGdW5jdGlvbiA/IGZ1bmN0aW9uICh4KSB7XG5cdCAgICAgICAgcmV0dXJuIHByb21pc2VSZXNvbHZlKEMsIG9uRmluYWxseSgpKS50aGVuKGZ1bmN0aW9uICgpIHsgcmV0dXJuIHg7IH0pO1xuXHQgICAgICB9IDogb25GaW5hbGx5LFxuXHQgICAgICBpc0Z1bmN0aW9uID8gZnVuY3Rpb24gKGUpIHtcblx0ICAgICAgICByZXR1cm4gcHJvbWlzZVJlc29sdmUoQywgb25GaW5hbGx5KCkpLnRoZW4oZnVuY3Rpb24gKCkgeyB0aHJvdyBlOyB9KTtcblx0ICAgICAgfSA6IG9uRmluYWxseVxuXHQgICAgKTtcblx0ICB9XG5cdH0pO1xuXG5cdC8vIHBhdGNoIG5hdGl2ZSBQcm9taXNlLnByb3RvdHlwZSBmb3IgbmF0aXZlIGFzeW5jIGZ1bmN0aW9uc1xuXHRpZiAoIHR5cGVvZiBuYXRpdmVQcm9taXNlQ29uc3RydWN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiAhbmF0aXZlUHJvbWlzZUNvbnN0cnVjdG9yLnByb3RvdHlwZVsnZmluYWxseSddKSB7XG5cdCAgcmVkZWZpbmUobmF0aXZlUHJvbWlzZUNvbnN0cnVjdG9yLnByb3RvdHlwZSwgJ2ZpbmFsbHknLCBnZXRCdWlsdEluKCdQcm9taXNlJykucHJvdG90eXBlWydmaW5hbGx5J10pO1xuXHR9XG5cblx0dmFyIHByb21pc2UkMSA9IHBhdGguUHJvbWlzZTtcblxuXHR2YXIgZXMyMDE1UHJvbWlzZSA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuXHR9KTtcblxuXHR1bndyYXBFeHBvcnRzKGVzMjAxNVByb21pc2UpO1xuXG5cdHZhciBuYXRpdmVBcHBseSA9IGdldEJ1aWx0SW4oJ1JlZmxlY3QnLCAnYXBwbHknKTtcblx0dmFyIGZ1bmN0aW9uQXBwbHkgPSBGdW5jdGlvbi5hcHBseTtcblxuXHQvLyBNUyBFZGdlIGFyZ3VtZW50c0xpc3QgYXJndW1lbnQgaXMgb3B0aW9uYWxcblx0dmFyIE9QVElPTkFMX0FSR1VNRU5UU19MSVNUID0gIWZhaWxzKGZ1bmN0aW9uICgpIHtcblx0ICBuYXRpdmVBcHBseShmdW5jdGlvbiAoKSB7IC8qIGVtcHR5ICovIH0pO1xuXHR9KTtcblxuXHQvLyBgUmVmbGVjdC5hcHBseWAgbWV0aG9kXG5cdC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXJlZmxlY3QuYXBwbHlcblx0X2V4cG9ydCh7IHRhcmdldDogJ1JlZmxlY3QnLCBzdGF0OiB0cnVlLCBmb3JjZWQ6IE9QVElPTkFMX0FSR1VNRU5UU19MSVNUIH0sIHtcblx0ICBhcHBseTogZnVuY3Rpb24gYXBwbHkodGFyZ2V0LCB0aGlzQXJndW1lbnQsIGFyZ3VtZW50c0xpc3QpIHtcblx0ICAgIGFGdW5jdGlvbiQxKHRhcmdldCk7XG5cdCAgICBhbk9iamVjdChhcmd1bWVudHNMaXN0KTtcblx0ICAgIHJldHVybiBuYXRpdmVBcHBseVxuXHQgICAgICA/IG5hdGl2ZUFwcGx5KHRhcmdldCwgdGhpc0FyZ3VtZW50LCBhcmd1bWVudHNMaXN0KVxuXHQgICAgICA6IGZ1bmN0aW9uQXBwbHkuY2FsbCh0YXJnZXQsIHRoaXNBcmd1bWVudCwgYXJndW1lbnRzTGlzdCk7XG5cdCAgfVxuXHR9KTtcblxuXHR2YXIgYXBwbHkgPSBwYXRoLlJlZmxlY3QuYXBwbHk7XG5cblx0dmFyIHNsaWNlID0gW10uc2xpY2U7XG5cdHZhciBmYWN0b3JpZXMgPSB7fTtcblxuXHR2YXIgY29uc3RydWN0ID0gZnVuY3Rpb24gKEMsIGFyZ3NMZW5ndGgsIGFyZ3MpIHtcblx0ICBpZiAoIShhcmdzTGVuZ3RoIGluIGZhY3RvcmllcykpIHtcblx0ICAgIGZvciAodmFyIGxpc3QgPSBbXSwgaSA9IDA7IGkgPCBhcmdzTGVuZ3RoOyBpKyspIGxpc3RbaV0gPSAnYVsnICsgaSArICddJztcblx0ICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1uZXctZnVuY1xuXHQgICAgZmFjdG9yaWVzW2FyZ3NMZW5ndGhdID0gRnVuY3Rpb24oJ0MsYScsICdyZXR1cm4gbmV3IEMoJyArIGxpc3Quam9pbignLCcpICsgJyknKTtcblx0ICB9IHJldHVybiBmYWN0b3JpZXNbYXJnc0xlbmd0aF0oQywgYXJncyk7XG5cdH07XG5cblx0Ly8gYEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kYCBtZXRob2QgaW1wbGVtZW50YXRpb25cblx0Ly8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtZnVuY3Rpb24ucHJvdG90eXBlLmJpbmRcblx0dmFyIGZ1bmN0aW9uQmluZCA9IEZ1bmN0aW9uLmJpbmQgfHwgZnVuY3Rpb24gYmluZCh0aGF0IC8qICwgLi4uYXJncyAqLykge1xuXHQgIHZhciBmbiA9IGFGdW5jdGlvbiQxKHRoaXMpO1xuXHQgIHZhciBwYXJ0QXJncyA9IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcblx0ICB2YXIgYm91bmRGdW5jdGlvbiA9IGZ1bmN0aW9uIGJvdW5kKC8qIGFyZ3MuLi4gKi8pIHtcblx0ICAgIHZhciBhcmdzID0gcGFydEFyZ3MuY29uY2F0KHNsaWNlLmNhbGwoYXJndW1lbnRzKSk7XG5cdCAgICByZXR1cm4gdGhpcyBpbnN0YW5jZW9mIGJvdW5kRnVuY3Rpb24gPyBjb25zdHJ1Y3QoZm4sIGFyZ3MubGVuZ3RoLCBhcmdzKSA6IGZuLmFwcGx5KHRoYXQsIGFyZ3MpO1xuXHQgIH07XG5cdCAgaWYgKGlzT2JqZWN0KGZuLnByb3RvdHlwZSkpIGJvdW5kRnVuY3Rpb24ucHJvdG90eXBlID0gZm4ucHJvdG90eXBlO1xuXHQgIHJldHVybiBib3VuZEZ1bmN0aW9uO1xuXHR9O1xuXG5cdHZhciBuYXRpdmVDb25zdHJ1Y3QgPSBnZXRCdWlsdEluKCdSZWZsZWN0JywgJ2NvbnN0cnVjdCcpO1xuXG5cdC8vIGBSZWZsZWN0LmNvbnN0cnVjdGAgbWV0aG9kXG5cdC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXJlZmxlY3QuY29uc3RydWN0XG5cdC8vIE1TIEVkZ2Ugc3VwcG9ydHMgb25seSAyIGFyZ3VtZW50cyBhbmQgYXJndW1lbnRzTGlzdCBhcmd1bWVudCBpcyBvcHRpb25hbFxuXHQvLyBGRiBOaWdodGx5IHNldHMgdGhpcmQgYXJndW1lbnQgYXMgYG5ldy50YXJnZXRgLCBidXQgZG9lcyBub3QgY3JlYXRlIGB0aGlzYCBmcm9tIGl0XG5cdHZhciBORVdfVEFSR0VUX0JVRyA9IGZhaWxzKGZ1bmN0aW9uICgpIHtcblx0ICBmdW5jdGlvbiBGKCkgeyAvKiBlbXB0eSAqLyB9XG5cdCAgcmV0dXJuICEobmF0aXZlQ29uc3RydWN0KGZ1bmN0aW9uICgpIHsgLyogZW1wdHkgKi8gfSwgW10sIEYpIGluc3RhbmNlb2YgRik7XG5cdH0pO1xuXHR2YXIgQVJHU19CVUcgPSAhZmFpbHMoZnVuY3Rpb24gKCkge1xuXHQgIG5hdGl2ZUNvbnN0cnVjdChmdW5jdGlvbiAoKSB7IC8qIGVtcHR5ICovIH0pO1xuXHR9KTtcblx0dmFyIEZPUkNFRCQ3ID0gTkVXX1RBUkdFVF9CVUcgfHwgQVJHU19CVUc7XG5cblx0X2V4cG9ydCh7IHRhcmdldDogJ1JlZmxlY3QnLCBzdGF0OiB0cnVlLCBmb3JjZWQ6IEZPUkNFRCQ3LCBzaGFtOiBGT1JDRUQkNyB9LCB7XG5cdCAgY29uc3RydWN0OiBmdW5jdGlvbiBjb25zdHJ1Y3QoVGFyZ2V0LCBhcmdzIC8qICwgbmV3VGFyZ2V0ICovKSB7XG5cdCAgICBhRnVuY3Rpb24kMShUYXJnZXQpO1xuXHQgICAgYW5PYmplY3QoYXJncyk7XG5cdCAgICB2YXIgbmV3VGFyZ2V0ID0gYXJndW1lbnRzLmxlbmd0aCA8IDMgPyBUYXJnZXQgOiBhRnVuY3Rpb24kMShhcmd1bWVudHNbMl0pO1xuXHQgICAgaWYgKEFSR1NfQlVHICYmICFORVdfVEFSR0VUX0JVRykgcmV0dXJuIG5hdGl2ZUNvbnN0cnVjdChUYXJnZXQsIGFyZ3MsIG5ld1RhcmdldCk7XG5cdCAgICBpZiAoVGFyZ2V0ID09IG5ld1RhcmdldCkge1xuXHQgICAgICAvLyB3L28gYWx0ZXJlZCBuZXdUYXJnZXQsIG9wdGltaXphdGlvbiBmb3IgMC00IGFyZ3VtZW50c1xuXHQgICAgICBzd2l0Y2ggKGFyZ3MubGVuZ3RoKSB7XG5cdCAgICAgICAgY2FzZSAwOiByZXR1cm4gbmV3IFRhcmdldCgpO1xuXHQgICAgICAgIGNhc2UgMTogcmV0dXJuIG5ldyBUYXJnZXQoYXJnc1swXSk7XG5cdCAgICAgICAgY2FzZSAyOiByZXR1cm4gbmV3IFRhcmdldChhcmdzWzBdLCBhcmdzWzFdKTtcblx0ICAgICAgICBjYXNlIDM6IHJldHVybiBuZXcgVGFyZ2V0KGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0pO1xuXHQgICAgICAgIGNhc2UgNDogcmV0dXJuIG5ldyBUYXJnZXQoYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSwgYXJnc1szXSk7XG5cdCAgICAgIH1cblx0ICAgICAgLy8gdy9vIGFsdGVyZWQgbmV3VGFyZ2V0LCBsb3Qgb2YgYXJndW1lbnRzIGNhc2Vcblx0ICAgICAgdmFyICRhcmdzID0gW251bGxdO1xuXHQgICAgICAkYXJncy5wdXNoLmFwcGx5KCRhcmdzLCBhcmdzKTtcblx0ICAgICAgcmV0dXJuIG5ldyAoZnVuY3Rpb25CaW5kLmFwcGx5KFRhcmdldCwgJGFyZ3MpKSgpO1xuXHQgICAgfVxuXHQgICAgLy8gd2l0aCBhbHRlcmVkIG5ld1RhcmdldCwgbm90IHN1cHBvcnQgYnVpbHQtaW4gY29uc3RydWN0b3JzXG5cdCAgICB2YXIgcHJvdG8gPSBuZXdUYXJnZXQucHJvdG90eXBlO1xuXHQgICAgdmFyIGluc3RhbmNlID0gb2JqZWN0Q3JlYXRlKGlzT2JqZWN0KHByb3RvKSA/IHByb3RvIDogT2JqZWN0LnByb3RvdHlwZSk7XG5cdCAgICB2YXIgcmVzdWx0ID0gRnVuY3Rpb24uYXBwbHkuY2FsbChUYXJnZXQsIGluc3RhbmNlLCBhcmdzKTtcblx0ICAgIHJldHVybiBpc09iamVjdChyZXN1bHQpID8gcmVzdWx0IDogaW5zdGFuY2U7XG5cdCAgfVxuXHR9KTtcblxuXHR2YXIgY29uc3RydWN0JDEgPSBwYXRoLlJlZmxlY3QuY29uc3RydWN0O1xuXG5cdC8vIE1TIEVkZ2UgaGFzIGJyb2tlbiBSZWZsZWN0LmRlZmluZVByb3BlcnR5IC0gdGhyb3dpbmcgaW5zdGVhZCBvZiByZXR1cm5pbmcgZmFsc2Vcblx0dmFyIEVSUk9SX0lOU1RFQURfT0ZfRkFMU0UgPSBmYWlscyhmdW5jdGlvbiAoKSB7XG5cdCAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmXG5cdCAgUmVmbGVjdC5kZWZpbmVQcm9wZXJ0eShvYmplY3REZWZpbmVQcm9wZXJ0eS5mKHt9LCAxLCB7IHZhbHVlOiAxIH0pLCAxLCB7IHZhbHVlOiAyIH0pO1xuXHR9KTtcblxuXHQvLyBgUmVmbGVjdC5kZWZpbmVQcm9wZXJ0eWAgbWV0aG9kXG5cdC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXJlZmxlY3QuZGVmaW5lcHJvcGVydHlcblx0X2V4cG9ydCh7IHRhcmdldDogJ1JlZmxlY3QnLCBzdGF0OiB0cnVlLCBmb3JjZWQ6IEVSUk9SX0lOU1RFQURfT0ZfRkFMU0UsIHNoYW06ICFkZXNjcmlwdG9ycyB9LCB7XG5cdCAgZGVmaW5lUHJvcGVydHk6IGZ1bmN0aW9uIGRlZmluZVByb3BlcnR5KHRhcmdldCwgcHJvcGVydHlLZXksIGF0dHJpYnV0ZXMpIHtcblx0ICAgIGFuT2JqZWN0KHRhcmdldCk7XG5cdCAgICB2YXIga2V5ID0gdG9QcmltaXRpdmUocHJvcGVydHlLZXksIHRydWUpO1xuXHQgICAgYW5PYmplY3QoYXR0cmlidXRlcyk7XG5cdCAgICB0cnkge1xuXHQgICAgICBvYmplY3REZWZpbmVQcm9wZXJ0eS5mKHRhcmdldCwga2V5LCBhdHRyaWJ1dGVzKTtcblx0ICAgICAgcmV0dXJuIHRydWU7XG5cdCAgICB9IGNhdGNoIChlcnJvcikge1xuXHQgICAgICByZXR1cm4gZmFsc2U7XG5cdCAgICB9XG5cdCAgfVxuXHR9KTtcblxuXHR2YXIgZGVmaW5lUHJvcGVydHkkNiA9IHBhdGguUmVmbGVjdC5kZWZpbmVQcm9wZXJ0eTtcblxuXHR2YXIgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yJDMgPSBvYmplY3RHZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IuZjtcblxuXHQvLyBgUmVmbGVjdC5kZWxldGVQcm9wZXJ0eWAgbWV0aG9kXG5cdC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXJlZmxlY3QuZGVsZXRlcHJvcGVydHlcblx0X2V4cG9ydCh7IHRhcmdldDogJ1JlZmxlY3QnLCBzdGF0OiB0cnVlIH0sIHtcblx0ICBkZWxldGVQcm9wZXJ0eTogZnVuY3Rpb24gZGVsZXRlUHJvcGVydHkodGFyZ2V0LCBwcm9wZXJ0eUtleSkge1xuXHQgICAgdmFyIGRlc2NyaXB0b3IgPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IkMyhhbk9iamVjdCh0YXJnZXQpLCBwcm9wZXJ0eUtleSk7XG5cdCAgICByZXR1cm4gZGVzY3JpcHRvciAmJiAhZGVzY3JpcHRvci5jb25maWd1cmFibGUgPyBmYWxzZSA6IGRlbGV0ZSB0YXJnZXRbcHJvcGVydHlLZXldO1xuXHQgIH1cblx0fSk7XG5cblx0dmFyIGRlbGV0ZVByb3BlcnR5ID0gcGF0aC5SZWZsZWN0LmRlbGV0ZVByb3BlcnR5O1xuXG5cdC8vIGBSZWZsZWN0LmdldGAgbWV0aG9kXG5cdC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXJlZmxlY3QuZ2V0XG5cdGZ1bmN0aW9uIGdldCQxKHRhcmdldCwgcHJvcGVydHlLZXkgLyogLCByZWNlaXZlciAqLykge1xuXHQgIHZhciByZWNlaXZlciA9IGFyZ3VtZW50cy5sZW5ndGggPCAzID8gdGFyZ2V0IDogYXJndW1lbnRzWzJdO1xuXHQgIHZhciBkZXNjcmlwdG9yLCBwcm90b3R5cGU7XG5cdCAgaWYgKGFuT2JqZWN0KHRhcmdldCkgPT09IHJlY2VpdmVyKSByZXR1cm4gdGFyZ2V0W3Byb3BlcnR5S2V5XTtcblx0ICBpZiAoZGVzY3JpcHRvciA9IG9iamVjdEdldE93blByb3BlcnR5RGVzY3JpcHRvci5mKHRhcmdldCwgcHJvcGVydHlLZXkpKSByZXR1cm4gaGFzKGRlc2NyaXB0b3IsICd2YWx1ZScpXG5cdCAgICA/IGRlc2NyaXB0b3IudmFsdWVcblx0ICAgIDogZGVzY3JpcHRvci5nZXQgPT09IHVuZGVmaW5lZFxuXHQgICAgICA/IHVuZGVmaW5lZFxuXHQgICAgICA6IGRlc2NyaXB0b3IuZ2V0LmNhbGwocmVjZWl2ZXIpO1xuXHQgIGlmIChpc09iamVjdChwcm90b3R5cGUgPSBvYmplY3RHZXRQcm90b3R5cGVPZih0YXJnZXQpKSkgcmV0dXJuIGdldCQxKHByb3RvdHlwZSwgcHJvcGVydHlLZXksIHJlY2VpdmVyKTtcblx0fVxuXG5cdF9leHBvcnQoeyB0YXJnZXQ6ICdSZWZsZWN0Jywgc3RhdDogdHJ1ZSB9LCB7XG5cdCAgZ2V0OiBnZXQkMVxuXHR9KTtcblxuXHR2YXIgZ2V0JDIgPSBwYXRoLlJlZmxlY3QuZ2V0O1xuXG5cdC8vIGBSZWZsZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcmAgbWV0aG9kXG5cdC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXJlZmxlY3QuZ2V0b3ducHJvcGVydHlkZXNjcmlwdG9yXG5cdF9leHBvcnQoeyB0YXJnZXQ6ICdSZWZsZWN0Jywgc3RhdDogdHJ1ZSwgc2hhbTogIWRlc2NyaXB0b3JzIH0sIHtcblx0ICBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I6IGZ1bmN0aW9uIGdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIHByb3BlcnR5S2V5KSB7XG5cdCAgICByZXR1cm4gb2JqZWN0R2V0T3duUHJvcGVydHlEZXNjcmlwdG9yLmYoYW5PYmplY3QodGFyZ2V0KSwgcHJvcGVydHlLZXkpO1xuXHQgIH1cblx0fSk7XG5cblx0dmFyIGdldE93blByb3BlcnR5RGVzY3JpcHRvciQ0ID0gcGF0aC5SZWZsZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcblxuXHQvLyBgUmVmbGVjdC5nZXRQcm90b3R5cGVPZmAgbWV0aG9kXG5cdC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXJlZmxlY3QuZ2V0cHJvdG90eXBlb2Zcblx0X2V4cG9ydCh7IHRhcmdldDogJ1JlZmxlY3QnLCBzdGF0OiB0cnVlLCBzaGFtOiAhY29ycmVjdFByb3RvdHlwZUdldHRlciB9LCB7XG5cdCAgZ2V0UHJvdG90eXBlT2Y6IGZ1bmN0aW9uIGdldFByb3RvdHlwZU9mKHRhcmdldCkge1xuXHQgICAgcmV0dXJuIG9iamVjdEdldFByb3RvdHlwZU9mKGFuT2JqZWN0KHRhcmdldCkpO1xuXHQgIH1cblx0fSk7XG5cblx0dmFyIGdldFByb3RvdHlwZU9mID0gcGF0aC5SZWZsZWN0LmdldFByb3RvdHlwZU9mO1xuXG5cdC8vIGBSZWZsZWN0Lmhhc2AgbWV0aG9kXG5cdC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXJlZmxlY3QuaGFzXG5cdF9leHBvcnQoeyB0YXJnZXQ6ICdSZWZsZWN0Jywgc3RhdDogdHJ1ZSB9LCB7XG5cdCAgaGFzOiBmdW5jdGlvbiBoYXModGFyZ2V0LCBwcm9wZXJ0eUtleSkge1xuXHQgICAgcmV0dXJuIHByb3BlcnR5S2V5IGluIHRhcmdldDtcblx0ICB9XG5cdH0pO1xuXG5cdHZhciBoYXMkMiA9IHBhdGguUmVmbGVjdC5oYXM7XG5cblx0dmFyIG9iamVjdElzRXh0ZW5zaWJsZSA9IE9iamVjdC5pc0V4dGVuc2libGU7XG5cblx0Ly8gYFJlZmxlY3QuaXNFeHRlbnNpYmxlYCBtZXRob2Rcblx0Ly8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtcmVmbGVjdC5pc2V4dGVuc2libGVcblx0X2V4cG9ydCh7IHRhcmdldDogJ1JlZmxlY3QnLCBzdGF0OiB0cnVlIH0sIHtcblx0ICBpc0V4dGVuc2libGU6IGZ1bmN0aW9uIGlzRXh0ZW5zaWJsZSh0YXJnZXQpIHtcblx0ICAgIGFuT2JqZWN0KHRhcmdldCk7XG5cdCAgICByZXR1cm4gb2JqZWN0SXNFeHRlbnNpYmxlID8gb2JqZWN0SXNFeHRlbnNpYmxlKHRhcmdldCkgOiB0cnVlO1xuXHQgIH1cblx0fSk7XG5cblx0dmFyIGlzRXh0ZW5zaWJsZSA9IHBhdGguUmVmbGVjdC5pc0V4dGVuc2libGU7XG5cblx0Ly8gYFJlZmxlY3Qub3duS2V5c2AgbWV0aG9kXG5cdC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXJlZmxlY3Qub3dua2V5c1xuXHRfZXhwb3J0KHsgdGFyZ2V0OiAnUmVmbGVjdCcsIHN0YXQ6IHRydWUgfSwge1xuXHQgIG93bktleXM6IG93bktleXNcblx0fSk7XG5cblx0dmFyIG93bktleXMkMSA9IHBhdGguUmVmbGVjdC5vd25LZXlzO1xuXG5cdC8vIGBSZWZsZWN0LnByZXZlbnRFeHRlbnNpb25zYCBtZXRob2Rcblx0Ly8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtcmVmbGVjdC5wcmV2ZW50ZXh0ZW5zaW9uc1xuXHRfZXhwb3J0KHsgdGFyZ2V0OiAnUmVmbGVjdCcsIHN0YXQ6IHRydWUsIHNoYW06ICFmcmVlemluZyB9LCB7XG5cdCAgcHJldmVudEV4dGVuc2lvbnM6IGZ1bmN0aW9uIHByZXZlbnRFeHRlbnNpb25zKHRhcmdldCkge1xuXHQgICAgYW5PYmplY3QodGFyZ2V0KTtcblx0ICAgIHRyeSB7XG5cdCAgICAgIHZhciBvYmplY3RQcmV2ZW50RXh0ZW5zaW9ucyA9IGdldEJ1aWx0SW4oJ09iamVjdCcsICdwcmV2ZW50RXh0ZW5zaW9ucycpO1xuXHQgICAgICBpZiAob2JqZWN0UHJldmVudEV4dGVuc2lvbnMpIG9iamVjdFByZXZlbnRFeHRlbnNpb25zKHRhcmdldCk7XG5cdCAgICAgIHJldHVybiB0cnVlO1xuXHQgICAgfSBjYXRjaCAoZXJyb3IpIHtcblx0ICAgICAgcmV0dXJuIGZhbHNlO1xuXHQgICAgfVxuXHQgIH1cblx0fSk7XG5cblx0dmFyIHByZXZlbnRFeHRlbnNpb25zID0gcGF0aC5SZWZsZWN0LnByZXZlbnRFeHRlbnNpb25zO1xuXG5cdC8vIGBSZWZsZWN0LnNldGAgbWV0aG9kXG5cdC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXJlZmxlY3Quc2V0XG5cdGZ1bmN0aW9uIHNldCQzKHRhcmdldCwgcHJvcGVydHlLZXksIFYgLyogLCByZWNlaXZlciAqLykge1xuXHQgIHZhciByZWNlaXZlciA9IGFyZ3VtZW50cy5sZW5ndGggPCA0ID8gdGFyZ2V0IDogYXJndW1lbnRzWzNdO1xuXHQgIHZhciBvd25EZXNjcmlwdG9yID0gb2JqZWN0R2V0T3duUHJvcGVydHlEZXNjcmlwdG9yLmYoYW5PYmplY3QodGFyZ2V0KSwgcHJvcGVydHlLZXkpO1xuXHQgIHZhciBleGlzdGluZ0Rlc2NyaXB0b3IsIHByb3RvdHlwZTtcblx0ICBpZiAoIW93bkRlc2NyaXB0b3IpIHtcblx0ICAgIGlmIChpc09iamVjdChwcm90b3R5cGUgPSBvYmplY3RHZXRQcm90b3R5cGVPZih0YXJnZXQpKSkge1xuXHQgICAgICByZXR1cm4gc2V0JDMocHJvdG90eXBlLCBwcm9wZXJ0eUtleSwgViwgcmVjZWl2ZXIpO1xuXHQgICAgfVxuXHQgICAgb3duRGVzY3JpcHRvciA9IGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvcigwKTtcblx0ICB9XG5cdCAgaWYgKGhhcyhvd25EZXNjcmlwdG9yLCAndmFsdWUnKSkge1xuXHQgICAgaWYgKG93bkRlc2NyaXB0b3Iud3JpdGFibGUgPT09IGZhbHNlIHx8ICFpc09iamVjdChyZWNlaXZlcikpIHJldHVybiBmYWxzZTtcblx0ICAgIGlmIChleGlzdGluZ0Rlc2NyaXB0b3IgPSBvYmplY3RHZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IuZihyZWNlaXZlciwgcHJvcGVydHlLZXkpKSB7XG5cdCAgICAgIGlmIChleGlzdGluZ0Rlc2NyaXB0b3IuZ2V0IHx8IGV4aXN0aW5nRGVzY3JpcHRvci5zZXQgfHwgZXhpc3RpbmdEZXNjcmlwdG9yLndyaXRhYmxlID09PSBmYWxzZSkgcmV0dXJuIGZhbHNlO1xuXHQgICAgICBleGlzdGluZ0Rlc2NyaXB0b3IudmFsdWUgPSBWO1xuXHQgICAgICBvYmplY3REZWZpbmVQcm9wZXJ0eS5mKHJlY2VpdmVyLCBwcm9wZXJ0eUtleSwgZXhpc3RpbmdEZXNjcmlwdG9yKTtcblx0ICAgIH0gZWxzZSBvYmplY3REZWZpbmVQcm9wZXJ0eS5mKHJlY2VpdmVyLCBwcm9wZXJ0eUtleSwgY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yKDAsIFYpKTtcblx0ICAgIHJldHVybiB0cnVlO1xuXHQgIH1cblx0ICByZXR1cm4gb3duRGVzY3JpcHRvci5zZXQgPT09IHVuZGVmaW5lZCA/IGZhbHNlIDogKG93bkRlc2NyaXB0b3Iuc2V0LmNhbGwocmVjZWl2ZXIsIFYpLCB0cnVlKTtcblx0fVxuXG5cdF9leHBvcnQoeyB0YXJnZXQ6ICdSZWZsZWN0Jywgc3RhdDogdHJ1ZSB9LCB7XG5cdCAgc2V0OiBzZXQkM1xuXHR9KTtcblxuXHR2YXIgc2V0JDQgPSBwYXRoLlJlZmxlY3Quc2V0O1xuXG5cdC8vIGBSZWZsZWN0LnNldFByb3RvdHlwZU9mYCBtZXRob2Rcblx0Ly8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtcmVmbGVjdC5zZXRwcm90b3R5cGVvZlxuXHRpZiAob2JqZWN0U2V0UHJvdG90eXBlT2YpIF9leHBvcnQoeyB0YXJnZXQ6ICdSZWZsZWN0Jywgc3RhdDogdHJ1ZSB9LCB7XG5cdCAgc2V0UHJvdG90eXBlT2Y6IGZ1bmN0aW9uIHNldFByb3RvdHlwZU9mKHRhcmdldCwgcHJvdG8pIHtcblx0ICAgIGFuT2JqZWN0KHRhcmdldCk7XG5cdCAgICBhUG9zc2libGVQcm90b3R5cGUocHJvdG8pO1xuXHQgICAgdHJ5IHtcblx0ICAgICAgb2JqZWN0U2V0UHJvdG90eXBlT2YodGFyZ2V0LCBwcm90byk7XG5cdCAgICAgIHJldHVybiB0cnVlO1xuXHQgICAgfSBjYXRjaCAoZXJyb3IpIHtcblx0ICAgICAgcmV0dXJuIGZhbHNlO1xuXHQgICAgfVxuXHQgIH1cblx0fSk7XG5cblx0dmFyIHNldFByb3RvdHlwZU9mJDEgPSBwYXRoLlJlZmxlY3Quc2V0UHJvdG90eXBlT2Y7XG5cblx0dmFyIGVzMjAxNVJlZmxlY3QgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcblx0fSk7XG5cblx0dW53cmFwRXhwb3J0cyhlczIwMTVSZWZsZWN0KTtcblxuXHR2YXIgJGluY2x1ZGVzID0gYXJyYXlJbmNsdWRlcy5pbmNsdWRlcztcblxuXG5cdC8vIGBBcnJheS5wcm90b3R5cGUuaW5jbHVkZXNgIG1ldGhvZFxuXHQvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUuaW5jbHVkZXNcblx0X2V4cG9ydCh7IHRhcmdldDogJ0FycmF5JywgcHJvdG86IHRydWUgfSwge1xuXHQgIGluY2x1ZGVzOiBmdW5jdGlvbiBpbmNsdWRlcyhlbCAvKiAsIGZyb21JbmRleCA9IDAgKi8pIHtcblx0ICAgIHJldHVybiAkaW5jbHVkZXModGhpcywgZWwsIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKTtcblx0ICB9XG5cdH0pO1xuXG5cdC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS1AQHVuc2NvcGFibGVzXG5cdGFkZFRvVW5zY29wYWJsZXMoJ2luY2x1ZGVzJyk7XG5cblx0dmFyIGluY2x1ZGVzJDEgPSBlbnRyeVVuYmluZCgnQXJyYXknLCAnaW5jbHVkZXMnKTtcblxuXHR2YXIgJGluY2x1ZGVzJDEgPSBhcnJheUluY2x1ZGVzLmluY2x1ZGVzO1xuXG5cdHZhciBhVHlwZWRBcnJheSQ2ID0gYXJyYXlCdWZmZXJWaWV3Q29yZS5hVHlwZWRBcnJheTtcblxuXHQvLyBgJVR5cGVkQXJyYXklLnByb3RvdHlwZS5pbmNsdWRlc2AgbWV0aG9kXG5cdC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLSV0eXBlZGFycmF5JS5wcm90b3R5cGUuaW5jbHVkZXNcblx0YXJyYXlCdWZmZXJWaWV3Q29yZS5leHBvcnRQcm90bygnaW5jbHVkZXMnLCBmdW5jdGlvbiBpbmNsdWRlcyhzZWFyY2hFbGVtZW50IC8qICwgZnJvbUluZGV4ICovKSB7XG5cdCAgcmV0dXJuICRpbmNsdWRlcyQxKGFUeXBlZEFycmF5JDYodGhpcyksIHNlYXJjaEVsZW1lbnQsIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKTtcblx0fSk7XG5cblx0dmFyIGVzMjAxNkFycmF5SW5jbHVkZSA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuXHR9KTtcblxuXHR1bndyYXBFeHBvcnRzKGVzMjAxNkFycmF5SW5jbHVkZSk7XG5cblx0dmFyIHByb3BlcnR5SXNFbnVtZXJhYmxlID0gb2JqZWN0UHJvcGVydHlJc0VudW1lcmFibGUuZjtcblxuXHQvLyBgT2JqZWN0LnsgZW50cmllcywgdmFsdWVzIH1gIG1ldGhvZHMgaW1wbGVtZW50YXRpb25cblx0dmFyIGNyZWF0ZU1ldGhvZCQ0ID0gZnVuY3Rpb24gKFRPX0VOVFJJRVMpIHtcblx0ICByZXR1cm4gZnVuY3Rpb24gKGl0KSB7XG5cdCAgICB2YXIgTyA9IHRvSW5kZXhlZE9iamVjdChpdCk7XG5cdCAgICB2YXIga2V5cyA9IG9iamVjdEtleXMoTyk7XG5cdCAgICB2YXIgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XG5cdCAgICB2YXIgaSA9IDA7XG5cdCAgICB2YXIgcmVzdWx0ID0gW107XG5cdCAgICB2YXIga2V5O1xuXHQgICAgd2hpbGUgKGxlbmd0aCA+IGkpIHtcblx0ICAgICAga2V5ID0ga2V5c1tpKytdO1xuXHQgICAgICBpZiAoIWRlc2NyaXB0b3JzIHx8IHByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwoTywga2V5KSkge1xuXHQgICAgICAgIHJlc3VsdC5wdXNoKFRPX0VOVFJJRVMgPyBba2V5LCBPW2tleV1dIDogT1trZXldKTtcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgICAgcmV0dXJuIHJlc3VsdDtcblx0ICB9O1xuXHR9O1xuXG5cdHZhciBvYmplY3RUb0FycmF5ID0ge1xuXHQgIC8vIGBPYmplY3QuZW50cmllc2AgbWV0aG9kXG5cdCAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtb2JqZWN0LmVudHJpZXNcblx0ICBlbnRyaWVzOiBjcmVhdGVNZXRob2QkNCh0cnVlKSxcblx0ICAvLyBgT2JqZWN0LnZhbHVlc2AgbWV0aG9kXG5cdCAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtb2JqZWN0LnZhbHVlc1xuXHQgIHZhbHVlczogY3JlYXRlTWV0aG9kJDQoZmFsc2UpXG5cdH07XG5cblx0dmFyICR2YWx1ZXMgPSBvYmplY3RUb0FycmF5LnZhbHVlcztcblxuXHQvLyBgT2JqZWN0LnZhbHVlc2AgbWV0aG9kXG5cdC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLW9iamVjdC52YWx1ZXNcblx0X2V4cG9ydCh7IHRhcmdldDogJ09iamVjdCcsIHN0YXQ6IHRydWUgfSwge1xuXHQgIHZhbHVlczogZnVuY3Rpb24gdmFsdWVzKE8pIHtcblx0ICAgIHJldHVybiAkdmFsdWVzKE8pO1xuXHQgIH1cblx0fSk7XG5cblx0dmFyIHZhbHVlcyQxID0gcGF0aC5PYmplY3QudmFsdWVzO1xuXG5cdHZhciAkZW50cmllcyA9IG9iamVjdFRvQXJyYXkuZW50cmllcztcblxuXHQvLyBgT2JqZWN0LmVudHJpZXNgIG1ldGhvZFxuXHQvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1vYmplY3QuZW50cmllc1xuXHRfZXhwb3J0KHsgdGFyZ2V0OiAnT2JqZWN0Jywgc3RhdDogdHJ1ZSB9LCB7XG5cdCAgZW50cmllczogZnVuY3Rpb24gZW50cmllcyhPKSB7XG5cdCAgICByZXR1cm4gJGVudHJpZXMoTyk7XG5cdCAgfVxuXHR9KTtcblxuXHR2YXIgZW50cmllcyQxID0gcGF0aC5PYmplY3QuZW50cmllcztcblxuXHQvLyBgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnNgIG1ldGhvZFxuXHQvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1vYmplY3QuZ2V0b3ducHJvcGVydHlkZXNjcmlwdG9yc1xuXHRfZXhwb3J0KHsgdGFyZ2V0OiAnT2JqZWN0Jywgc3RhdDogdHJ1ZSwgc2hhbTogIWRlc2NyaXB0b3JzIH0sIHtcblx0ICBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzOiBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKG9iamVjdCkge1xuXHQgICAgdmFyIE8gPSB0b0luZGV4ZWRPYmplY3Qob2JqZWN0KTtcblx0ICAgIHZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSBvYmplY3RHZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IuZjtcblx0ICAgIHZhciBrZXlzID0gb3duS2V5cyhPKTtcblx0ICAgIHZhciByZXN1bHQgPSB7fTtcblx0ICAgIHZhciBpbmRleCA9IDA7XG5cdCAgICB2YXIga2V5LCBkZXNjcmlwdG9yO1xuXHQgICAgd2hpbGUgKGtleXMubGVuZ3RoID4gaW5kZXgpIHtcblx0ICAgICAgZGVzY3JpcHRvciA9IGdldE93blByb3BlcnR5RGVzY3JpcHRvcihPLCBrZXkgPSBrZXlzW2luZGV4KytdKTtcblx0ICAgICAgaWYgKGRlc2NyaXB0b3IgIT09IHVuZGVmaW5lZCkgY3JlYXRlUHJvcGVydHkocmVzdWx0LCBrZXksIGRlc2NyaXB0b3IpO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIHJlc3VsdDtcblx0ICB9XG5cdH0pO1xuXG5cdHZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID0gcGF0aC5PYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycztcblxuXHR2YXIgZXMyMDE3T2JqZWN0ID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5cdH0pO1xuXG5cdHVud3JhcEV4cG9ydHMoZXMyMDE3T2JqZWN0KTtcblxuXHQvLyBodHRwczovL2dpdGh1Yi5jb20vdGMzOS9wcm9wb3NhbC1zdHJpbmctcGFkLXN0YXJ0LWVuZFxuXG5cblxuXG5cdHZhciBjZWlsJDIgPSBNYXRoLmNlaWw7XG5cblx0Ly8gYFN0cmluZy5wcm90b3R5cGUueyBwYWRTdGFydCwgcGFkRW5kIH1gIG1ldGhvZHMgaW1wbGVtZW50YXRpb25cblx0dmFyIGNyZWF0ZU1ldGhvZCQ1ID0gZnVuY3Rpb24gKElTX0VORCkge1xuXHQgIHJldHVybiBmdW5jdGlvbiAoJHRoaXMsIG1heExlbmd0aCwgZmlsbFN0cmluZykge1xuXHQgICAgdmFyIFMgPSBTdHJpbmcocmVxdWlyZU9iamVjdENvZXJjaWJsZSgkdGhpcykpO1xuXHQgICAgdmFyIHN0cmluZ0xlbmd0aCA9IFMubGVuZ3RoO1xuXHQgICAgdmFyIGZpbGxTdHIgPSBmaWxsU3RyaW5nID09PSB1bmRlZmluZWQgPyAnICcgOiBTdHJpbmcoZmlsbFN0cmluZyk7XG5cdCAgICB2YXIgaW50TWF4TGVuZ3RoID0gdG9MZW5ndGgobWF4TGVuZ3RoKTtcblx0ICAgIHZhciBmaWxsTGVuLCBzdHJpbmdGaWxsZXI7XG5cdCAgICBpZiAoaW50TWF4TGVuZ3RoIDw9IHN0cmluZ0xlbmd0aCB8fCBmaWxsU3RyID09ICcnKSByZXR1cm4gUztcblx0ICAgIGZpbGxMZW4gPSBpbnRNYXhMZW5ndGggLSBzdHJpbmdMZW5ndGg7XG5cdCAgICBzdHJpbmdGaWxsZXIgPSBzdHJpbmdSZXBlYXQuY2FsbChmaWxsU3RyLCBjZWlsJDIoZmlsbExlbiAvIGZpbGxTdHIubGVuZ3RoKSk7XG5cdCAgICBpZiAoc3RyaW5nRmlsbGVyLmxlbmd0aCA+IGZpbGxMZW4pIHN0cmluZ0ZpbGxlciA9IHN0cmluZ0ZpbGxlci5zbGljZSgwLCBmaWxsTGVuKTtcblx0ICAgIHJldHVybiBJU19FTkQgPyBTICsgc3RyaW5nRmlsbGVyIDogc3RyaW5nRmlsbGVyICsgUztcblx0ICB9O1xuXHR9O1xuXG5cdHZhciBzdHJpbmdQYWQgPSB7XG5cdCAgLy8gYFN0cmluZy5wcm90b3R5cGUucGFkU3RhcnRgIG1ldGhvZFxuXHQgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXN0cmluZy5wcm90b3R5cGUucGFkc3RhcnRcblx0ICBzdGFydDogY3JlYXRlTWV0aG9kJDUoZmFsc2UpLFxuXHQgIC8vIGBTdHJpbmcucHJvdG90eXBlLnBhZEVuZGAgbWV0aG9kXG5cdCAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtc3RyaW5nLnByb3RvdHlwZS5wYWRlbmRcblx0ICBlbmQ6IGNyZWF0ZU1ldGhvZCQ1KHRydWUpXG5cdH07XG5cblx0Ly8gaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzI4MFxuXG5cblx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHVuaWNvcm4vbm8tdW5zYWZlLXJlZ2V4XG5cdHZhciB3ZWJraXRTdHJpbmdQYWRCdWcgPSAvVmVyc2lvblxcLzEwXFwuXFxkKyhcXC5cXGQrKT8oIE1vYmlsZVxcL1xcdyspPyBTYWZhcmlcXC8vLnRlc3QodXNlckFnZW50KTtcblxuXHR2YXIgJHBhZFN0YXJ0ID0gc3RyaW5nUGFkLnN0YXJ0O1xuXG5cblx0Ly8gYFN0cmluZy5wcm90b3R5cGUucGFkU3RhcnRgIG1ldGhvZFxuXHQvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1zdHJpbmcucHJvdG90eXBlLnBhZHN0YXJ0XG5cdF9leHBvcnQoeyB0YXJnZXQ6ICdTdHJpbmcnLCBwcm90bzogdHJ1ZSwgZm9yY2VkOiB3ZWJraXRTdHJpbmdQYWRCdWcgfSwge1xuXHQgIHBhZFN0YXJ0OiBmdW5jdGlvbiBwYWRTdGFydChtYXhMZW5ndGggLyogLCBmaWxsU3RyaW5nID0gJyAnICovKSB7XG5cdCAgICByZXR1cm4gJHBhZFN0YXJ0KHRoaXMsIG1heExlbmd0aCwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpO1xuXHQgIH1cblx0fSk7XG5cblx0dmFyIHBhZFN0YXJ0ID0gZW50cnlVbmJpbmQoJ1N0cmluZycsICdwYWRTdGFydCcpO1xuXG5cdHZhciAkcGFkRW5kID0gc3RyaW5nUGFkLmVuZDtcblxuXG5cdC8vIGBTdHJpbmcucHJvdG90eXBlLnBhZEVuZGAgbWV0aG9kXG5cdC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXN0cmluZy5wcm90b3R5cGUucGFkZW5kXG5cdF9leHBvcnQoeyB0YXJnZXQ6ICdTdHJpbmcnLCBwcm90bzogdHJ1ZSwgZm9yY2VkOiB3ZWJraXRTdHJpbmdQYWRCdWcgfSwge1xuXHQgIHBhZEVuZDogZnVuY3Rpb24gcGFkRW5kKG1heExlbmd0aCAvKiAsIGZpbGxTdHJpbmcgPSAnICcgKi8pIHtcblx0ICAgIHJldHVybiAkcGFkRW5kKHRoaXMsIG1heExlbmd0aCwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpO1xuXHQgIH1cblx0fSk7XG5cblx0dmFyIHBhZEVuZCA9IGVudHJ5VW5iaW5kKCdTdHJpbmcnLCAncGFkRW5kJyk7XG5cblx0dmFyIGVzMjAxN1N0cmluZyA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuXHR9KTtcblxuXHR1bndyYXBFeHBvcnRzKGVzMjAxN1N0cmluZyk7XG5cblx0Ly8gYFRvSW5kZXhgIGFic3RyYWN0IG9wZXJhdGlvblxuXHQvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy10b2luZGV4XG5cdHZhciB0b0luZGV4ID0gZnVuY3Rpb24gKGl0KSB7XG5cdCAgaWYgKGl0ID09PSB1bmRlZmluZWQpIHJldHVybiAwO1xuXHQgIHZhciBudW1iZXIgPSB0b0ludGVnZXIoaXQpO1xuXHQgIHZhciBsZW5ndGggPSB0b0xlbmd0aChudW1iZXIpO1xuXHQgIGlmIChudW1iZXIgIT09IGxlbmd0aCkgdGhyb3cgUmFuZ2VFcnJvcignV3JvbmcgbGVuZ3RoIG9yIGluZGV4Jyk7XG5cdCAgcmV0dXJuIGxlbmd0aDtcblx0fTtcblxuXHR2YXIgYXJyYXlCdWZmZXIgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG5cblxuXHR2YXIgTkFUSVZFX0FSUkFZX0JVRkZFUiA9IGFycmF5QnVmZmVyVmlld0NvcmUuTkFUSVZFX0FSUkFZX0JVRkZFUjtcblxuXG5cblxuXG5cblxuXHR2YXIgZ2V0T3duUHJvcGVydHlOYW1lcyA9IG9iamVjdEdldE93blByb3BlcnR5TmFtZXMuZjtcblx0dmFyIGRlZmluZVByb3BlcnR5ID0gb2JqZWN0RGVmaW5lUHJvcGVydHkuZjtcblxuXG5cblxuXHR2YXIgZ2V0SW50ZXJuYWxTdGF0ZSA9IGludGVybmFsU3RhdGUuZ2V0O1xuXHR2YXIgc2V0SW50ZXJuYWxTdGF0ZSA9IGludGVybmFsU3RhdGUuc2V0O1xuXHR2YXIgQVJSQVlfQlVGRkVSID0gJ0FycmF5QnVmZmVyJztcblx0dmFyIERBVEFfVklFVyA9ICdEYXRhVmlldyc7XG5cdHZhciBQUk9UT1RZUEUgPSAncHJvdG90eXBlJztcblx0dmFyIFdST05HX0xFTkdUSCA9ICdXcm9uZyBsZW5ndGgnO1xuXHR2YXIgV1JPTkdfSU5ERVggPSAnV3JvbmcgaW5kZXgnO1xuXHR2YXIgTmF0aXZlQXJyYXlCdWZmZXIgPSBnbG9iYWxfMVtBUlJBWV9CVUZGRVJdO1xuXHR2YXIgJEFycmF5QnVmZmVyID0gTmF0aXZlQXJyYXlCdWZmZXI7XG5cdHZhciAkRGF0YVZpZXcgPSBnbG9iYWxfMVtEQVRBX1ZJRVddO1xuXHR2YXIgTWF0aCA9IGdsb2JhbF8xLk1hdGg7XG5cdHZhciBSYW5nZUVycm9yID0gZ2xvYmFsXzEuUmFuZ2VFcnJvcjtcblx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNoYWRvdy1yZXN0cmljdGVkLW5hbWVzXG5cdHZhciBJbmZpbml0eSA9IDEgLyAwO1xuXHR2YXIgYWJzID0gTWF0aC5hYnM7XG5cdHZhciBwb3cgPSBNYXRoLnBvdztcblx0dmFyIGZsb29yID0gTWF0aC5mbG9vcjtcblx0dmFyIGxvZyA9IE1hdGgubG9nO1xuXHR2YXIgTE4yID0gTWF0aC5MTjI7XG5cblx0Ly8gSUVFRTc1NCBjb252ZXJzaW9ucyBiYXNlZCBvbiBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2llZWU3NTRcblx0dmFyIHBhY2tJRUVFNzU0ID0gZnVuY3Rpb24gKG51bWJlciwgbWFudGlzc2FMZW5ndGgsIGJ5dGVzKSB7XG5cdCAgdmFyIGJ1ZmZlciA9IG5ldyBBcnJheShieXRlcyk7XG5cdCAgdmFyIGV4cG9uZW50TGVuZ3RoID0gYnl0ZXMgKiA4IC0gbWFudGlzc2FMZW5ndGggLSAxO1xuXHQgIHZhciBlTWF4ID0gKDEgPDwgZXhwb25lbnRMZW5ndGgpIC0gMTtcblx0ICB2YXIgZUJpYXMgPSBlTWF4ID4+IDE7XG5cdCAgdmFyIHJ0ID0gbWFudGlzc2FMZW5ndGggPT09IDIzID8gcG93KDIsIC0yNCkgLSBwb3coMiwgLTc3KSA6IDA7XG5cdCAgdmFyIHNpZ24gPSBudW1iZXIgPCAwIHx8IG51bWJlciA9PT0gMCAmJiAxIC8gbnVtYmVyIDwgMCA/IDEgOiAwO1xuXHQgIHZhciBpbmRleCA9IDA7XG5cdCAgdmFyIGV4cG9uZW50LCBtYW50aXNzYSwgYztcblx0ICBudW1iZXIgPSBhYnMobnVtYmVyKTtcblx0ICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1jb21wYXJlXG5cdCAgaWYgKG51bWJlciAhPSBudW1iZXIgfHwgbnVtYmVyID09PSBJbmZpbml0eSkge1xuXHQgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtY29tcGFyZVxuXHQgICAgbWFudGlzc2EgPSBudW1iZXIgIT0gbnVtYmVyID8gMSA6IDA7XG5cdCAgICBleHBvbmVudCA9IGVNYXg7XG5cdCAgfSBlbHNlIHtcblx0ICAgIGV4cG9uZW50ID0gZmxvb3IobG9nKG51bWJlcikgLyBMTjIpO1xuXHQgICAgaWYgKG51bWJlciAqIChjID0gcG93KDIsIC1leHBvbmVudCkpIDwgMSkge1xuXHQgICAgICBleHBvbmVudC0tO1xuXHQgICAgICBjICo9IDI7XG5cdCAgICB9XG5cdCAgICBpZiAoZXhwb25lbnQgKyBlQmlhcyA+PSAxKSB7XG5cdCAgICAgIG51bWJlciArPSBydCAvIGM7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICBudW1iZXIgKz0gcnQgKiBwb3coMiwgMSAtIGVCaWFzKTtcblx0ICAgIH1cblx0ICAgIGlmIChudW1iZXIgKiBjID49IDIpIHtcblx0ICAgICAgZXhwb25lbnQrKztcblx0ICAgICAgYyAvPSAyO1xuXHQgICAgfVxuXHQgICAgaWYgKGV4cG9uZW50ICsgZUJpYXMgPj0gZU1heCkge1xuXHQgICAgICBtYW50aXNzYSA9IDA7XG5cdCAgICAgIGV4cG9uZW50ID0gZU1heDtcblx0ICAgIH0gZWxzZSBpZiAoZXhwb25lbnQgKyBlQmlhcyA+PSAxKSB7XG5cdCAgICAgIG1hbnRpc3NhID0gKG51bWJlciAqIGMgLSAxKSAqIHBvdygyLCBtYW50aXNzYUxlbmd0aCk7XG5cdCAgICAgIGV4cG9uZW50ID0gZXhwb25lbnQgKyBlQmlhcztcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIG1hbnRpc3NhID0gbnVtYmVyICogcG93KDIsIGVCaWFzIC0gMSkgKiBwb3coMiwgbWFudGlzc2FMZW5ndGgpO1xuXHQgICAgICBleHBvbmVudCA9IDA7XG5cdCAgICB9XG5cdCAgfVxuXHQgIGZvciAoOyBtYW50aXNzYUxlbmd0aCA+PSA4OyBidWZmZXJbaW5kZXgrK10gPSBtYW50aXNzYSAmIDI1NSwgbWFudGlzc2EgLz0gMjU2LCBtYW50aXNzYUxlbmd0aCAtPSA4KTtcblx0ICBleHBvbmVudCA9IGV4cG9uZW50IDw8IG1hbnRpc3NhTGVuZ3RoIHwgbWFudGlzc2E7XG5cdCAgZXhwb25lbnRMZW5ndGggKz0gbWFudGlzc2FMZW5ndGg7XG5cdCAgZm9yICg7IGV4cG9uZW50TGVuZ3RoID4gMDsgYnVmZmVyW2luZGV4KytdID0gZXhwb25lbnQgJiAyNTUsIGV4cG9uZW50IC89IDI1NiwgZXhwb25lbnRMZW5ndGggLT0gOCk7XG5cdCAgYnVmZmVyWy0taW5kZXhdIHw9IHNpZ24gKiAxMjg7XG5cdCAgcmV0dXJuIGJ1ZmZlcjtcblx0fTtcblxuXHR2YXIgdW5wYWNrSUVFRTc1NCA9IGZ1bmN0aW9uIChidWZmZXIsIG1hbnRpc3NhTGVuZ3RoKSB7XG5cdCAgdmFyIGJ5dGVzID0gYnVmZmVyLmxlbmd0aDtcblx0ICB2YXIgZXhwb25lbnRMZW5ndGggPSBieXRlcyAqIDggLSBtYW50aXNzYUxlbmd0aCAtIDE7XG5cdCAgdmFyIGVNYXggPSAoMSA8PCBleHBvbmVudExlbmd0aCkgLSAxO1xuXHQgIHZhciBlQmlhcyA9IGVNYXggPj4gMTtcblx0ICB2YXIgbkJpdHMgPSBleHBvbmVudExlbmd0aCAtIDc7XG5cdCAgdmFyIGluZGV4ID0gYnl0ZXMgLSAxO1xuXHQgIHZhciBzaWduID0gYnVmZmVyW2luZGV4LS1dO1xuXHQgIHZhciBleHBvbmVudCA9IHNpZ24gJiAxMjc7XG5cdCAgdmFyIG1hbnRpc3NhO1xuXHQgIHNpZ24gPj49IDc7XG5cdCAgZm9yICg7IG5CaXRzID4gMDsgZXhwb25lbnQgPSBleHBvbmVudCAqIDI1NiArIGJ1ZmZlcltpbmRleF0sIGluZGV4LS0sIG5CaXRzIC09IDgpO1xuXHQgIG1hbnRpc3NhID0gZXhwb25lbnQgJiAoMSA8PCAtbkJpdHMpIC0gMTtcblx0ICBleHBvbmVudCA+Pj0gLW5CaXRzO1xuXHQgIG5CaXRzICs9IG1hbnRpc3NhTGVuZ3RoO1xuXHQgIGZvciAoOyBuQml0cyA+IDA7IG1hbnRpc3NhID0gbWFudGlzc2EgKiAyNTYgKyBidWZmZXJbaW5kZXhdLCBpbmRleC0tLCBuQml0cyAtPSA4KTtcblx0ICBpZiAoZXhwb25lbnQgPT09IDApIHtcblx0ICAgIGV4cG9uZW50ID0gMSAtIGVCaWFzO1xuXHQgIH0gZWxzZSBpZiAoZXhwb25lbnQgPT09IGVNYXgpIHtcblx0ICAgIHJldHVybiBtYW50aXNzYSA/IE5hTiA6IHNpZ24gPyAtSW5maW5pdHkgOiBJbmZpbml0eTtcblx0ICB9IGVsc2Uge1xuXHQgICAgbWFudGlzc2EgPSBtYW50aXNzYSArIHBvdygyLCBtYW50aXNzYUxlbmd0aCk7XG5cdCAgICBleHBvbmVudCA9IGV4cG9uZW50IC0gZUJpYXM7XG5cdCAgfSByZXR1cm4gKHNpZ24gPyAtMSA6IDEpICogbWFudGlzc2EgKiBwb3coMiwgZXhwb25lbnQgLSBtYW50aXNzYUxlbmd0aCk7XG5cdH07XG5cblx0dmFyIHVucGFja0ludDMyID0gZnVuY3Rpb24gKGJ1ZmZlcikge1xuXHQgIHJldHVybiBidWZmZXJbM10gPDwgMjQgfCBidWZmZXJbMl0gPDwgMTYgfCBidWZmZXJbMV0gPDwgOCB8IGJ1ZmZlclswXTtcblx0fTtcblxuXHR2YXIgcGFja0ludDggPSBmdW5jdGlvbiAobnVtYmVyKSB7XG5cdCAgcmV0dXJuIFtudW1iZXIgJiAweEZGXTtcblx0fTtcblxuXHR2YXIgcGFja0ludDE2ID0gZnVuY3Rpb24gKG51bWJlcikge1xuXHQgIHJldHVybiBbbnVtYmVyICYgMHhGRiwgbnVtYmVyID4+IDggJiAweEZGXTtcblx0fTtcblxuXHR2YXIgcGFja0ludDMyID0gZnVuY3Rpb24gKG51bWJlcikge1xuXHQgIHJldHVybiBbbnVtYmVyICYgMHhGRiwgbnVtYmVyID4+IDggJiAweEZGLCBudW1iZXIgPj4gMTYgJiAweEZGLCBudW1iZXIgPj4gMjQgJiAweEZGXTtcblx0fTtcblxuXHR2YXIgcGFja0Zsb2F0MzIgPSBmdW5jdGlvbiAobnVtYmVyKSB7XG5cdCAgcmV0dXJuIHBhY2tJRUVFNzU0KG51bWJlciwgMjMsIDQpO1xuXHR9O1xuXG5cdHZhciBwYWNrRmxvYXQ2NCA9IGZ1bmN0aW9uIChudW1iZXIpIHtcblx0ICByZXR1cm4gcGFja0lFRUU3NTQobnVtYmVyLCA1MiwgOCk7XG5cdH07XG5cblx0dmFyIGFkZEdldHRlciA9IGZ1bmN0aW9uIChDb25zdHJ1Y3Rvciwga2V5KSB7XG5cdCAgZGVmaW5lUHJvcGVydHkoQ29uc3RydWN0b3JbUFJPVE9UWVBFXSwga2V5LCB7IGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2V0SW50ZXJuYWxTdGF0ZSh0aGlzKVtrZXldOyB9IH0pO1xuXHR9O1xuXG5cdHZhciBnZXQgPSBmdW5jdGlvbiAodmlldywgY291bnQsIGluZGV4LCBpc0xpdHRsZUVuZGlhbikge1xuXHQgIHZhciBudW1JbmRleCA9ICtpbmRleDtcblx0ICB2YXIgaW50SW5kZXggPSB0b0luZGV4KG51bUluZGV4KTtcblx0ICB2YXIgc3RvcmUgPSBnZXRJbnRlcm5hbFN0YXRlKHZpZXcpO1xuXHQgIGlmIChpbnRJbmRleCArIGNvdW50ID4gc3RvcmUuYnl0ZUxlbmd0aCkgdGhyb3cgUmFuZ2VFcnJvcihXUk9OR19JTkRFWCk7XG5cdCAgdmFyIGJ5dGVzID0gZ2V0SW50ZXJuYWxTdGF0ZShzdG9yZS5idWZmZXIpLmJ5dGVzO1xuXHQgIHZhciBzdGFydCA9IGludEluZGV4ICsgc3RvcmUuYnl0ZU9mZnNldDtcblx0ICB2YXIgcGFjayA9IGJ5dGVzLnNsaWNlKHN0YXJ0LCBzdGFydCArIGNvdW50KTtcblx0ICByZXR1cm4gaXNMaXR0bGVFbmRpYW4gPyBwYWNrIDogcGFjay5yZXZlcnNlKCk7XG5cdH07XG5cblx0dmFyIHNldCA9IGZ1bmN0aW9uICh2aWV3LCBjb3VudCwgaW5kZXgsIGNvbnZlcnNpb24sIHZhbHVlLCBpc0xpdHRsZUVuZGlhbikge1xuXHQgIHZhciBudW1JbmRleCA9ICtpbmRleDtcblx0ICB2YXIgaW50SW5kZXggPSB0b0luZGV4KG51bUluZGV4KTtcblx0ICB2YXIgc3RvcmUgPSBnZXRJbnRlcm5hbFN0YXRlKHZpZXcpO1xuXHQgIGlmIChpbnRJbmRleCArIGNvdW50ID4gc3RvcmUuYnl0ZUxlbmd0aCkgdGhyb3cgUmFuZ2VFcnJvcihXUk9OR19JTkRFWCk7XG5cdCAgdmFyIGJ5dGVzID0gZ2V0SW50ZXJuYWxTdGF0ZShzdG9yZS5idWZmZXIpLmJ5dGVzO1xuXHQgIHZhciBzdGFydCA9IGludEluZGV4ICsgc3RvcmUuYnl0ZU9mZnNldDtcblx0ICB2YXIgcGFjayA9IGNvbnZlcnNpb24oK3ZhbHVlKTtcblx0ICBmb3IgKHZhciBpID0gMDsgaSA8IGNvdW50OyBpKyspIGJ5dGVzW3N0YXJ0ICsgaV0gPSBwYWNrW2lzTGl0dGxlRW5kaWFuID8gaSA6IGNvdW50IC0gaSAtIDFdO1xuXHR9O1xuXG5cdGlmICghTkFUSVZFX0FSUkFZX0JVRkZFUikge1xuXHQgICRBcnJheUJ1ZmZlciA9IGZ1bmN0aW9uIEFycmF5QnVmZmVyKGxlbmd0aCkge1xuXHQgICAgYW5JbnN0YW5jZSh0aGlzLCAkQXJyYXlCdWZmZXIsIEFSUkFZX0JVRkZFUik7XG5cdCAgICB2YXIgYnl0ZUxlbmd0aCA9IHRvSW5kZXgobGVuZ3RoKTtcblx0ICAgIHNldEludGVybmFsU3RhdGUodGhpcywge1xuXHQgICAgICBieXRlczogYXJyYXlGaWxsLmNhbGwobmV3IEFycmF5KGJ5dGVMZW5ndGgpLCAwKSxcblx0ICAgICAgYnl0ZUxlbmd0aDogYnl0ZUxlbmd0aFxuXHQgICAgfSk7XG5cdCAgICBpZiAoIWRlc2NyaXB0b3JzKSB0aGlzLmJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoO1xuXHQgIH07XG5cblx0ICAkRGF0YVZpZXcgPSBmdW5jdGlvbiBEYXRhVmlldyhidWZmZXIsIGJ5dGVPZmZzZXQsIGJ5dGVMZW5ndGgpIHtcblx0ICAgIGFuSW5zdGFuY2UodGhpcywgJERhdGFWaWV3LCBEQVRBX1ZJRVcpO1xuXHQgICAgYW5JbnN0YW5jZShidWZmZXIsICRBcnJheUJ1ZmZlciwgREFUQV9WSUVXKTtcblx0ICAgIHZhciBidWZmZXJMZW5ndGggPSBnZXRJbnRlcm5hbFN0YXRlKGJ1ZmZlcikuYnl0ZUxlbmd0aDtcblx0ICAgIHZhciBvZmZzZXQgPSB0b0ludGVnZXIoYnl0ZU9mZnNldCk7XG5cdCAgICBpZiAob2Zmc2V0IDwgMCB8fCBvZmZzZXQgPiBidWZmZXJMZW5ndGgpIHRocm93IFJhbmdlRXJyb3IoJ1dyb25nIG9mZnNldCcpO1xuXHQgICAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPT09IHVuZGVmaW5lZCA/IGJ1ZmZlckxlbmd0aCAtIG9mZnNldCA6IHRvTGVuZ3RoKGJ5dGVMZW5ndGgpO1xuXHQgICAgaWYgKG9mZnNldCArIGJ5dGVMZW5ndGggPiBidWZmZXJMZW5ndGgpIHRocm93IFJhbmdlRXJyb3IoV1JPTkdfTEVOR1RIKTtcblx0ICAgIHNldEludGVybmFsU3RhdGUodGhpcywge1xuXHQgICAgICBidWZmZXI6IGJ1ZmZlcixcblx0ICAgICAgYnl0ZUxlbmd0aDogYnl0ZUxlbmd0aCxcblx0ICAgICAgYnl0ZU9mZnNldDogb2Zmc2V0XG5cdCAgICB9KTtcblx0ICAgIGlmICghZGVzY3JpcHRvcnMpIHtcblx0ICAgICAgdGhpcy5idWZmZXIgPSBidWZmZXI7XG5cdCAgICAgIHRoaXMuYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGg7XG5cdCAgICAgIHRoaXMuYnl0ZU9mZnNldCA9IG9mZnNldDtcblx0ICAgIH1cblx0ICB9O1xuXG5cdCAgaWYgKGRlc2NyaXB0b3JzKSB7XG5cdCAgICBhZGRHZXR0ZXIoJEFycmF5QnVmZmVyLCAnYnl0ZUxlbmd0aCcpO1xuXHQgICAgYWRkR2V0dGVyKCREYXRhVmlldywgJ2J1ZmZlcicpO1xuXHQgICAgYWRkR2V0dGVyKCREYXRhVmlldywgJ2J5dGVMZW5ndGgnKTtcblx0ICAgIGFkZEdldHRlcigkRGF0YVZpZXcsICdieXRlT2Zmc2V0Jyk7XG5cdCAgfVxuXG5cdCAgcmVkZWZpbmVBbGwoJERhdGFWaWV3W1BST1RPVFlQRV0sIHtcblx0ICAgIGdldEludDg6IGZ1bmN0aW9uIGdldEludDgoYnl0ZU9mZnNldCkge1xuXHQgICAgICByZXR1cm4gZ2V0KHRoaXMsIDEsIGJ5dGVPZmZzZXQpWzBdIDw8IDI0ID4+IDI0O1xuXHQgICAgfSxcblx0ICAgIGdldFVpbnQ4OiBmdW5jdGlvbiBnZXRVaW50OChieXRlT2Zmc2V0KSB7XG5cdCAgICAgIHJldHVybiBnZXQodGhpcywgMSwgYnl0ZU9mZnNldClbMF07XG5cdCAgICB9LFxuXHQgICAgZ2V0SW50MTY6IGZ1bmN0aW9uIGdldEludDE2KGJ5dGVPZmZzZXQgLyogLCBsaXR0bGVFbmRpYW4gKi8pIHtcblx0ICAgICAgdmFyIGJ5dGVzID0gZ2V0KHRoaXMsIDIsIGJ5dGVPZmZzZXQsIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKTtcblx0ICAgICAgcmV0dXJuIChieXRlc1sxXSA8PCA4IHwgYnl0ZXNbMF0pIDw8IDE2ID4+IDE2O1xuXHQgICAgfSxcblx0ICAgIGdldFVpbnQxNjogZnVuY3Rpb24gZ2V0VWludDE2KGJ5dGVPZmZzZXQgLyogLCBsaXR0bGVFbmRpYW4gKi8pIHtcblx0ICAgICAgdmFyIGJ5dGVzID0gZ2V0KHRoaXMsIDIsIGJ5dGVPZmZzZXQsIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKTtcblx0ICAgICAgcmV0dXJuIGJ5dGVzWzFdIDw8IDggfCBieXRlc1swXTtcblx0ICAgIH0sXG5cdCAgICBnZXRJbnQzMjogZnVuY3Rpb24gZ2V0SW50MzIoYnl0ZU9mZnNldCAvKiAsIGxpdHRsZUVuZGlhbiAqLykge1xuXHQgICAgICByZXR1cm4gdW5wYWNrSW50MzIoZ2V0KHRoaXMsIDQsIGJ5dGVPZmZzZXQsIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKSk7XG5cdCAgICB9LFxuXHQgICAgZ2V0VWludDMyOiBmdW5jdGlvbiBnZXRVaW50MzIoYnl0ZU9mZnNldCAvKiAsIGxpdHRsZUVuZGlhbiAqLykge1xuXHQgICAgICByZXR1cm4gdW5wYWNrSW50MzIoZ2V0KHRoaXMsIDQsIGJ5dGVPZmZzZXQsIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKSkgPj4+IDA7XG5cdCAgICB9LFxuXHQgICAgZ2V0RmxvYXQzMjogZnVuY3Rpb24gZ2V0RmxvYXQzMihieXRlT2Zmc2V0IC8qICwgbGl0dGxlRW5kaWFuICovKSB7XG5cdCAgICAgIHJldHVybiB1bnBhY2tJRUVFNzU0KGdldCh0aGlzLCA0LCBieXRlT2Zmc2V0LCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCksIDIzKTtcblx0ICAgIH0sXG5cdCAgICBnZXRGbG9hdDY0OiBmdW5jdGlvbiBnZXRGbG9hdDY0KGJ5dGVPZmZzZXQgLyogLCBsaXR0bGVFbmRpYW4gKi8pIHtcblx0ICAgICAgcmV0dXJuIHVucGFja0lFRUU3NTQoZ2V0KHRoaXMsIDgsIGJ5dGVPZmZzZXQsIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKSwgNTIpO1xuXHQgICAgfSxcblx0ICAgIHNldEludDg6IGZ1bmN0aW9uIHNldEludDgoYnl0ZU9mZnNldCwgdmFsdWUpIHtcblx0ICAgICAgc2V0KHRoaXMsIDEsIGJ5dGVPZmZzZXQsIHBhY2tJbnQ4LCB2YWx1ZSk7XG5cdCAgICB9LFxuXHQgICAgc2V0VWludDg6IGZ1bmN0aW9uIHNldFVpbnQ4KGJ5dGVPZmZzZXQsIHZhbHVlKSB7XG5cdCAgICAgIHNldCh0aGlzLCAxLCBieXRlT2Zmc2V0LCBwYWNrSW50OCwgdmFsdWUpO1xuXHQgICAgfSxcblx0ICAgIHNldEludDE2OiBmdW5jdGlvbiBzZXRJbnQxNihieXRlT2Zmc2V0LCB2YWx1ZSAvKiAsIGxpdHRsZUVuZGlhbiAqLykge1xuXHQgICAgICBzZXQodGhpcywgMiwgYnl0ZU9mZnNldCwgcGFja0ludDE2LCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCA+IDIgPyBhcmd1bWVudHNbMl0gOiB1bmRlZmluZWQpO1xuXHQgICAgfSxcblx0ICAgIHNldFVpbnQxNjogZnVuY3Rpb24gc2V0VWludDE2KGJ5dGVPZmZzZXQsIHZhbHVlIC8qICwgbGl0dGxlRW5kaWFuICovKSB7XG5cdCAgICAgIHNldCh0aGlzLCAyLCBieXRlT2Zmc2V0LCBwYWNrSW50MTYsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoID4gMiA/IGFyZ3VtZW50c1syXSA6IHVuZGVmaW5lZCk7XG5cdCAgICB9LFxuXHQgICAgc2V0SW50MzI6IGZ1bmN0aW9uIHNldEludDMyKGJ5dGVPZmZzZXQsIHZhbHVlIC8qICwgbGl0dGxlRW5kaWFuICovKSB7XG5cdCAgICAgIHNldCh0aGlzLCA0LCBieXRlT2Zmc2V0LCBwYWNrSW50MzIsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoID4gMiA/IGFyZ3VtZW50c1syXSA6IHVuZGVmaW5lZCk7XG5cdCAgICB9LFxuXHQgICAgc2V0VWludDMyOiBmdW5jdGlvbiBzZXRVaW50MzIoYnl0ZU9mZnNldCwgdmFsdWUgLyogLCBsaXR0bGVFbmRpYW4gKi8pIHtcblx0ICAgICAgc2V0KHRoaXMsIDQsIGJ5dGVPZmZzZXQsIHBhY2tJbnQzMiwgdmFsdWUsIGFyZ3VtZW50cy5sZW5ndGggPiAyID8gYXJndW1lbnRzWzJdIDogdW5kZWZpbmVkKTtcblx0ICAgIH0sXG5cdCAgICBzZXRGbG9hdDMyOiBmdW5jdGlvbiBzZXRGbG9hdDMyKGJ5dGVPZmZzZXQsIHZhbHVlIC8qICwgbGl0dGxlRW5kaWFuICovKSB7XG5cdCAgICAgIHNldCh0aGlzLCA0LCBieXRlT2Zmc2V0LCBwYWNrRmxvYXQzMiwgdmFsdWUsIGFyZ3VtZW50cy5sZW5ndGggPiAyID8gYXJndW1lbnRzWzJdIDogdW5kZWZpbmVkKTtcblx0ICAgIH0sXG5cdCAgICBzZXRGbG9hdDY0OiBmdW5jdGlvbiBzZXRGbG9hdDY0KGJ5dGVPZmZzZXQsIHZhbHVlIC8qICwgbGl0dGxlRW5kaWFuICovKSB7XG5cdCAgICAgIHNldCh0aGlzLCA4LCBieXRlT2Zmc2V0LCBwYWNrRmxvYXQ2NCwgdmFsdWUsIGFyZ3VtZW50cy5sZW5ndGggPiAyID8gYXJndW1lbnRzWzJdIDogdW5kZWZpbmVkKTtcblx0ICAgIH1cblx0ICB9KTtcblx0fSBlbHNlIHtcblx0ICBpZiAoIWZhaWxzKGZ1bmN0aW9uICgpIHtcblx0ICAgIE5hdGl2ZUFycmF5QnVmZmVyKDEpO1xuXHQgIH0pIHx8ICFmYWlscyhmdW5jdGlvbiAoKSB7XG5cdCAgICBuZXcgTmF0aXZlQXJyYXlCdWZmZXIoLTEpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5ld1xuXHQgIH0pIHx8IGZhaWxzKGZ1bmN0aW9uICgpIHtcblx0ICAgIG5ldyBOYXRpdmVBcnJheUJ1ZmZlcigpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5ld1xuXHQgICAgbmV3IE5hdGl2ZUFycmF5QnVmZmVyKDEuNSk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmV3XG5cdCAgICBuZXcgTmF0aXZlQXJyYXlCdWZmZXIoTmFOKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXdcblx0ICAgIHJldHVybiBOYXRpdmVBcnJheUJ1ZmZlci5uYW1lICE9IEFSUkFZX0JVRkZFUjtcblx0ICB9KSkge1xuXHQgICAgJEFycmF5QnVmZmVyID0gZnVuY3Rpb24gQXJyYXlCdWZmZXIobGVuZ3RoKSB7XG5cdCAgICAgIGFuSW5zdGFuY2UodGhpcywgJEFycmF5QnVmZmVyKTtcblx0ICAgICAgcmV0dXJuIG5ldyBOYXRpdmVBcnJheUJ1ZmZlcih0b0luZGV4KGxlbmd0aCkpO1xuXHQgICAgfTtcblx0ICAgIHZhciBBcnJheUJ1ZmZlclByb3RvdHlwZSA9ICRBcnJheUJ1ZmZlcltQUk9UT1RZUEVdID0gTmF0aXZlQXJyYXlCdWZmZXJbUFJPVE9UWVBFXTtcblx0ICAgIGZvciAodmFyIGtleXMgPSBnZXRPd25Qcm9wZXJ0eU5hbWVzKE5hdGl2ZUFycmF5QnVmZmVyKSwgaiA9IDAsIGtleTsga2V5cy5sZW5ndGggPiBqOykge1xuXHQgICAgICBpZiAoISgoa2V5ID0ga2V5c1tqKytdKSBpbiAkQXJyYXlCdWZmZXIpKSBoaWRlKCRBcnJheUJ1ZmZlciwga2V5LCBOYXRpdmVBcnJheUJ1ZmZlcltrZXldKTtcblx0ICAgIH1cblx0ICAgIEFycmF5QnVmZmVyUHJvdG90eXBlLmNvbnN0cnVjdG9yID0gJEFycmF5QnVmZmVyO1xuXHQgIH1cblx0ICAvLyBpT1MgU2FmYXJpIDcueCBidWdcblx0ICB2YXIgdGVzdFZpZXcgPSBuZXcgJERhdGFWaWV3KG5ldyAkQXJyYXlCdWZmZXIoMikpO1xuXHQgIHZhciBuYXRpdmVTZXRJbnQ4ID0gJERhdGFWaWV3W1BST1RPVFlQRV0uc2V0SW50ODtcblx0ICB0ZXN0Vmlldy5zZXRJbnQ4KDAsIDIxNDc0ODM2NDgpO1xuXHQgIHRlc3RWaWV3LnNldEludDgoMSwgMjE0NzQ4MzY0OSk7XG5cdCAgaWYgKHRlc3RWaWV3LmdldEludDgoMCkgfHwgIXRlc3RWaWV3LmdldEludDgoMSkpIHJlZGVmaW5lQWxsKCREYXRhVmlld1tQUk9UT1RZUEVdLCB7XG5cdCAgICBzZXRJbnQ4OiBmdW5jdGlvbiBzZXRJbnQ4KGJ5dGVPZmZzZXQsIHZhbHVlKSB7XG5cdCAgICAgIG5hdGl2ZVNldEludDguY2FsbCh0aGlzLCBieXRlT2Zmc2V0LCB2YWx1ZSA8PCAyNCA+PiAyNCk7XG5cdCAgICB9LFxuXHQgICAgc2V0VWludDg6IGZ1bmN0aW9uIHNldFVpbnQ4KGJ5dGVPZmZzZXQsIHZhbHVlKSB7XG5cdCAgICAgIG5hdGl2ZVNldEludDguY2FsbCh0aGlzLCBieXRlT2Zmc2V0LCB2YWx1ZSA8PCAyNCA+PiAyNCk7XG5cdCAgICB9XG5cdCAgfSwgeyB1bnNhZmU6IHRydWUgfSk7XG5cdH1cblxuXHRzZXRUb1N0cmluZ1RhZygkQXJyYXlCdWZmZXIsIEFSUkFZX0JVRkZFUik7XG5cdHNldFRvU3RyaW5nVGFnKCREYXRhVmlldywgREFUQV9WSUVXKTtcblx0ZXhwb3J0c1tBUlJBWV9CVUZGRVJdID0gJEFycmF5QnVmZmVyO1xuXHRleHBvcnRzW0RBVEFfVklFV10gPSAkRGF0YVZpZXc7XG5cdH0pO1xuXG5cdHZhciB0b09mZnNldCA9IGZ1bmN0aW9uIChpdCwgQllURVMpIHtcblx0ICB2YXIgb2Zmc2V0ID0gdG9JbnRlZ2VyKGl0KTtcblx0ICBpZiAob2Zmc2V0IDwgMCB8fCBvZmZzZXQgJSBCWVRFUykgdGhyb3cgUmFuZ2VFcnJvcignV3Jvbmcgb2Zmc2V0Jyk7XG5cdCAgcmV0dXJuIG9mZnNldDtcblx0fTtcblxuXHR2YXIgdHlwZWRBcnJheUNvbnN0cnVjdG9yID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSkge1xuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXHR2YXIgZ2V0T3duUHJvcGVydHlOYW1lcyA9IG9iamVjdEdldE93blByb3BlcnR5TmFtZXMuZjtcblxuXHR2YXIgZm9yRWFjaCA9IGFycmF5SXRlcmF0aW9uLmZvckVhY2g7XG5cblxuXG5cblxuXHR2YXIgZ2V0SW50ZXJuYWxTdGF0ZSA9IGludGVybmFsU3RhdGUuZ2V0O1xuXHR2YXIgc2V0SW50ZXJuYWxTdGF0ZSA9IGludGVybmFsU3RhdGUuc2V0O1xuXHR2YXIgbmF0aXZlRGVmaW5lUHJvcGVydHkgPSBvYmplY3REZWZpbmVQcm9wZXJ0eS5mO1xuXHR2YXIgbmF0aXZlR2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gb2JqZWN0R2V0T3duUHJvcGVydHlEZXNjcmlwdG9yLmY7XG5cdHZhciByb3VuZCA9IE1hdGgucm91bmQ7XG5cdHZhciBSYW5nZUVycm9yID0gZ2xvYmFsXzEuUmFuZ2VFcnJvcjtcblx0dmFyIEFycmF5QnVmZmVyID0gYXJyYXlCdWZmZXIuQXJyYXlCdWZmZXI7XG5cdHZhciBEYXRhVmlldyA9IGFycmF5QnVmZmVyLkRhdGFWaWV3O1xuXHR2YXIgTkFUSVZFX0FSUkFZX0JVRkZFUl9WSUVXUyA9IGFycmF5QnVmZmVyVmlld0NvcmUuTkFUSVZFX0FSUkFZX0JVRkZFUl9WSUVXUztcblx0dmFyIFRZUEVEX0FSUkFZX1RBRyA9IGFycmF5QnVmZmVyVmlld0NvcmUuVFlQRURfQVJSQVlfVEFHO1xuXHR2YXIgVHlwZWRBcnJheSA9IGFycmF5QnVmZmVyVmlld0NvcmUuVHlwZWRBcnJheTtcblx0dmFyIFR5cGVkQXJyYXlQcm90b3R5cGUgPSBhcnJheUJ1ZmZlclZpZXdDb3JlLlR5cGVkQXJyYXlQcm90b3R5cGU7XG5cdHZhciBhVHlwZWRBcnJheUNvbnN0cnVjdG9yID0gYXJyYXlCdWZmZXJWaWV3Q29yZS5hVHlwZWRBcnJheUNvbnN0cnVjdG9yO1xuXHR2YXIgaXNUeXBlZEFycmF5ID0gYXJyYXlCdWZmZXJWaWV3Q29yZS5pc1R5cGVkQXJyYXk7XG5cdHZhciBCWVRFU19QRVJfRUxFTUVOVCA9ICdCWVRFU19QRVJfRUxFTUVOVCc7XG5cdHZhciBXUk9OR19MRU5HVEggPSAnV3JvbmcgbGVuZ3RoJztcblxuXHR2YXIgZnJvbUxpc3QgPSBmdW5jdGlvbiAoQywgbGlzdCkge1xuXHQgIHZhciBpbmRleCA9IDA7XG5cdCAgdmFyIGxlbmd0aCA9IGxpc3QubGVuZ3RoO1xuXHQgIHZhciByZXN1bHQgPSBuZXcgKGFUeXBlZEFycmF5Q29uc3RydWN0b3IoQykpKGxlbmd0aCk7XG5cdCAgd2hpbGUgKGxlbmd0aCA+IGluZGV4KSByZXN1bHRbaW5kZXhdID0gbGlzdFtpbmRleCsrXTtcblx0ICByZXR1cm4gcmVzdWx0O1xuXHR9O1xuXG5cdHZhciBhZGRHZXR0ZXIgPSBmdW5jdGlvbiAoaXQsIGtleSkge1xuXHQgIG5hdGl2ZURlZmluZVByb3BlcnR5KGl0LCBrZXksIHsgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICByZXR1cm4gZ2V0SW50ZXJuYWxTdGF0ZSh0aGlzKVtrZXldO1xuXHQgIH0gfSk7XG5cdH07XG5cblx0dmFyIGlzQXJyYXlCdWZmZXIgPSBmdW5jdGlvbiAoaXQpIHtcblx0ICB2YXIga2xhc3M7XG5cdCAgcmV0dXJuIGl0IGluc3RhbmNlb2YgQXJyYXlCdWZmZXIgfHwgKGtsYXNzID0gY2xhc3NvZihpdCkpID09ICdBcnJheUJ1ZmZlcicgfHwga2xhc3MgPT0gJ1NoYXJlZEFycmF5QnVmZmVyJztcblx0fTtcblxuXHR2YXIgaXNUeXBlZEFycmF5SW5kZXggPSBmdW5jdGlvbiAodGFyZ2V0LCBrZXkpIHtcblx0ICByZXR1cm4gaXNUeXBlZEFycmF5KHRhcmdldClcblx0ICAgICYmIHR5cGVvZiBrZXkgIT0gJ3N5bWJvbCdcblx0ICAgICYmIGtleSBpbiB0YXJnZXRcblx0ICAgICYmIFN0cmluZygra2V5KSA9PSBTdHJpbmcoa2V5KTtcblx0fTtcblxuXHR2YXIgd3JhcHBlZEdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IGZ1bmN0aW9uIGdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkge1xuXHQgIHJldHVybiBpc1R5cGVkQXJyYXlJbmRleCh0YXJnZXQsIGtleSA9IHRvUHJpbWl0aXZlKGtleSwgdHJ1ZSkpXG5cdCAgICA/IGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvcigyLCB0YXJnZXRba2V5XSlcblx0ICAgIDogbmF0aXZlR2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KTtcblx0fTtcblxuXHR2YXIgd3JhcHBlZERlZmluZVByb3BlcnR5ID0gZnVuY3Rpb24gZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIGRlc2NyaXB0b3IpIHtcblx0ICBpZiAoaXNUeXBlZEFycmF5SW5kZXgodGFyZ2V0LCBrZXkgPSB0b1ByaW1pdGl2ZShrZXksIHRydWUpKVxuXHQgICAgJiYgaXNPYmplY3QoZGVzY3JpcHRvcilcblx0ICAgICYmIGhhcyhkZXNjcmlwdG9yLCAndmFsdWUnKVxuXHQgICAgJiYgIWhhcyhkZXNjcmlwdG9yLCAnZ2V0Jylcblx0ICAgICYmICFoYXMoZGVzY3JpcHRvciwgJ3NldCcpXG5cdCAgICAvLyBUT0RPOiBhZGQgdmFsaWRhdGlvbiBkZXNjcmlwdG9yIHcvbyBjYWxsaW5nIGFjY2Vzc29yc1xuXHQgICAgJiYgIWRlc2NyaXB0b3IuY29uZmlndXJhYmxlXG5cdCAgICAmJiAoIWhhcyhkZXNjcmlwdG9yLCAnd3JpdGFibGUnKSB8fCBkZXNjcmlwdG9yLndyaXRhYmxlKVxuXHQgICAgJiYgKCFoYXMoZGVzY3JpcHRvciwgJ2VudW1lcmFibGUnKSB8fCBkZXNjcmlwdG9yLmVudW1lcmFibGUpXG5cdCAgKSB7XG5cdCAgICB0YXJnZXRba2V5XSA9IGRlc2NyaXB0b3IudmFsdWU7XG5cdCAgICByZXR1cm4gdGFyZ2V0O1xuXHQgIH0gcmV0dXJuIG5hdGl2ZURlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBkZXNjcmlwdG9yKTtcblx0fTtcblxuXHRpZiAoZGVzY3JpcHRvcnMpIHtcblx0ICBpZiAoIU5BVElWRV9BUlJBWV9CVUZGRVJfVklFV1MpIHtcblx0ICAgIG9iamVjdEdldE93blByb3BlcnR5RGVzY3JpcHRvci5mID0gd3JhcHBlZEdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcblx0ICAgIG9iamVjdERlZmluZVByb3BlcnR5LmYgPSB3cmFwcGVkRGVmaW5lUHJvcGVydHk7XG5cdCAgICBhZGRHZXR0ZXIoVHlwZWRBcnJheVByb3RvdHlwZSwgJ2J1ZmZlcicpO1xuXHQgICAgYWRkR2V0dGVyKFR5cGVkQXJyYXlQcm90b3R5cGUsICdieXRlT2Zmc2V0Jyk7XG5cdCAgICBhZGRHZXR0ZXIoVHlwZWRBcnJheVByb3RvdHlwZSwgJ2J5dGVMZW5ndGgnKTtcblx0ICAgIGFkZEdldHRlcihUeXBlZEFycmF5UHJvdG90eXBlLCAnbGVuZ3RoJyk7XG5cdCAgfVxuXG5cdCAgX2V4cG9ydCh7IHRhcmdldDogJ09iamVjdCcsIHN0YXQ6IHRydWUsIGZvcmNlZDogIU5BVElWRV9BUlJBWV9CVUZGRVJfVklFV1MgfSwge1xuXHQgICAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOiB3cmFwcGVkR2V0T3duUHJvcGVydHlEZXNjcmlwdG9yLFxuXHQgICAgZGVmaW5lUHJvcGVydHk6IHdyYXBwZWREZWZpbmVQcm9wZXJ0eVxuXHQgIH0pO1xuXG5cdCAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG1heC1zdGF0ZW1lbnRzXG5cdCAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoVFlQRSwgQllURVMsIHdyYXBwZXIsIENMQU1QRUQpIHtcblx0ICAgIHZhciBDT05TVFJVQ1RPUl9OQU1FID0gVFlQRSArIChDTEFNUEVEID8gJ0NsYW1wZWQnIDogJycpICsgJ0FycmF5Jztcblx0ICAgIHZhciBHRVRURVIgPSAnZ2V0JyArIFRZUEU7XG5cdCAgICB2YXIgU0VUVEVSID0gJ3NldCcgKyBUWVBFO1xuXHQgICAgdmFyIE5hdGl2ZVR5cGVkQXJyYXlDb25zdHJ1Y3RvciA9IGdsb2JhbF8xW0NPTlNUUlVDVE9SX05BTUVdO1xuXHQgICAgdmFyIFR5cGVkQXJyYXlDb25zdHJ1Y3RvciA9IE5hdGl2ZVR5cGVkQXJyYXlDb25zdHJ1Y3Rvcjtcblx0ICAgIHZhciBUeXBlZEFycmF5Q29uc3RydWN0b3JQcm90b3R5cGUgPSBUeXBlZEFycmF5Q29uc3RydWN0b3IgJiYgVHlwZWRBcnJheUNvbnN0cnVjdG9yLnByb3RvdHlwZTtcblx0ICAgIHZhciBleHBvcnRlZCA9IHt9O1xuXG5cdCAgICB2YXIgZ2V0dGVyID0gZnVuY3Rpb24gKHRoYXQsIGluZGV4KSB7XG5cdCAgICAgIHZhciBkYXRhID0gZ2V0SW50ZXJuYWxTdGF0ZSh0aGF0KTtcblx0ICAgICAgcmV0dXJuIGRhdGEudmlld1tHRVRURVJdKGluZGV4ICogQllURVMgKyBkYXRhLmJ5dGVPZmZzZXQsIHRydWUpO1xuXHQgICAgfTtcblxuXHQgICAgdmFyIHNldHRlciA9IGZ1bmN0aW9uICh0aGF0LCBpbmRleCwgdmFsdWUpIHtcblx0ICAgICAgdmFyIGRhdGEgPSBnZXRJbnRlcm5hbFN0YXRlKHRoYXQpO1xuXHQgICAgICBpZiAoQ0xBTVBFRCkgdmFsdWUgPSAodmFsdWUgPSByb3VuZCh2YWx1ZSkpIDwgMCA/IDAgOiB2YWx1ZSA+IDB4RkYgPyAweEZGIDogdmFsdWUgJiAweEZGO1xuXHQgICAgICBkYXRhLnZpZXdbU0VUVEVSXShpbmRleCAqIEJZVEVTICsgZGF0YS5ieXRlT2Zmc2V0LCB2YWx1ZSwgdHJ1ZSk7XG5cdCAgICB9O1xuXG5cdCAgICB2YXIgYWRkRWxlbWVudCA9IGZ1bmN0aW9uICh0aGF0LCBpbmRleCkge1xuXHQgICAgICBuYXRpdmVEZWZpbmVQcm9wZXJ0eSh0aGF0LCBpbmRleCwge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgcmV0dXJuIGdldHRlcih0aGlzLCBpbmRleCk7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHQgICAgICAgICAgcmV0dXJuIHNldHRlcih0aGlzLCBpbmRleCwgdmFsdWUpO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgZW51bWVyYWJsZTogdHJ1ZVxuXHQgICAgICB9KTtcblx0ICAgIH07XG5cblx0ICAgIGlmICghTkFUSVZFX0FSUkFZX0JVRkZFUl9WSUVXUykge1xuXHQgICAgICBUeXBlZEFycmF5Q29uc3RydWN0b3IgPSB3cmFwcGVyKGZ1bmN0aW9uICh0aGF0LCBkYXRhLCBvZmZzZXQsICRsZW5ndGgpIHtcblx0ICAgICAgICBhbkluc3RhbmNlKHRoYXQsIFR5cGVkQXJyYXlDb25zdHJ1Y3RvciwgQ09OU1RSVUNUT1JfTkFNRSk7XG5cdCAgICAgICAgdmFyIGluZGV4ID0gMDtcblx0ICAgICAgICB2YXIgYnl0ZU9mZnNldCA9IDA7XG5cdCAgICAgICAgdmFyIGJ1ZmZlciwgYnl0ZUxlbmd0aCwgbGVuZ3RoO1xuXHQgICAgICAgIGlmICghaXNPYmplY3QoZGF0YSkpIHtcblx0ICAgICAgICAgIGxlbmd0aCA9IHRvSW5kZXgoZGF0YSk7XG5cdCAgICAgICAgICBieXRlTGVuZ3RoID0gbGVuZ3RoICogQllURVM7XG5cdCAgICAgICAgICBidWZmZXIgPSBuZXcgQXJyYXlCdWZmZXIoYnl0ZUxlbmd0aCk7XG5cdCAgICAgICAgfSBlbHNlIGlmIChpc0FycmF5QnVmZmVyKGRhdGEpKSB7XG5cdCAgICAgICAgICBidWZmZXIgPSBkYXRhO1xuXHQgICAgICAgICAgYnl0ZU9mZnNldCA9IHRvT2Zmc2V0KG9mZnNldCwgQllURVMpO1xuXHQgICAgICAgICAgdmFyICRsZW4gPSBkYXRhLmJ5dGVMZW5ndGg7XG5cdCAgICAgICAgICBpZiAoJGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG5cdCAgICAgICAgICAgIGlmICgkbGVuICUgQllURVMpIHRocm93IFJhbmdlRXJyb3IoV1JPTkdfTEVOR1RIKTtcblx0ICAgICAgICAgICAgYnl0ZUxlbmd0aCA9ICRsZW4gLSBieXRlT2Zmc2V0O1xuXHQgICAgICAgICAgICBpZiAoYnl0ZUxlbmd0aCA8IDApIHRocm93IFJhbmdlRXJyb3IoV1JPTkdfTEVOR1RIKTtcblx0ICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgIGJ5dGVMZW5ndGggPSB0b0xlbmd0aCgkbGVuZ3RoKSAqIEJZVEVTO1xuXHQgICAgICAgICAgICBpZiAoYnl0ZUxlbmd0aCArIGJ5dGVPZmZzZXQgPiAkbGVuKSB0aHJvdyBSYW5nZUVycm9yKFdST05HX0xFTkdUSCk7XG5cdCAgICAgICAgICB9XG5cdCAgICAgICAgICBsZW5ndGggPSBieXRlTGVuZ3RoIC8gQllURVM7XG5cdCAgICAgICAgfSBlbHNlIGlmIChpc1R5cGVkQXJyYXkoZGF0YSkpIHtcblx0ICAgICAgICAgIHJldHVybiBmcm9tTGlzdChUeXBlZEFycmF5Q29uc3RydWN0b3IsIGRhdGEpO1xuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICByZXR1cm4gdHlwZWRBcnJheUZyb20uY2FsbChUeXBlZEFycmF5Q29uc3RydWN0b3IsIGRhdGEpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBzZXRJbnRlcm5hbFN0YXRlKHRoYXQsIHtcblx0ICAgICAgICAgIGJ1ZmZlcjogYnVmZmVyLFxuXHQgICAgICAgICAgYnl0ZU9mZnNldDogYnl0ZU9mZnNldCxcblx0ICAgICAgICAgIGJ5dGVMZW5ndGg6IGJ5dGVMZW5ndGgsXG5cdCAgICAgICAgICBsZW5ndGg6IGxlbmd0aCxcblx0ICAgICAgICAgIHZpZXc6IG5ldyBEYXRhVmlldyhidWZmZXIpXG5cdCAgICAgICAgfSk7XG5cdCAgICAgICAgd2hpbGUgKGluZGV4IDwgbGVuZ3RoKSBhZGRFbGVtZW50KHRoYXQsIGluZGV4KyspO1xuXHQgICAgICB9KTtcblxuXHQgICAgICBpZiAob2JqZWN0U2V0UHJvdG90eXBlT2YpIG9iamVjdFNldFByb3RvdHlwZU9mKFR5cGVkQXJyYXlDb25zdHJ1Y3RvciwgVHlwZWRBcnJheSk7XG5cdCAgICAgIFR5cGVkQXJyYXlDb25zdHJ1Y3RvclByb3RvdHlwZSA9IFR5cGVkQXJyYXlDb25zdHJ1Y3Rvci5wcm90b3R5cGUgPSBvYmplY3RDcmVhdGUoVHlwZWRBcnJheVByb3RvdHlwZSk7XG5cdCAgICB9IGVsc2UgaWYgKHR5cGVkQXJyYXlzQ29uc3RydWN0b3JzUmVxdWlyZXNXcmFwcGVycykge1xuXHQgICAgICBUeXBlZEFycmF5Q29uc3RydWN0b3IgPSB3cmFwcGVyKGZ1bmN0aW9uIChkdW1teSwgZGF0YSwgdHlwZWRBcnJheU9mZnNldCwgJGxlbmd0aCkge1xuXHQgICAgICAgIGFuSW5zdGFuY2UoZHVtbXksIFR5cGVkQXJyYXlDb25zdHJ1Y3RvciwgQ09OU1RSVUNUT1JfTkFNRSk7XG5cdCAgICAgICAgaWYgKCFpc09iamVjdChkYXRhKSkgcmV0dXJuIG5ldyBOYXRpdmVUeXBlZEFycmF5Q29uc3RydWN0b3IodG9JbmRleChkYXRhKSk7XG5cdCAgICAgICAgaWYgKGlzQXJyYXlCdWZmZXIoZGF0YSkpIHJldHVybiAkbGVuZ3RoICE9PSB1bmRlZmluZWRcblx0ICAgICAgICAgID8gbmV3IE5hdGl2ZVR5cGVkQXJyYXlDb25zdHJ1Y3RvcihkYXRhLCB0b09mZnNldCh0eXBlZEFycmF5T2Zmc2V0LCBCWVRFUyksICRsZW5ndGgpXG5cdCAgICAgICAgICA6IHR5cGVkQXJyYXlPZmZzZXQgIT09IHVuZGVmaW5lZFxuXHQgICAgICAgICAgICA/IG5ldyBOYXRpdmVUeXBlZEFycmF5Q29uc3RydWN0b3IoZGF0YSwgdG9PZmZzZXQodHlwZWRBcnJheU9mZnNldCwgQllURVMpKVxuXHQgICAgICAgICAgICA6IG5ldyBOYXRpdmVUeXBlZEFycmF5Q29uc3RydWN0b3IoZGF0YSk7XG5cdCAgICAgICAgaWYgKGlzVHlwZWRBcnJheShkYXRhKSkgcmV0dXJuIGZyb21MaXN0KFR5cGVkQXJyYXlDb25zdHJ1Y3RvciwgZGF0YSk7XG5cdCAgICAgICAgcmV0dXJuIHR5cGVkQXJyYXlGcm9tLmNhbGwoVHlwZWRBcnJheUNvbnN0cnVjdG9yLCBkYXRhKTtcblx0ICAgICAgfSk7XG5cblx0ICAgICAgaWYgKG9iamVjdFNldFByb3RvdHlwZU9mKSBvYmplY3RTZXRQcm90b3R5cGVPZihUeXBlZEFycmF5Q29uc3RydWN0b3IsIFR5cGVkQXJyYXkpO1xuXHQgICAgICBmb3JFYWNoKGdldE93blByb3BlcnR5TmFtZXMoTmF0aXZlVHlwZWRBcnJheUNvbnN0cnVjdG9yKSwgZnVuY3Rpb24gKGtleSkge1xuXHQgICAgICAgIGlmICghKGtleSBpbiBUeXBlZEFycmF5Q29uc3RydWN0b3IpKSBoaWRlKFR5cGVkQXJyYXlDb25zdHJ1Y3Rvciwga2V5LCBOYXRpdmVUeXBlZEFycmF5Q29uc3RydWN0b3Jba2V5XSk7XG5cdCAgICAgIH0pO1xuXHQgICAgICBUeXBlZEFycmF5Q29uc3RydWN0b3IucHJvdG90eXBlID0gVHlwZWRBcnJheUNvbnN0cnVjdG9yUHJvdG90eXBlO1xuXHQgICAgfVxuXG5cdCAgICBpZiAoVHlwZWRBcnJheUNvbnN0cnVjdG9yUHJvdG90eXBlLmNvbnN0cnVjdG9yICE9PSBUeXBlZEFycmF5Q29uc3RydWN0b3IpIHtcblx0ICAgICAgaGlkZShUeXBlZEFycmF5Q29uc3RydWN0b3JQcm90b3R5cGUsICdjb25zdHJ1Y3RvcicsIFR5cGVkQXJyYXlDb25zdHJ1Y3Rvcik7XG5cdCAgICB9XG5cblx0ICAgIGlmIChUWVBFRF9BUlJBWV9UQUcpIGhpZGUoVHlwZWRBcnJheUNvbnN0cnVjdG9yUHJvdG90eXBlLCBUWVBFRF9BUlJBWV9UQUcsIENPTlNUUlVDVE9SX05BTUUpO1xuXG5cdCAgICBleHBvcnRlZFtDT05TVFJVQ1RPUl9OQU1FXSA9IFR5cGVkQXJyYXlDb25zdHJ1Y3RvcjtcblxuXHQgICAgX2V4cG9ydCh7XG5cdCAgICAgIGdsb2JhbDogdHJ1ZSwgZm9yY2VkOiBUeXBlZEFycmF5Q29uc3RydWN0b3IgIT0gTmF0aXZlVHlwZWRBcnJheUNvbnN0cnVjdG9yLCBzaGFtOiAhTkFUSVZFX0FSUkFZX0JVRkZFUl9WSUVXU1xuXHQgICAgfSwgZXhwb3J0ZWQpO1xuXG5cdCAgICBpZiAoIShCWVRFU19QRVJfRUxFTUVOVCBpbiBUeXBlZEFycmF5Q29uc3RydWN0b3IpKSB7XG5cdCAgICAgIGhpZGUoVHlwZWRBcnJheUNvbnN0cnVjdG9yLCBCWVRFU19QRVJfRUxFTUVOVCwgQllURVMpO1xuXHQgICAgfVxuXG5cdCAgICBpZiAoIShCWVRFU19QRVJfRUxFTUVOVCBpbiBUeXBlZEFycmF5Q29uc3RydWN0b3JQcm90b3R5cGUpKSB7XG5cdCAgICAgIGhpZGUoVHlwZWRBcnJheUNvbnN0cnVjdG9yUHJvdG90eXBlLCBCWVRFU19QRVJfRUxFTUVOVCwgQllURVMpO1xuXHQgICAgfVxuXG5cdCAgICBzZXRTcGVjaWVzKENPTlNUUlVDVE9SX05BTUUpO1xuXHQgIH07XG5cdH0gZWxzZSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHsgLyogZW1wdHkgKi8gfTtcblx0fSk7XG5cblx0Ly8gYEludDhBcnJheWAgY29uc3RydWN0b3Jcblx0Ly8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtdHlwZWRhcnJheS1vYmplY3RzXG5cdHR5cGVkQXJyYXlDb25zdHJ1Y3RvcignSW50OCcsIDEsIGZ1bmN0aW9uIChpbml0KSB7XG5cdCAgcmV0dXJuIGZ1bmN0aW9uIEludDhBcnJheShkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpIHtcblx0ICAgIHJldHVybiBpbml0KHRoaXMsIGRhdGEsIGJ5dGVPZmZzZXQsIGxlbmd0aCk7XG5cdCAgfTtcblx0fSk7XG5cblx0dmFyICRldmVyeSA9IGFycmF5SXRlcmF0aW9uLmV2ZXJ5O1xuXG5cdHZhciBhVHlwZWRBcnJheSQ3ID0gYXJyYXlCdWZmZXJWaWV3Q29yZS5hVHlwZWRBcnJheTtcblxuXHQvLyBgJVR5cGVkQXJyYXklLnByb3RvdHlwZS5ldmVyeWAgbWV0aG9kXG5cdC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLSV0eXBlZGFycmF5JS5wcm90b3R5cGUuZXZlcnlcblx0YXJyYXlCdWZmZXJWaWV3Q29yZS5leHBvcnRQcm90bygnZXZlcnknLCBmdW5jdGlvbiBldmVyeShjYWxsYmFja2ZuIC8qICwgdGhpc0FyZyAqLykge1xuXHQgIHJldHVybiAkZXZlcnkoYVR5cGVkQXJyYXkkNyh0aGlzKSwgY2FsbGJhY2tmbiwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpO1xuXHR9KTtcblxuXHR2YXIgJGZpbHRlciA9IGFycmF5SXRlcmF0aW9uLmZpbHRlcjtcblxuXG5cdHZhciBhVHlwZWRBcnJheSQ4ID0gYXJyYXlCdWZmZXJWaWV3Q29yZS5hVHlwZWRBcnJheTtcblx0dmFyIGFUeXBlZEFycmF5Q29uc3RydWN0b3IkMyA9IGFycmF5QnVmZmVyVmlld0NvcmUuYVR5cGVkQXJyYXlDb25zdHJ1Y3RvcjtcblxuXHQvLyBgJVR5cGVkQXJyYXklLnByb3RvdHlwZS5maWx0ZXJgIG1ldGhvZFxuXHQvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy0ldHlwZWRhcnJheSUucHJvdG90eXBlLmZpbHRlclxuXHRhcnJheUJ1ZmZlclZpZXdDb3JlLmV4cG9ydFByb3RvKCdmaWx0ZXInLCBmdW5jdGlvbiBmaWx0ZXIoY2FsbGJhY2tmbiAvKiAsIHRoaXNBcmcgKi8pIHtcblx0ICB2YXIgbGlzdCA9ICRmaWx0ZXIoYVR5cGVkQXJyYXkkOCh0aGlzKSwgY2FsbGJhY2tmbiwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpO1xuXHQgIHZhciBDID0gc3BlY2llc0NvbnN0cnVjdG9yKHRoaXMsIHRoaXMuY29uc3RydWN0b3IpO1xuXHQgIHZhciBpbmRleCA9IDA7XG5cdCAgdmFyIGxlbmd0aCA9IGxpc3QubGVuZ3RoO1xuXHQgIHZhciByZXN1bHQgPSBuZXcgKGFUeXBlZEFycmF5Q29uc3RydWN0b3IkMyhDKSkobGVuZ3RoKTtcblx0ICB3aGlsZSAobGVuZ3RoID4gaW5kZXgpIHJlc3VsdFtpbmRleF0gPSBsaXN0W2luZGV4KytdO1xuXHQgIHJldHVybiByZXN1bHQ7XG5cdH0pO1xuXG5cdHZhciAkZm9yRWFjaCQxID0gYXJyYXlJdGVyYXRpb24uZm9yRWFjaDtcblxuXHR2YXIgYVR5cGVkQXJyYXkkOSA9IGFycmF5QnVmZmVyVmlld0NvcmUuYVR5cGVkQXJyYXk7XG5cblx0Ly8gYCVUeXBlZEFycmF5JS5wcm90b3R5cGUuZm9yRWFjaGAgbWV0aG9kXG5cdC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLSV0eXBlZGFycmF5JS5wcm90b3R5cGUuZm9yZWFjaFxuXHRhcnJheUJ1ZmZlclZpZXdDb3JlLmV4cG9ydFByb3RvKCdmb3JFYWNoJywgZnVuY3Rpb24gZm9yRWFjaChjYWxsYmFja2ZuIC8qICwgdGhpc0FyZyAqLykge1xuXHQgICRmb3JFYWNoJDEoYVR5cGVkQXJyYXkkOSh0aGlzKSwgY2FsbGJhY2tmbiwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpO1xuXHR9KTtcblxuXHR2YXIgJGluZGV4T2YgPSBhcnJheUluY2x1ZGVzLmluZGV4T2Y7XG5cblx0dmFyIGFUeXBlZEFycmF5JGEgPSBhcnJheUJ1ZmZlclZpZXdDb3JlLmFUeXBlZEFycmF5O1xuXG5cdC8vIGAlVHlwZWRBcnJheSUucHJvdG90eXBlLmluZGV4T2ZgIG1ldGhvZFxuXHQvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy0ldHlwZWRhcnJheSUucHJvdG90eXBlLmluZGV4b2Zcblx0YXJyYXlCdWZmZXJWaWV3Q29yZS5leHBvcnRQcm90bygnaW5kZXhPZicsIGZ1bmN0aW9uIGluZGV4T2Yoc2VhcmNoRWxlbWVudCAvKiAsIGZyb21JbmRleCAqLykge1xuXHQgIHJldHVybiAkaW5kZXhPZihhVHlwZWRBcnJheSRhKHRoaXMpLCBzZWFyY2hFbGVtZW50LCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG5cdH0pO1xuXG5cdHZhciBhVHlwZWRBcnJheSRiID0gYXJyYXlCdWZmZXJWaWV3Q29yZS5hVHlwZWRBcnJheTtcblx0dmFyICRqb2luID0gW10uam9pbjtcblxuXHQvLyBgJVR5cGVkQXJyYXklLnByb3RvdHlwZS5qb2luYCBtZXRob2Rcblx0Ly8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtJXR5cGVkYXJyYXklLnByb3RvdHlwZS5qb2luXG5cdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtdmFyc1xuXHRhcnJheUJ1ZmZlclZpZXdDb3JlLmV4cG9ydFByb3RvKCdqb2luJywgZnVuY3Rpb24gam9pbihzZXBhcmF0b3IpIHtcblx0ICByZXR1cm4gJGpvaW4uYXBwbHkoYVR5cGVkQXJyYXkkYih0aGlzKSwgYXJndW1lbnRzKTtcblx0fSk7XG5cblx0dmFyIHNsb3BweUFycmF5TWV0aG9kID0gZnVuY3Rpb24gKE1FVEhPRF9OQU1FLCBhcmd1bWVudCkge1xuXHQgIHZhciBtZXRob2QgPSBbXVtNRVRIT0RfTkFNRV07XG5cdCAgcmV0dXJuICFtZXRob2QgfHwgIWZhaWxzKGZ1bmN0aW9uICgpIHtcblx0ICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11c2VsZXNzLWNhbGwsbm8tdGhyb3ctbGl0ZXJhbFxuXHQgICAgbWV0aG9kLmNhbGwobnVsbCwgYXJndW1lbnQgfHwgZnVuY3Rpb24gKCkgeyB0aHJvdyAxOyB9LCAxKTtcblx0ICB9KTtcblx0fTtcblxuXHR2YXIgbWluJDUgPSBNYXRoLm1pbjtcblx0dmFyIG5hdGl2ZUxhc3RJbmRleE9mID0gW10ubGFzdEluZGV4T2Y7XG5cdHZhciBORUdBVElWRV9aRVJPID0gISFuYXRpdmVMYXN0SW5kZXhPZiAmJiAxIC8gWzFdLmxhc3RJbmRleE9mKDEsIC0wKSA8IDA7XG5cdHZhciBTTE9QUFlfTUVUSE9EID0gc2xvcHB5QXJyYXlNZXRob2QoJ2xhc3RJbmRleE9mJyk7XG5cblx0Ly8gYEFycmF5LnByb3RvdHlwZS5sYXN0SW5kZXhPZmAgbWV0aG9kIGltcGxlbWVudGF0aW9uXG5cdC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5sYXN0aW5kZXhvZlxuXHR2YXIgYXJyYXlMYXN0SW5kZXhPZiA9IChORUdBVElWRV9aRVJPIHx8IFNMT1BQWV9NRVRIT0QpID8gZnVuY3Rpb24gbGFzdEluZGV4T2Yoc2VhcmNoRWxlbWVudCAvKiAsIGZyb21JbmRleCA9IEBbKi0xXSAqLykge1xuXHQgIC8vIGNvbnZlcnQgLTAgdG8gKzBcblx0ICBpZiAoTkVHQVRJVkVfWkVSTykgcmV0dXJuIG5hdGl2ZUxhc3RJbmRleE9mLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgMDtcblx0ICB2YXIgTyA9IHRvSW5kZXhlZE9iamVjdCh0aGlzKTtcblx0ICB2YXIgbGVuZ3RoID0gdG9MZW5ndGgoTy5sZW5ndGgpO1xuXHQgIHZhciBpbmRleCA9IGxlbmd0aCAtIDE7XG5cdCAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSBpbmRleCA9IG1pbiQ1KGluZGV4LCB0b0ludGVnZXIoYXJndW1lbnRzWzFdKSk7XG5cdCAgaWYgKGluZGV4IDwgMCkgaW5kZXggPSBsZW5ndGggKyBpbmRleDtcblx0ICBmb3IgKDtpbmRleCA+PSAwOyBpbmRleC0tKSBpZiAoaW5kZXggaW4gTyAmJiBPW2luZGV4XSA9PT0gc2VhcmNoRWxlbWVudCkgcmV0dXJuIGluZGV4IHx8IDA7XG5cdCAgcmV0dXJuIC0xO1xuXHR9IDogbmF0aXZlTGFzdEluZGV4T2Y7XG5cblx0dmFyIGFUeXBlZEFycmF5JGMgPSBhcnJheUJ1ZmZlclZpZXdDb3JlLmFUeXBlZEFycmF5O1xuXG5cdC8vIGAlVHlwZWRBcnJheSUucHJvdG90eXBlLmxhc3RJbmRleE9mYCBtZXRob2Rcblx0Ly8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtJXR5cGVkYXJyYXklLnByb3RvdHlwZS5sYXN0aW5kZXhvZlxuXHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLXZhcnNcblx0YXJyYXlCdWZmZXJWaWV3Q29yZS5leHBvcnRQcm90bygnbGFzdEluZGV4T2YnLCBmdW5jdGlvbiBsYXN0SW5kZXhPZihzZWFyY2hFbGVtZW50IC8qICwgZnJvbUluZGV4ICovKSB7XG5cdCAgcmV0dXJuIGFycmF5TGFzdEluZGV4T2YuYXBwbHkoYVR5cGVkQXJyYXkkYyh0aGlzKSwgYXJndW1lbnRzKTtcblx0fSk7XG5cblx0dmFyICRtYXAgPSBhcnJheUl0ZXJhdGlvbi5tYXA7XG5cblxuXHR2YXIgYVR5cGVkQXJyYXkkZCA9IGFycmF5QnVmZmVyVmlld0NvcmUuYVR5cGVkQXJyYXk7XG5cdHZhciBhVHlwZWRBcnJheUNvbnN0cnVjdG9yJDQgPSBhcnJheUJ1ZmZlclZpZXdDb3JlLmFUeXBlZEFycmF5Q29uc3RydWN0b3I7XG5cblx0Ly8gYCVUeXBlZEFycmF5JS5wcm90b3R5cGUubWFwYCBtZXRob2Rcblx0Ly8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtJXR5cGVkYXJyYXklLnByb3RvdHlwZS5tYXBcblx0YXJyYXlCdWZmZXJWaWV3Q29yZS5leHBvcnRQcm90bygnbWFwJywgZnVuY3Rpb24gbWFwKG1hcGZuIC8qICwgdGhpc0FyZyAqLykge1xuXHQgIHJldHVybiAkbWFwKGFUeXBlZEFycmF5JGQodGhpcyksIG1hcGZuLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCwgZnVuY3Rpb24gKE8sIGxlbmd0aCkge1xuXHQgICAgcmV0dXJuIG5ldyAoYVR5cGVkQXJyYXlDb25zdHJ1Y3RvciQ0KHNwZWNpZXNDb25zdHJ1Y3RvcihPLCBPLmNvbnN0cnVjdG9yKSkpKGxlbmd0aCk7XG5cdCAgfSk7XG5cdH0pO1xuXG5cdC8vIGBBcnJheS5wcm90b3R5cGUueyByZWR1Y2UsIHJlZHVjZVJpZ2h0IH1gIG1ldGhvZHMgaW1wbGVtZW50YXRpb25cblx0dmFyIGNyZWF0ZU1ldGhvZCQ2ID0gZnVuY3Rpb24gKElTX1JJR0hUKSB7XG5cdCAgcmV0dXJuIGZ1bmN0aW9uICh0aGF0LCBjYWxsYmFja2ZuLCBhcmd1bWVudHNMZW5ndGgsIG1lbW8pIHtcblx0ICAgIGFGdW5jdGlvbiQxKGNhbGxiYWNrZm4pO1xuXHQgICAgdmFyIE8gPSB0b09iamVjdCh0aGF0KTtcblx0ICAgIHZhciBzZWxmID0gaW5kZXhlZE9iamVjdChPKTtcblx0ICAgIHZhciBsZW5ndGggPSB0b0xlbmd0aChPLmxlbmd0aCk7XG5cdCAgICB2YXIgaW5kZXggPSBJU19SSUdIVCA/IGxlbmd0aCAtIDEgOiAwO1xuXHQgICAgdmFyIGkgPSBJU19SSUdIVCA/IC0xIDogMTtcblx0ICAgIGlmIChhcmd1bWVudHNMZW5ndGggPCAyKSB3aGlsZSAodHJ1ZSkge1xuXHQgICAgICBpZiAoaW5kZXggaW4gc2VsZikge1xuXHQgICAgICAgIG1lbW8gPSBzZWxmW2luZGV4XTtcblx0ICAgICAgICBpbmRleCArPSBpO1xuXHQgICAgICAgIGJyZWFrO1xuXHQgICAgICB9XG5cdCAgICAgIGluZGV4ICs9IGk7XG5cdCAgICAgIGlmIChJU19SSUdIVCA/IGluZGV4IDwgMCA6IGxlbmd0aCA8PSBpbmRleCkge1xuXHQgICAgICAgIHRocm93IFR5cGVFcnJvcignUmVkdWNlIG9mIGVtcHR5IGFycmF5IHdpdGggbm8gaW5pdGlhbCB2YWx1ZScpO1xuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgICBmb3IgKDtJU19SSUdIVCA/IGluZGV4ID49IDAgOiBsZW5ndGggPiBpbmRleDsgaW5kZXggKz0gaSkgaWYgKGluZGV4IGluIHNlbGYpIHtcblx0ICAgICAgbWVtbyA9IGNhbGxiYWNrZm4obWVtbywgc2VsZltpbmRleF0sIGluZGV4LCBPKTtcblx0ICAgIH1cblx0ICAgIHJldHVybiBtZW1vO1xuXHQgIH07XG5cdH07XG5cblx0dmFyIGFycmF5UmVkdWNlID0ge1xuXHQgIC8vIGBBcnJheS5wcm90b3R5cGUucmVkdWNlYCBtZXRob2Rcblx0ICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUucmVkdWNlXG5cdCAgbGVmdDogY3JlYXRlTWV0aG9kJDYoZmFsc2UpLFxuXHQgIC8vIGBBcnJheS5wcm90b3R5cGUucmVkdWNlUmlnaHRgIG1ldGhvZFxuXHQgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5yZWR1Y2VyaWdodFxuXHQgIHJpZ2h0OiBjcmVhdGVNZXRob2QkNih0cnVlKVxuXHR9O1xuXG5cdHZhciAkcmVkdWNlID0gYXJyYXlSZWR1Y2UubGVmdDtcblxuXHR2YXIgYVR5cGVkQXJyYXkkZSA9IGFycmF5QnVmZmVyVmlld0NvcmUuYVR5cGVkQXJyYXk7XG5cblx0Ly8gYCVUeXBlZEFycmF5JS5wcm90b3R5cGUucmVkdWNlYCBtZXRob2Rcblx0Ly8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtJXR5cGVkYXJyYXklLnByb3RvdHlwZS5yZWR1Y2Vcblx0YXJyYXlCdWZmZXJWaWV3Q29yZS5leHBvcnRQcm90bygncmVkdWNlJywgZnVuY3Rpb24gcmVkdWNlKGNhbGxiYWNrZm4gLyogLCBpbml0aWFsVmFsdWUgKi8pIHtcblx0ICByZXR1cm4gJHJlZHVjZShhVHlwZWRBcnJheSRlKHRoaXMpLCBjYWxsYmFja2ZuLCBhcmd1bWVudHMubGVuZ3RoLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG5cdH0pO1xuXG5cdHZhciAkcmVkdWNlUmlnaHQgPSBhcnJheVJlZHVjZS5yaWdodDtcblxuXHR2YXIgYVR5cGVkQXJyYXkkZiA9IGFycmF5QnVmZmVyVmlld0NvcmUuYVR5cGVkQXJyYXk7XG5cblx0Ly8gYCVUeXBlZEFycmF5JS5wcm90b3R5cGUucmVkdWNlUmljaHRgIG1ldGhvZFxuXHQvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy0ldHlwZWRhcnJheSUucHJvdG90eXBlLnJlZHVjZXJpZ2h0XG5cdGFycmF5QnVmZmVyVmlld0NvcmUuZXhwb3J0UHJvdG8oJ3JlZHVjZVJpZ2h0JywgZnVuY3Rpb24gcmVkdWNlUmlnaHQoY2FsbGJhY2tmbiAvKiAsIGluaXRpYWxWYWx1ZSAqLykge1xuXHQgIHJldHVybiAkcmVkdWNlUmlnaHQoYVR5cGVkQXJyYXkkZih0aGlzKSwgY2FsbGJhY2tmbiwgYXJndW1lbnRzLmxlbmd0aCwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpO1xuXHR9KTtcblxuXHR2YXIgYVR5cGVkQXJyYXkkZyA9IGFycmF5QnVmZmVyVmlld0NvcmUuYVR5cGVkQXJyYXk7XG5cdHZhciBmbG9vciQ0ID0gTWF0aC5mbG9vcjtcblxuXHQvLyBgJVR5cGVkQXJyYXklLnByb3RvdHlwZS5yZXZlcnNlYCBtZXRob2Rcblx0Ly8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtJXR5cGVkYXJyYXklLnByb3RvdHlwZS5yZXZlcnNlXG5cdGFycmF5QnVmZmVyVmlld0NvcmUuZXhwb3J0UHJvdG8oJ3JldmVyc2UnLCBmdW5jdGlvbiByZXZlcnNlKCkge1xuXHQgIHZhciB0aGF0ID0gdGhpcztcblx0ICB2YXIgbGVuZ3RoID0gYVR5cGVkQXJyYXkkZyh0aGF0KS5sZW5ndGg7XG5cdCAgdmFyIG1pZGRsZSA9IGZsb29yJDQobGVuZ3RoIC8gMik7XG5cdCAgdmFyIGluZGV4ID0gMDtcblx0ICB2YXIgdmFsdWU7XG5cdCAgd2hpbGUgKGluZGV4IDwgbWlkZGxlKSB7XG5cdCAgICB2YWx1ZSA9IHRoYXRbaW5kZXhdO1xuXHQgICAgdGhhdFtpbmRleCsrXSA9IHRoYXRbLS1sZW5ndGhdO1xuXHQgICAgdGhhdFtsZW5ndGhdID0gdmFsdWU7XG5cdCAgfSByZXR1cm4gdGhhdDtcblx0fSk7XG5cblx0dmFyIGFUeXBlZEFycmF5JGggPSBhcnJheUJ1ZmZlclZpZXdDb3JlLmFUeXBlZEFycmF5O1xuXG5cdHZhciBGT1JDRUQkOCA9IGZhaWxzKGZ1bmN0aW9uICgpIHtcblx0ICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWZcblx0ICBuZXcgSW50OEFycmF5KDEpLnNldCh7fSk7XG5cdH0pO1xuXG5cdC8vIGAlVHlwZWRBcnJheSUucHJvdG90eXBlLnNldGAgbWV0aG9kXG5cdC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLSV0eXBlZGFycmF5JS5wcm90b3R5cGUuc2V0XG5cdGFycmF5QnVmZmVyVmlld0NvcmUuZXhwb3J0UHJvdG8oJ3NldCcsIGZ1bmN0aW9uIHNldChhcnJheUxpa2UgLyogLCBvZmZzZXQgKi8pIHtcblx0ICBhVHlwZWRBcnJheSRoKHRoaXMpO1xuXHQgIHZhciBvZmZzZXQgPSB0b09mZnNldChhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCwgMSk7XG5cdCAgdmFyIGxlbmd0aCA9IHRoaXMubGVuZ3RoO1xuXHQgIHZhciBzcmMgPSB0b09iamVjdChhcnJheUxpa2UpO1xuXHQgIHZhciBsZW4gPSB0b0xlbmd0aChzcmMubGVuZ3RoKTtcblx0ICB2YXIgaW5kZXggPSAwO1xuXHQgIGlmIChsZW4gKyBvZmZzZXQgPiBsZW5ndGgpIHRocm93IFJhbmdlRXJyb3IoJ1dyb25nIGxlbmd0aCcpO1xuXHQgIHdoaWxlIChpbmRleCA8IGxlbikgdGhpc1tvZmZzZXQgKyBpbmRleF0gPSBzcmNbaW5kZXgrK107XG5cdH0sIEZPUkNFRCQ4KTtcblxuXHR2YXIgYVR5cGVkQXJyYXkkaSA9IGFycmF5QnVmZmVyVmlld0NvcmUuYVR5cGVkQXJyYXk7XG5cdHZhciBhVHlwZWRBcnJheUNvbnN0cnVjdG9yJDUgPSBhcnJheUJ1ZmZlclZpZXdDb3JlLmFUeXBlZEFycmF5Q29uc3RydWN0b3I7XG5cdHZhciAkc2xpY2UgPSBbXS5zbGljZTtcblxuXHR2YXIgRk9SQ0VEJDkgPSBmYWlscyhmdW5jdGlvbiAoKSB7XG5cdCAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmXG5cdCAgbmV3IEludDhBcnJheSgxKS5zbGljZSgpO1xuXHR9KTtcblxuXHQvLyBgJVR5cGVkQXJyYXklLnByb3RvdHlwZS5zbGljZWAgbWV0aG9kXG5cdC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLSV0eXBlZGFycmF5JS5wcm90b3R5cGUuc2xpY2Vcblx0YXJyYXlCdWZmZXJWaWV3Q29yZS5leHBvcnRQcm90bygnc2xpY2UnLCBmdW5jdGlvbiBzbGljZShzdGFydCwgZW5kKSB7XG5cdCAgdmFyIGxpc3QgPSAkc2xpY2UuY2FsbChhVHlwZWRBcnJheSRpKHRoaXMpLCBzdGFydCwgZW5kKTtcblx0ICB2YXIgQyA9IHNwZWNpZXNDb25zdHJ1Y3Rvcih0aGlzLCB0aGlzLmNvbnN0cnVjdG9yKTtcblx0ICB2YXIgaW5kZXggPSAwO1xuXHQgIHZhciBsZW5ndGggPSBsaXN0Lmxlbmd0aDtcblx0ICB2YXIgcmVzdWx0ID0gbmV3IChhVHlwZWRBcnJheUNvbnN0cnVjdG9yJDUoQykpKGxlbmd0aCk7XG5cdCAgd2hpbGUgKGxlbmd0aCA+IGluZGV4KSByZXN1bHRbaW5kZXhdID0gbGlzdFtpbmRleCsrXTtcblx0ICByZXR1cm4gcmVzdWx0O1xuXHR9LCBGT1JDRUQkOSk7XG5cblx0dmFyICRzb21lID0gYXJyYXlJdGVyYXRpb24uc29tZTtcblxuXHR2YXIgYVR5cGVkQXJyYXkkaiA9IGFycmF5QnVmZmVyVmlld0NvcmUuYVR5cGVkQXJyYXk7XG5cblx0Ly8gYCVUeXBlZEFycmF5JS5wcm90b3R5cGUuc29tZWAgbWV0aG9kXG5cdC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLSV0eXBlZGFycmF5JS5wcm90b3R5cGUuc29tZVxuXHRhcnJheUJ1ZmZlclZpZXdDb3JlLmV4cG9ydFByb3RvKCdzb21lJywgZnVuY3Rpb24gc29tZShjYWxsYmFja2ZuIC8qICwgdGhpc0FyZyAqLykge1xuXHQgIHJldHVybiAkc29tZShhVHlwZWRBcnJheSRqKHRoaXMpLCBjYWxsYmFja2ZuLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG5cdH0pO1xuXG5cdHZhciBhVHlwZWRBcnJheSRrID0gYXJyYXlCdWZmZXJWaWV3Q29yZS5hVHlwZWRBcnJheTtcblx0dmFyICRzb3J0ID0gW10uc29ydDtcblxuXHQvLyBgJVR5cGVkQXJyYXklLnByb3RvdHlwZS5zb3J0YCBtZXRob2Rcblx0Ly8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtJXR5cGVkYXJyYXklLnByb3RvdHlwZS5zb3J0XG5cdGFycmF5QnVmZmVyVmlld0NvcmUuZXhwb3J0UHJvdG8oJ3NvcnQnLCBmdW5jdGlvbiBzb3J0KGNvbXBhcmVmbikge1xuXHQgIHJldHVybiAkc29ydC5jYWxsKGFUeXBlZEFycmF5JGsodGhpcyksIGNvbXBhcmVmbik7XG5cdH0pO1xuXG5cdHZhciBhVHlwZWRBcnJheSRsID0gYXJyYXlCdWZmZXJWaWV3Q29yZS5hVHlwZWRBcnJheTtcblxuXHQvLyBgJVR5cGVkQXJyYXklLnByb3RvdHlwZS5zdWJhcnJheWAgbWV0aG9kXG5cdC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLSV0eXBlZGFycmF5JS5wcm90b3R5cGUuc3ViYXJyYXlcblx0YXJyYXlCdWZmZXJWaWV3Q29yZS5leHBvcnRQcm90bygnc3ViYXJyYXknLCBmdW5jdGlvbiBzdWJhcnJheShiZWdpbiwgZW5kKSB7XG5cdCAgdmFyIE8gPSBhVHlwZWRBcnJheSRsKHRoaXMpO1xuXHQgIHZhciBsZW5ndGggPSBPLmxlbmd0aDtcblx0ICB2YXIgYmVnaW5JbmRleCA9IHRvQWJzb2x1dGVJbmRleChiZWdpbiwgbGVuZ3RoKTtcblx0ICByZXR1cm4gbmV3IChzcGVjaWVzQ29uc3RydWN0b3IoTywgTy5jb25zdHJ1Y3RvcikpKFxuXHQgICAgTy5idWZmZXIsXG5cdCAgICBPLmJ5dGVPZmZzZXQgKyBiZWdpbkluZGV4ICogTy5CWVRFU19QRVJfRUxFTUVOVCxcblx0ICAgIHRvTGVuZ3RoKChlbmQgPT09IHVuZGVmaW5lZCA/IGxlbmd0aCA6IHRvQWJzb2x1dGVJbmRleChlbmQsIGxlbmd0aCkpIC0gYmVnaW5JbmRleClcblx0ICApO1xuXHR9KTtcblxuXHR2YXIgSW50OEFycmF5JDMgPSBnbG9iYWxfMS5JbnQ4QXJyYXk7XG5cdHZhciBhVHlwZWRBcnJheSRtID0gYXJyYXlCdWZmZXJWaWV3Q29yZS5hVHlwZWRBcnJheTtcblx0dmFyICR0b0xvY2FsZVN0cmluZyA9IFtdLnRvTG9jYWxlU3RyaW5nO1xuXHR2YXIgJHNsaWNlJDEgPSBbXS5zbGljZTtcblxuXHQvLyBpT1MgU2FmYXJpIDYueCBmYWlscyBoZXJlXG5cdHZhciBUT19MT0NBTEVfU1RSSU5HX0JVRyA9ICEhSW50OEFycmF5JDMgJiYgZmFpbHMoZnVuY3Rpb24gKCkge1xuXHQgICR0b0xvY2FsZVN0cmluZy5jYWxsKG5ldyBJbnQ4QXJyYXkkMygxKSk7XG5cdH0pO1xuXG5cdHZhciBGT1JDRUQkYSA9IGZhaWxzKGZ1bmN0aW9uICgpIHtcblx0ICByZXR1cm4gWzEsIDJdLnRvTG9jYWxlU3RyaW5nKCkgIT0gbmV3IEludDhBcnJheSQzKFsxLCAyXSkudG9Mb2NhbGVTdHJpbmcoKTtcblx0fSkgfHwgIWZhaWxzKGZ1bmN0aW9uICgpIHtcblx0ICBJbnQ4QXJyYXkkMy5wcm90b3R5cGUudG9Mb2NhbGVTdHJpbmcuY2FsbChbMSwgMl0pO1xuXHR9KTtcblxuXHQvLyBgJVR5cGVkQXJyYXklLnByb3RvdHlwZS50b0xvY2FsZVN0cmluZ2AgbWV0aG9kXG5cdC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLSV0eXBlZGFycmF5JS5wcm90b3R5cGUudG9sb2NhbGVzdHJpbmdcblx0YXJyYXlCdWZmZXJWaWV3Q29yZS5leHBvcnRQcm90bygndG9Mb2NhbGVTdHJpbmcnLCBmdW5jdGlvbiB0b0xvY2FsZVN0cmluZygpIHtcblx0ICByZXR1cm4gJHRvTG9jYWxlU3RyaW5nLmFwcGx5KFRPX0xPQ0FMRV9TVFJJTkdfQlVHID8gJHNsaWNlJDEuY2FsbChhVHlwZWRBcnJheSRtKHRoaXMpKSA6IGFUeXBlZEFycmF5JG0odGhpcyksIGFyZ3VtZW50cyk7XG5cdH0sIEZPUkNFRCRhKTtcblxuXHR2YXIgVWludDhBcnJheSQxID0gZ2xvYmFsXzEuVWludDhBcnJheTtcblx0dmFyIFVpbnQ4QXJyYXlQcm90b3R5cGUgPSBVaW50OEFycmF5JDEgJiYgVWludDhBcnJheSQxLnByb3RvdHlwZTtcblx0dmFyIGFycmF5VG9TdHJpbmcgPSBbXS50b1N0cmluZztcblx0dmFyIGFycmF5Sm9pbiA9IFtdLmpvaW47XG5cblx0aWYgKGZhaWxzKGZ1bmN0aW9uICgpIHsgYXJyYXlUb1N0cmluZy5jYWxsKHt9KTsgfSkpIHtcblx0ICBhcnJheVRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG5cdCAgICByZXR1cm4gYXJyYXlKb2luLmNhbGwodGhpcyk7XG5cdCAgfTtcblx0fVxuXG5cdC8vIGAlVHlwZWRBcnJheSUucHJvdG90eXBlLnRvU3RyaW5nYCBtZXRob2Rcblx0Ly8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtJXR5cGVkYXJyYXklLnByb3RvdHlwZS50b3N0cmluZ1xuXHRhcnJheUJ1ZmZlclZpZXdDb3JlLmV4cG9ydFByb3RvKCd0b1N0cmluZycsIGFycmF5VG9TdHJpbmcsIChVaW50OEFycmF5UHJvdG90eXBlIHx8IHt9KS50b1N0cmluZyAhPSBhcnJheVRvU3RyaW5nKTtcblxuXHR2YXIgaW50OEFycmF5ID0gZ2xvYmFsXzEuSW50OEFycmF5O1xuXG5cdC8vIGBVaW50OEFycmF5YCBjb25zdHJ1Y3RvclxuXHQvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy10eXBlZGFycmF5LW9iamVjdHNcblx0dHlwZWRBcnJheUNvbnN0cnVjdG9yKCdVaW50OCcsIDEsIGZ1bmN0aW9uIChpbml0KSB7XG5cdCAgcmV0dXJuIGZ1bmN0aW9uIFVpbnQ4QXJyYXkoZGF0YSwgYnl0ZU9mZnNldCwgbGVuZ3RoKSB7XG5cdCAgICByZXR1cm4gaW5pdCh0aGlzLCBkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpO1xuXHQgIH07XG5cdH0pO1xuXG5cdHZhciB1aW50OEFycmF5ID0gZ2xvYmFsXzEuVWludDhBcnJheTtcblxuXHQvLyBgVWludDhDbGFtcGVkQXJyYXlgIGNvbnN0cnVjdG9yXG5cdC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXR5cGVkYXJyYXktb2JqZWN0c1xuXHR0eXBlZEFycmF5Q29uc3RydWN0b3IoJ1VpbnQ4JywgMSwgZnVuY3Rpb24gKGluaXQpIHtcblx0ICByZXR1cm4gZnVuY3Rpb24gVWludDhDbGFtcGVkQXJyYXkoZGF0YSwgYnl0ZU9mZnNldCwgbGVuZ3RoKSB7XG5cdCAgICByZXR1cm4gaW5pdCh0aGlzLCBkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpO1xuXHQgIH07XG5cdH0sIHRydWUpO1xuXG5cdHZhciB1aW50OENsYW1wZWRBcnJheSA9IGdsb2JhbF8xLlVpbnQ4Q2xhbXBlZEFycmF5O1xuXG5cdC8vIGBJbnQxNkFycmF5YCBjb25zdHJ1Y3RvclxuXHQvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy10eXBlZGFycmF5LW9iamVjdHNcblx0dHlwZWRBcnJheUNvbnN0cnVjdG9yKCdJbnQxNicsIDIsIGZ1bmN0aW9uIChpbml0KSB7XG5cdCAgcmV0dXJuIGZ1bmN0aW9uIEludDE2QXJyYXkoZGF0YSwgYnl0ZU9mZnNldCwgbGVuZ3RoKSB7XG5cdCAgICByZXR1cm4gaW5pdCh0aGlzLCBkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpO1xuXHQgIH07XG5cdH0pO1xuXG5cdHZhciBpbnQxNkFycmF5ID0gZ2xvYmFsXzEuSW50MTZBcnJheTtcblxuXHQvLyBgVWludDE2QXJyYXlgIGNvbnN0cnVjdG9yXG5cdC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXR5cGVkYXJyYXktb2JqZWN0c1xuXHR0eXBlZEFycmF5Q29uc3RydWN0b3IoJ1VpbnQxNicsIDIsIGZ1bmN0aW9uIChpbml0KSB7XG5cdCAgcmV0dXJuIGZ1bmN0aW9uIFVpbnQxNkFycmF5KGRhdGEsIGJ5dGVPZmZzZXQsIGxlbmd0aCkge1xuXHQgICAgcmV0dXJuIGluaXQodGhpcywgZGF0YSwgYnl0ZU9mZnNldCwgbGVuZ3RoKTtcblx0ICB9O1xuXHR9KTtcblxuXHR2YXIgdWludDE2QXJyYXkgPSBnbG9iYWxfMS5VaW50MTZBcnJheTtcblxuXHQvLyBgSW50MzJBcnJheWAgY29uc3RydWN0b3Jcblx0Ly8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtdHlwZWRhcnJheS1vYmplY3RzXG5cdHR5cGVkQXJyYXlDb25zdHJ1Y3RvcignSW50MzInLCA0LCBmdW5jdGlvbiAoaW5pdCkge1xuXHQgIHJldHVybiBmdW5jdGlvbiBJbnQzMkFycmF5KGRhdGEsIGJ5dGVPZmZzZXQsIGxlbmd0aCkge1xuXHQgICAgcmV0dXJuIGluaXQodGhpcywgZGF0YSwgYnl0ZU9mZnNldCwgbGVuZ3RoKTtcblx0ICB9O1xuXHR9KTtcblxuXHR2YXIgaW50MzJBcnJheSA9IGdsb2JhbF8xLkludDMyQXJyYXk7XG5cblx0Ly8gYFVpbnQzMkFycmF5YCBjb25zdHJ1Y3RvclxuXHQvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy10eXBlZGFycmF5LW9iamVjdHNcblx0dHlwZWRBcnJheUNvbnN0cnVjdG9yKCdVaW50MzInLCA0LCBmdW5jdGlvbiAoaW5pdCkge1xuXHQgIHJldHVybiBmdW5jdGlvbiBVaW50MzJBcnJheShkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpIHtcblx0ICAgIHJldHVybiBpbml0KHRoaXMsIGRhdGEsIGJ5dGVPZmZzZXQsIGxlbmd0aCk7XG5cdCAgfTtcblx0fSk7XG5cblx0dmFyIHVpbnQzMkFycmF5ID0gZ2xvYmFsXzEuVWludDMyQXJyYXk7XG5cblx0Ly8gYEZsb2F0MzJBcnJheWAgY29uc3RydWN0b3Jcblx0Ly8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtdHlwZWRhcnJheS1vYmplY3RzXG5cdHR5cGVkQXJyYXlDb25zdHJ1Y3RvcignRmxvYXQzMicsIDQsIGZ1bmN0aW9uIChpbml0KSB7XG5cdCAgcmV0dXJuIGZ1bmN0aW9uIEZsb2F0MzJBcnJheShkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpIHtcblx0ICAgIHJldHVybiBpbml0KHRoaXMsIGRhdGEsIGJ5dGVPZmZzZXQsIGxlbmd0aCk7XG5cdCAgfTtcblx0fSk7XG5cblx0dmFyIGZsb2F0MzJBcnJheSA9IGdsb2JhbF8xLkZsb2F0MzJBcnJheTtcblxuXHQvLyBgRmxvYXQ2NEFycmF5YCBjb25zdHJ1Y3RvclxuXHQvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy10eXBlZGFycmF5LW9iamVjdHNcblx0dHlwZWRBcnJheUNvbnN0cnVjdG9yKCdGbG9hdDY0JywgOCwgZnVuY3Rpb24gKGluaXQpIHtcblx0ICByZXR1cm4gZnVuY3Rpb24gRmxvYXQ2NEFycmF5KGRhdGEsIGJ5dGVPZmZzZXQsIGxlbmd0aCkge1xuXHQgICAgcmV0dXJuIGluaXQodGhpcywgZGF0YSwgYnl0ZU9mZnNldCwgbGVuZ3RoKTtcblx0ICB9O1xuXHR9KTtcblxuXHR2YXIgZmxvYXQ2NEFycmF5ID0gZ2xvYmFsXzEuRmxvYXQ2NEFycmF5O1xuXG5cdHZhciBlczIwMTdUeXBlZEFycmF5cyA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuXHR9KTtcblxuXHR1bndyYXBFeHBvcnRzKGVzMjAxN1R5cGVkQXJyYXlzKTtcblxuXHR2YXIgX2ZpbmFsbHkgPSBlbnRyeVVuYmluZCgnUHJvbWlzZScsICdmaW5hbGx5Jyk7XG5cblx0dmFyIGVzMjAxOFByb21pc2UgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcblx0fSk7XG5cblx0dW53cmFwRXhwb3J0cyhlczIwMThQcm9taXNlKTtcblxuXHQvLyBgRmxhdHRlbkludG9BcnJheWAgYWJzdHJhY3Qgb3BlcmF0aW9uXG5cdC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vcHJvcG9zYWwtZmxhdE1hcC8jc2VjLUZsYXR0ZW5JbnRvQXJyYXlcblx0dmFyIGZsYXR0ZW5JbnRvQXJyYXkgPSBmdW5jdGlvbiAodGFyZ2V0LCBvcmlnaW5hbCwgc291cmNlLCBzb3VyY2VMZW4sIHN0YXJ0LCBkZXB0aCwgbWFwcGVyLCB0aGlzQXJnKSB7XG5cdCAgdmFyIHRhcmdldEluZGV4ID0gc3RhcnQ7XG5cdCAgdmFyIHNvdXJjZUluZGV4ID0gMDtcblx0ICB2YXIgbWFwRm4gPSBtYXBwZXIgPyBiaW5kQ29udGV4dChtYXBwZXIsIHRoaXNBcmcsIDMpIDogZmFsc2U7XG5cdCAgdmFyIGVsZW1lbnQ7XG5cblx0ICB3aGlsZSAoc291cmNlSW5kZXggPCBzb3VyY2VMZW4pIHtcblx0ICAgIGlmIChzb3VyY2VJbmRleCBpbiBzb3VyY2UpIHtcblx0ICAgICAgZWxlbWVudCA9IG1hcEZuID8gbWFwRm4oc291cmNlW3NvdXJjZUluZGV4XSwgc291cmNlSW5kZXgsIG9yaWdpbmFsKSA6IHNvdXJjZVtzb3VyY2VJbmRleF07XG5cblx0ICAgICAgaWYgKGRlcHRoID4gMCAmJiBpc0FycmF5KGVsZW1lbnQpKSB7XG5cdCAgICAgICAgdGFyZ2V0SW5kZXggPSBmbGF0dGVuSW50b0FycmF5KHRhcmdldCwgb3JpZ2luYWwsIGVsZW1lbnQsIHRvTGVuZ3RoKGVsZW1lbnQubGVuZ3RoKSwgdGFyZ2V0SW5kZXgsIGRlcHRoIC0gMSkgLSAxO1xuXHQgICAgICB9IGVsc2Uge1xuXHQgICAgICAgIGlmICh0YXJnZXRJbmRleCA+PSAweDFGRkZGRkZGRkZGRkZGKSB0aHJvdyBUeXBlRXJyb3IoJ0V4Y2VlZCB0aGUgYWNjZXB0YWJsZSBhcnJheSBsZW5ndGgnKTtcblx0ICAgICAgICB0YXJnZXRbdGFyZ2V0SW5kZXhdID0gZWxlbWVudDtcblx0ICAgICAgfVxuXG5cdCAgICAgIHRhcmdldEluZGV4Kys7XG5cdCAgICB9XG5cdCAgICBzb3VyY2VJbmRleCsrO1xuXHQgIH1cblx0ICByZXR1cm4gdGFyZ2V0SW5kZXg7XG5cdH07XG5cblx0dmFyIGZsYXR0ZW5JbnRvQXJyYXlfMSA9IGZsYXR0ZW5JbnRvQXJyYXk7XG5cblx0Ly8gYEFycmF5LnByb3RvdHlwZS5mbGF0TWFwYCBtZXRob2Rcblx0Ly8gaHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtZmxhdE1hcFxuXHRfZXhwb3J0KHsgdGFyZ2V0OiAnQXJyYXknLCBwcm90bzogdHJ1ZSB9LCB7XG5cdCAgZmxhdE1hcDogZnVuY3Rpb24gZmxhdE1hcChjYWxsYmFja2ZuIC8qICwgdGhpc0FyZyAqLykge1xuXHQgICAgdmFyIE8gPSB0b09iamVjdCh0aGlzKTtcblx0ICAgIHZhciBzb3VyY2VMZW4gPSB0b0xlbmd0aChPLmxlbmd0aCk7XG5cdCAgICB2YXIgQTtcblx0ICAgIGFGdW5jdGlvbiQxKGNhbGxiYWNrZm4pO1xuXHQgICAgQSA9IGFycmF5U3BlY2llc0NyZWF0ZShPLCAwKTtcblx0ICAgIEEubGVuZ3RoID0gZmxhdHRlbkludG9BcnJheV8xKEEsIE8sIE8sIHNvdXJjZUxlbiwgMCwgMSwgY2FsbGJhY2tmbiwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpO1xuXHQgICAgcmV0dXJuIEE7XG5cdCAgfVxuXHR9KTtcblxuXHQvLyB0aGlzIG1ldGhvZCB3YXMgYWRkZWQgdG8gdW5zY29wYWJsZXMgYWZ0ZXIgaW1wbGVtZW50YXRpb25cblx0Ly8gaW4gcG9wdWxhciBlbmdpbmVzLCBzbyBpdCdzIG1vdmVkIHRvIGEgc2VwYXJhdGUgbW9kdWxlXG5cblxuXHRhZGRUb1Vuc2NvcGFibGVzKCdmbGF0TWFwJyk7XG5cblx0dmFyIGZsYXRNYXAgPSBlbnRyeVVuYmluZCgnQXJyYXknLCAnZmxhdE1hcCcpO1xuXG5cdC8vIGBBcnJheS5wcm90b3R5cGUuZmxhdGAgbWV0aG9kXG5cdC8vIGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L3Byb3Bvc2FsLWZsYXRNYXBcblx0X2V4cG9ydCh7IHRhcmdldDogJ0FycmF5JywgcHJvdG86IHRydWUgfSwge1xuXHQgIGZsYXQ6IGZ1bmN0aW9uIGZsYXQoLyogZGVwdGhBcmcgPSAxICovKSB7XG5cdCAgICB2YXIgZGVwdGhBcmcgPSBhcmd1bWVudHMubGVuZ3RoID8gYXJndW1lbnRzWzBdIDogdW5kZWZpbmVkO1xuXHQgICAgdmFyIE8gPSB0b09iamVjdCh0aGlzKTtcblx0ICAgIHZhciBzb3VyY2VMZW4gPSB0b0xlbmd0aChPLmxlbmd0aCk7XG5cdCAgICB2YXIgQSA9IGFycmF5U3BlY2llc0NyZWF0ZShPLCAwKTtcblx0ICAgIEEubGVuZ3RoID0gZmxhdHRlbkludG9BcnJheV8xKEEsIE8sIE8sIHNvdXJjZUxlbiwgMCwgZGVwdGhBcmcgPT09IHVuZGVmaW5lZCA/IDEgOiB0b0ludGVnZXIoZGVwdGhBcmcpKTtcblx0ICAgIHJldHVybiBBO1xuXHQgIH1cblx0fSk7XG5cblx0Ly8gdGhpcyBtZXRob2Qgd2FzIGFkZGVkIHRvIHVuc2NvcGFibGVzIGFmdGVyIGltcGxlbWVudGF0aW9uXG5cdC8vIGluIHBvcHVsYXIgZW5naW5lcywgc28gaXQncyBtb3ZlZCB0byBhIHNlcGFyYXRlIG1vZHVsZVxuXG5cblx0YWRkVG9VbnNjb3BhYmxlcygnZmxhdCcpO1xuXG5cdHZhciBmbGF0ID0gZW50cnlVbmJpbmQoJ0FycmF5JywgJ2ZsYXQnKTtcblxuXHR2YXIgZXMyMDE5QXJyYXkgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcblx0fSk7XG5cblx0dW53cmFwRXhwb3J0cyhlczIwMTlBcnJheSk7XG5cblx0dmFyIG5vbiA9ICdcXHUyMDBCXFx1MDA4NVxcdTE4MEUnO1xuXG5cdC8vIGNoZWNrIHRoYXQgYSBtZXRob2Qgd29ya3Mgd2l0aCB0aGUgY29ycmVjdCBsaXN0XG5cdC8vIG9mIHdoaXRlc3BhY2VzIGFuZCBoYXMgYSBjb3JyZWN0IG5hbWVcblx0dmFyIGZvcmNlZFN0cmluZ1RyaW1NZXRob2QgPSBmdW5jdGlvbiAoTUVUSE9EX05BTUUpIHtcblx0ICByZXR1cm4gZmFpbHMoZnVuY3Rpb24gKCkge1xuXHQgICAgcmV0dXJuICEhd2hpdGVzcGFjZXNbTUVUSE9EX05BTUVdKCkgfHwgbm9uW01FVEhPRF9OQU1FXSgpICE9IG5vbiB8fCB3aGl0ZXNwYWNlc1tNRVRIT0RfTkFNRV0ubmFtZSAhPT0gTUVUSE9EX05BTUU7XG5cdCAgfSk7XG5cdH07XG5cblx0dmFyICR0cmltRW5kID0gc3RyaW5nVHJpbS5lbmQ7XG5cblxuXHR2YXIgRk9SQ0VEJGIgPSBmb3JjZWRTdHJpbmdUcmltTWV0aG9kKCd0cmltRW5kJyk7XG5cblx0dmFyIHRyaW1FbmQgPSBGT1JDRUQkYiA/IGZ1bmN0aW9uIHRyaW1FbmQoKSB7XG5cdCAgcmV0dXJuICR0cmltRW5kKHRoaXMpO1xuXHR9IDogJycudHJpbUVuZDtcblxuXHQvLyBgU3RyaW5nLnByb3RvdHlwZS57IHRyaW1FbmQsIHRyaW1SaWdodCB9YCBtZXRob2RzXG5cdC8vIGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L2VjbWFzY3JpcHQtc3RyaW5nLWxlZnQtcmlnaHQtdHJpbVxuXHRfZXhwb3J0KHsgdGFyZ2V0OiAnU3RyaW5nJywgcHJvdG86IHRydWUsIGZvcmNlZDogRk9SQ0VEJGIgfSwge1xuXHQgIHRyaW1FbmQ6IHRyaW1FbmQsXG5cdCAgdHJpbVJpZ2h0OiB0cmltRW5kXG5cdH0pO1xuXG5cdHZhciB0cmltRW5kJDEgPSBlbnRyeVVuYmluZCgnU3RyaW5nJywgJ3RyaW1SaWdodCcpO1xuXG5cdHZhciAkdHJpbVN0YXJ0ID0gc3RyaW5nVHJpbS5zdGFydDtcblxuXG5cdHZhciBGT1JDRUQkYyA9IGZvcmNlZFN0cmluZ1RyaW1NZXRob2QoJ3RyaW1TdGFydCcpO1xuXG5cdHZhciB0cmltU3RhcnQgPSBGT1JDRUQkYyA/IGZ1bmN0aW9uIHRyaW1TdGFydCgpIHtcblx0ICByZXR1cm4gJHRyaW1TdGFydCh0aGlzKTtcblx0fSA6ICcnLnRyaW1TdGFydDtcblxuXHQvLyBgU3RyaW5nLnByb3RvdHlwZS57IHRyaW1TdGFydCwgdHJpbUxlZnQgfWAgbWV0aG9kc1xuXHQvLyBodHRwczovL2dpdGh1Yi5jb20vdGMzOS9lY21hc2NyaXB0LXN0cmluZy1sZWZ0LXJpZ2h0LXRyaW1cblx0X2V4cG9ydCh7IHRhcmdldDogJ1N0cmluZycsIHByb3RvOiB0cnVlLCBmb3JjZWQ6IEZPUkNFRCRjIH0sIHtcblx0ICB0cmltU3RhcnQ6IHRyaW1TdGFydCxcblx0ICB0cmltTGVmdDogdHJpbVN0YXJ0XG5cdH0pO1xuXG5cdHZhciB0cmltU3RhcnQkMSA9IGVudHJ5VW5iaW5kKCdTdHJpbmcnLCAndHJpbUxlZnQnKTtcblxuXHR2YXIgdHJpbUxlZnQgPSBlbnRyeVVuYmluZCgnU3RyaW5nJywgJ3RyaW1MZWZ0Jyk7XG5cblx0dmFyIHRyaW1SaWdodCA9IGVudHJ5VW5iaW5kKCdTdHJpbmcnLCAndHJpbVJpZ2h0Jyk7XG5cblx0dmFyIGVzMjAxOVN0cmluZyA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuXHR9KTtcblxuXHR1bndyYXBFeHBvcnRzKGVzMjAxOVN0cmluZyk7XG5cblx0Ly8gYE9iamVjdC5mcm9tRW50cmllc2AgbWV0aG9kXG5cdC8vIGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L3Byb3Bvc2FsLW9iamVjdC1mcm9tLWVudHJpZXNcblx0X2V4cG9ydCh7IHRhcmdldDogJ09iamVjdCcsIHN0YXQ6IHRydWUgfSwge1xuXHQgIGZyb21FbnRyaWVzOiBmdW5jdGlvbiBmcm9tRW50cmllcyhpdGVyYWJsZSkge1xuXHQgICAgdmFyIG9iaiA9IHt9O1xuXHQgICAgaXRlcmF0ZV8xKGl0ZXJhYmxlLCBmdW5jdGlvbiAoaywgdikge1xuXHQgICAgICBjcmVhdGVQcm9wZXJ0eShvYmosIGssIHYpO1xuXHQgICAgfSwgdW5kZWZpbmVkLCB0cnVlKTtcblx0ICAgIHJldHVybiBvYmo7XG5cdCAgfVxuXHR9KTtcblxuXHR2YXIgZnJvbUVudHJpZXMgPSBwYXRoLk9iamVjdC5mcm9tRW50cmllcztcblxuXHR2YXIgZXMyMDE5T2JqZWN0ID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5cdH0pO1xuXG5cdHVud3JhcEV4cG9ydHMoZXMyMDE5T2JqZWN0KTtcblxuXHR2YXIgY2hhckF0JDEgPSBzdHJpbmdNdWx0aWJ5dGUuY2hhckF0O1xuXG5cdC8vIGBBZHZhbmNlU3RyaW5nSW5kZXhgIGFic3RyYWN0IG9wZXJhdGlvblxuXHQvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1hZHZhbmNlc3RyaW5naW5kZXhcblx0dmFyIGFkdmFuY2VTdHJpbmdJbmRleCA9IGZ1bmN0aW9uIChTLCBpbmRleCwgdW5pY29kZSkge1xuXHQgIHJldHVybiBpbmRleCArICh1bmljb2RlID8gY2hhckF0JDEoUywgaW5kZXgpLmxlbmd0aCA6IDEpO1xuXHR9O1xuXG5cdHZhciBNQVRDSF9BTEwgPSB3ZWxsS25vd25TeW1ib2woJ21hdGNoQWxsJyk7XG5cdHZhciBSRUdFWFBfU1RSSU5HID0gJ1JlZ0V4cCBTdHJpbmcnO1xuXHR2YXIgUkVHRVhQX1NUUklOR19JVEVSQVRPUiA9IFJFR0VYUF9TVFJJTkcgKyAnIEl0ZXJhdG9yJztcblx0dmFyIHNldEludGVybmFsU3RhdGUkNiA9IGludGVybmFsU3RhdGUuc2V0O1xuXHR2YXIgZ2V0SW50ZXJuYWxTdGF0ZSQ0ID0gaW50ZXJuYWxTdGF0ZS5nZXR0ZXJGb3IoUkVHRVhQX1NUUklOR19JVEVSQVRPUik7XG5cdHZhciBSZWdFeHBQcm90b3R5cGUkMSA9IFJlZ0V4cC5wcm90b3R5cGU7XG5cdHZhciByZWdFeHBCdWlsdGluRXhlYyA9IFJlZ0V4cFByb3RvdHlwZSQxLmV4ZWM7XG5cblx0dmFyIHJlZ0V4cEV4ZWMgPSBmdW5jdGlvbiAoUiwgUykge1xuXHQgIHZhciBleGVjID0gUi5leGVjO1xuXHQgIHZhciByZXN1bHQ7XG5cdCAgaWYgKHR5cGVvZiBleGVjID09ICdmdW5jdGlvbicpIHtcblx0ICAgIHJlc3VsdCA9IGV4ZWMuY2FsbChSLCBTKTtcblx0ICAgIGlmICh0eXBlb2YgcmVzdWx0ICE9ICdvYmplY3QnKSB0aHJvdyBUeXBlRXJyb3IoJ0luY29ycmVjdCBleGVjIHJlc3VsdCcpO1xuXHQgICAgcmV0dXJuIHJlc3VsdDtcblx0ICB9IHJldHVybiByZWdFeHBCdWlsdGluRXhlYy5jYWxsKFIsIFMpO1xuXHR9O1xuXG5cdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBtYXgtbGVuXG5cdHZhciAkUmVnRXhwU3RyaW5nSXRlcmF0b3IgPSBjcmVhdGVJdGVyYXRvckNvbnN0cnVjdG9yKGZ1bmN0aW9uIFJlZ0V4cFN0cmluZ0l0ZXJhdG9yKHJlZ2V4cCwgc3RyaW5nLCBnbG9iYWwsIGZ1bGxVbmljb2RlKSB7XG5cdCAgc2V0SW50ZXJuYWxTdGF0ZSQ2KHRoaXMsIHtcblx0ICAgIHR5cGU6IFJFR0VYUF9TVFJJTkdfSVRFUkFUT1IsXG5cdCAgICByZWdleHA6IHJlZ2V4cCxcblx0ICAgIHN0cmluZzogc3RyaW5nLFxuXHQgICAgZ2xvYmFsOiBnbG9iYWwsXG5cdCAgICB1bmljb2RlOiBmdWxsVW5pY29kZSxcblx0ICAgIGRvbmU6IGZhbHNlXG5cdCAgfSk7XG5cdH0sIFJFR0VYUF9TVFJJTkcsIGZ1bmN0aW9uIG5leHQoKSB7XG5cdCAgdmFyIHN0YXRlID0gZ2V0SW50ZXJuYWxTdGF0ZSQ0KHRoaXMpO1xuXHQgIGlmIChzdGF0ZS5kb25lKSByZXR1cm4geyB2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlIH07XG5cdCAgdmFyIFIgPSBzdGF0ZS5yZWdleHA7XG5cdCAgdmFyIFMgPSBzdGF0ZS5zdHJpbmc7XG5cdCAgdmFyIG1hdGNoID0gcmVnRXhwRXhlYyhSLCBTKTtcblx0ICBpZiAobWF0Y2ggPT09IG51bGwpIHJldHVybiB7IHZhbHVlOiB1bmRlZmluZWQsIGRvbmU6IHN0YXRlLmRvbmUgPSB0cnVlIH07XG5cdCAgaWYgKHN0YXRlLmdsb2JhbCkge1xuXHQgICAgaWYgKFN0cmluZyhtYXRjaFswXSkgPT0gJycpIFIubGFzdEluZGV4ID0gYWR2YW5jZVN0cmluZ0luZGV4KFMsIHRvTGVuZ3RoKFIubGFzdEluZGV4KSwgc3RhdGUudW5pY29kZSk7XG5cdCAgICByZXR1cm4geyB2YWx1ZTogbWF0Y2gsIGRvbmU6IGZhbHNlIH07XG5cdCAgfVxuXHQgIHN0YXRlLmRvbmUgPSB0cnVlO1xuXHQgIHJldHVybiB7IHZhbHVlOiBtYXRjaCwgZG9uZTogZmFsc2UgfTtcblx0fSk7XG5cblx0dmFyICRtYXRjaEFsbCA9IGZ1bmN0aW9uIChzdHJpbmcpIHtcblx0ICB2YXIgUiA9IGFuT2JqZWN0KHRoaXMpO1xuXHQgIHZhciBTID0gU3RyaW5nKHN0cmluZyk7XG5cdCAgdmFyIEMsIGZsYWdzVmFsdWUsIGZsYWdzLCBtYXRjaGVyLCBnbG9iYWwsIGZ1bGxVbmljb2RlO1xuXHQgIEMgPSBzcGVjaWVzQ29uc3RydWN0b3IoUiwgUmVnRXhwKTtcblx0ICBmbGFnc1ZhbHVlID0gUi5mbGFncztcblx0ICBpZiAoZmxhZ3NWYWx1ZSA9PT0gdW5kZWZpbmVkICYmIFIgaW5zdGFuY2VvZiBSZWdFeHAgJiYgISgnZmxhZ3MnIGluIFJlZ0V4cFByb3RvdHlwZSQxKSkge1xuXHQgICAgZmxhZ3NWYWx1ZSA9IHJlZ2V4cEZsYWdzLmNhbGwoUik7XG5cdCAgfVxuXHQgIGZsYWdzID0gZmxhZ3NWYWx1ZSA9PT0gdW5kZWZpbmVkID8gJycgOiBTdHJpbmcoZmxhZ3NWYWx1ZSk7XG5cdCAgbWF0Y2hlciA9IG5ldyBDKEMgPT09IFJlZ0V4cCA/IFIuc291cmNlIDogUiwgZmxhZ3MpO1xuXHQgIGdsb2JhbCA9ICEhfmZsYWdzLmluZGV4T2YoJ2cnKTtcblx0ICBmdWxsVW5pY29kZSA9ICEhfmZsYWdzLmluZGV4T2YoJ3UnKTtcblx0ICBtYXRjaGVyLmxhc3RJbmRleCA9IHRvTGVuZ3RoKFIubGFzdEluZGV4KTtcblx0ICByZXR1cm4gbmV3ICRSZWdFeHBTdHJpbmdJdGVyYXRvcihtYXRjaGVyLCBTLCBnbG9iYWwsIGZ1bGxVbmljb2RlKTtcblx0fTtcblxuXHQvLyBgU3RyaW5nLnByb3RvdHlwZS5tYXRjaEFsbGAgbWV0aG9kXG5cdC8vIGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L3Byb3Bvc2FsLXN0cmluZy1tYXRjaGFsbFxuXHRfZXhwb3J0KHsgdGFyZ2V0OiAnU3RyaW5nJywgcHJvdG86IHRydWUgfSwge1xuXHQgIG1hdGNoQWxsOiBmdW5jdGlvbiBtYXRjaEFsbChyZWdleHApIHtcblx0ICAgIHZhciBPID0gcmVxdWlyZU9iamVjdENvZXJjaWJsZSh0aGlzKTtcblx0ICAgIHZhciBTLCBtYXRjaGVyLCByeDtcblx0ICAgIGlmIChyZWdleHAgIT0gbnVsbCkge1xuXHQgICAgICBtYXRjaGVyID0gcmVnZXhwW01BVENIX0FMTF07XG5cdCAgICAgIGlmIChtYXRjaGVyID09PSB1bmRlZmluZWQgJiYgaXNQdXJlICYmIGNsYXNzb2YocmVnZXhwKSA9PSAnUmVnRXhwJykgbWF0Y2hlciA9ICRtYXRjaEFsbDtcblx0ICAgICAgaWYgKG1hdGNoZXIgIT0gbnVsbCkgcmV0dXJuIGFGdW5jdGlvbiQxKG1hdGNoZXIpLmNhbGwocmVnZXhwLCBPKTtcblx0ICAgIH1cblx0ICAgIFMgPSBTdHJpbmcoTyk7XG5cdCAgICByeCA9IG5ldyBSZWdFeHAocmVnZXhwLCAnZycpO1xuXHQgICAgcmV0dXJuICByeFtNQVRDSF9BTExdKFMpO1xuXHQgIH1cblx0fSk7XG5cblx0IE1BVENIX0FMTCBpbiBSZWdFeHBQcm90b3R5cGUkMSB8fCBoaWRlKFJlZ0V4cFByb3RvdHlwZSQxLCBNQVRDSF9BTEwsICRtYXRjaEFsbCk7XG5cblx0dmFyIG1hdGNoQWxsID0gZW50cnlVbmJpbmQoJ1N0cmluZycsICdtYXRjaEFsbCcpO1xuXG5cdHZhciBlczIwMjBTdHJpbmcgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcblx0fSk7XG5cblx0dW53cmFwRXhwb3J0cyhlczIwMjBTdHJpbmcpO1xuXG5cdHZhciBsaWIgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcblx0fSk7XG5cblx0dmFyIGluZGV4JDEgPSB1bndyYXBFeHBvcnRzKGxpYik7XG5cblx0cmV0dXJuIGluZGV4JDE7XG5cbn0oKSk7XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/ts-polyfill/dist/ts-polyfill.js\n");

/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function(\"return this\")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvd2VicGFjay9idWlsZGluL2dsb2JhbC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8od2VicGFjaykvYnVpbGRpbi9nbG9iYWwuanM/Y2QwMCJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgZztcblxuLy8gVGhpcyB3b3JrcyBpbiBub24tc3RyaWN0IG1vZGVcbmcgPSAoZnVuY3Rpb24oKSB7XG5cdHJldHVybiB0aGlzO1xufSkoKTtcblxudHJ5IHtcblx0Ly8gVGhpcyB3b3JrcyBpZiBldmFsIGlzIGFsbG93ZWQgKHNlZSBDU1ApXG5cdGcgPSBnIHx8IG5ldyBGdW5jdGlvbihcInJldHVybiB0aGlzXCIpKCk7XG59IGNhdGNoIChlKSB7XG5cdC8vIFRoaXMgd29ya3MgaWYgdGhlIHdpbmRvdyByZWZlcmVuY2UgaXMgYXZhaWxhYmxlXG5cdGlmICh0eXBlb2Ygd2luZG93ID09PSBcIm9iamVjdFwiKSBnID0gd2luZG93O1xufVxuXG4vLyBnIGNhbiBzdGlsbCBiZSB1bmRlZmluZWQsIGJ1dCBub3RoaW5nIHRvIGRvIGFib3V0IGl0Li4uXG4vLyBXZSByZXR1cm4gdW5kZWZpbmVkLCBpbnN0ZWFkIG9mIG5vdGhpbmcgaGVyZSwgc28gaXQnc1xuLy8gZWFzaWVyIHRvIGhhbmRsZSB0aGlzIGNhc2UuIGlmKCFnbG9iYWwpIHsgLi4ufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGc7XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/webpack/buildin/global.js\n");

/***/ }),

/***/ "./node_modules/whatwg-fetch/fetch.js":
/*!********************************************!*\
  !*** ./node_modules/whatwg-fetch/fetch.js ***!
  \********************************************/
/*! exports provided: Headers, Request, Response, DOMException, fetch */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* WEBPACK VAR INJECTION */(function(Promise) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Headers\", function() { return Headers; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Request\", function() { return Request; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Response\", function() { return Response; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DOMException\", function() { return DOMException; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fetch\", function() { return fetch; });\nvar support = {\n  searchParams: 'URLSearchParams' in self,\n  iterable: 'Symbol' in self && 'iterator' in Symbol,\n  blob:\n    'FileReader' in self &&\n    'Blob' in self &&\n    (function() {\n      try {\n        new Blob()\n        return true\n      } catch (e) {\n        return false\n      }\n    })(),\n  formData: 'FormData' in self,\n  arrayBuffer: 'ArrayBuffer' in self\n}\n\nfunction isDataView(obj) {\n  return obj && DataView.prototype.isPrototypeOf(obj)\n}\n\nif (support.arrayBuffer) {\n  var viewClasses = [\n    '[object Int8Array]',\n    '[object Uint8Array]',\n    '[object Uint8ClampedArray]',\n    '[object Int16Array]',\n    '[object Uint16Array]',\n    '[object Int32Array]',\n    '[object Uint32Array]',\n    '[object Float32Array]',\n    '[object Float64Array]'\n  ]\n\n  var isArrayBufferView =\n    ArrayBuffer.isView ||\n    function(obj) {\n      return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1\n    }\n}\n\nfunction normalizeName(name) {\n  if (typeof name !== 'string') {\n    name = String(name)\n  }\n  if (/[^a-z0-9\\-#$%&'*+.^_`|~]/i.test(name)) {\n    throw new TypeError('Invalid character in header field name')\n  }\n  return name.toLowerCase()\n}\n\nfunction normalizeValue(value) {\n  if (typeof value !== 'string') {\n    value = String(value)\n  }\n  return value\n}\n\n// Build a destructive iterator for the value list\nfunction iteratorFor(items) {\n  var iterator = {\n    next: function() {\n      var value = items.shift()\n      return {done: value === undefined, value: value}\n    }\n  }\n\n  if (support.iterable) {\n    iterator[Symbol.iterator] = function() {\n      return iterator\n    }\n  }\n\n  return iterator\n}\n\nfunction Headers(headers) {\n  this.map = {}\n\n  if (headers instanceof Headers) {\n    headers.forEach(function(value, name) {\n      this.append(name, value)\n    }, this)\n  } else if (Array.isArray(headers)) {\n    headers.forEach(function(header) {\n      this.append(header[0], header[1])\n    }, this)\n  } else if (headers) {\n    Object.getOwnPropertyNames(headers).forEach(function(name) {\n      this.append(name, headers[name])\n    }, this)\n  }\n}\n\nHeaders.prototype.append = function(name, value) {\n  name = normalizeName(name)\n  value = normalizeValue(value)\n  var oldValue = this.map[name]\n  this.map[name] = oldValue ? oldValue + ', ' + value : value\n}\n\nHeaders.prototype['delete'] = function(name) {\n  delete this.map[normalizeName(name)]\n}\n\nHeaders.prototype.get = function(name) {\n  name = normalizeName(name)\n  return this.has(name) ? this.map[name] : null\n}\n\nHeaders.prototype.has = function(name) {\n  return this.map.hasOwnProperty(normalizeName(name))\n}\n\nHeaders.prototype.set = function(name, value) {\n  this.map[normalizeName(name)] = normalizeValue(value)\n}\n\nHeaders.prototype.forEach = function(callback, thisArg) {\n  for (var name in this.map) {\n    if (this.map.hasOwnProperty(name)) {\n      callback.call(thisArg, this.map[name], name, this)\n    }\n  }\n}\n\nHeaders.prototype.keys = function() {\n  var items = []\n  this.forEach(function(value, name) {\n    items.push(name)\n  })\n  return iteratorFor(items)\n}\n\nHeaders.prototype.values = function() {\n  var items = []\n  this.forEach(function(value) {\n    items.push(value)\n  })\n  return iteratorFor(items)\n}\n\nHeaders.prototype.entries = function() {\n  var items = []\n  this.forEach(function(value, name) {\n    items.push([name, value])\n  })\n  return iteratorFor(items)\n}\n\nif (support.iterable) {\n  Headers.prototype[Symbol.iterator] = Headers.prototype.entries\n}\n\nfunction consumed(body) {\n  if (body.bodyUsed) {\n    return Promise.reject(new TypeError('Already read'))\n  }\n  body.bodyUsed = true\n}\n\nfunction fileReaderReady(reader) {\n  return new Promise(function(resolve, reject) {\n    reader.onload = function() {\n      resolve(reader.result)\n    }\n    reader.onerror = function() {\n      reject(reader.error)\n    }\n  })\n}\n\nfunction readBlobAsArrayBuffer(blob) {\n  var reader = new FileReader()\n  var promise = fileReaderReady(reader)\n  reader.readAsArrayBuffer(blob)\n  return promise\n}\n\nfunction readBlobAsText(blob) {\n  var reader = new FileReader()\n  var promise = fileReaderReady(reader)\n  reader.readAsText(blob)\n  return promise\n}\n\nfunction readArrayBufferAsText(buf) {\n  var view = new Uint8Array(buf)\n  var chars = new Array(view.length)\n\n  for (var i = 0; i < view.length; i++) {\n    chars[i] = String.fromCharCode(view[i])\n  }\n  return chars.join('')\n}\n\nfunction bufferClone(buf) {\n  if (buf.slice) {\n    return buf.slice(0)\n  } else {\n    var view = new Uint8Array(buf.byteLength)\n    view.set(new Uint8Array(buf))\n    return view.buffer\n  }\n}\n\nfunction Body() {\n  this.bodyUsed = false\n\n  this._initBody = function(body) {\n    this._bodyInit = body\n    if (!body) {\n      this._bodyText = ''\n    } else if (typeof body === 'string') {\n      this._bodyText = body\n    } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {\n      this._bodyBlob = body\n    } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {\n      this._bodyFormData = body\n    } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {\n      this._bodyText = body.toString()\n    } else if (support.arrayBuffer && support.blob && isDataView(body)) {\n      this._bodyArrayBuffer = bufferClone(body.buffer)\n      // IE 10-11 can't handle a DataView body.\n      this._bodyInit = new Blob([this._bodyArrayBuffer])\n    } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {\n      this._bodyArrayBuffer = bufferClone(body)\n    } else {\n      this._bodyText = body = Object.prototype.toString.call(body)\n    }\n\n    if (!this.headers.get('content-type')) {\n      if (typeof body === 'string') {\n        this.headers.set('content-type', 'text/plain;charset=UTF-8')\n      } else if (this._bodyBlob && this._bodyBlob.type) {\n        this.headers.set('content-type', this._bodyBlob.type)\n      } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {\n        this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8')\n      }\n    }\n  }\n\n  if (support.blob) {\n    this.blob = function() {\n      var rejected = consumed(this)\n      if (rejected) {\n        return rejected\n      }\n\n      if (this._bodyBlob) {\n        return Promise.resolve(this._bodyBlob)\n      } else if (this._bodyArrayBuffer) {\n        return Promise.resolve(new Blob([this._bodyArrayBuffer]))\n      } else if (this._bodyFormData) {\n        throw new Error('could not read FormData body as blob')\n      } else {\n        return Promise.resolve(new Blob([this._bodyText]))\n      }\n    }\n\n    this.arrayBuffer = function() {\n      if (this._bodyArrayBuffer) {\n        return consumed(this) || Promise.resolve(this._bodyArrayBuffer)\n      } else {\n        return this.blob().then(readBlobAsArrayBuffer)\n      }\n    }\n  }\n\n  this.text = function() {\n    var rejected = consumed(this)\n    if (rejected) {\n      return rejected\n    }\n\n    if (this._bodyBlob) {\n      return readBlobAsText(this._bodyBlob)\n    } else if (this._bodyArrayBuffer) {\n      return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer))\n    } else if (this._bodyFormData) {\n      throw new Error('could not read FormData body as text')\n    } else {\n      return Promise.resolve(this._bodyText)\n    }\n  }\n\n  if (support.formData) {\n    this.formData = function() {\n      return this.text().then(decode)\n    }\n  }\n\n  this.json = function() {\n    return this.text().then(JSON.parse)\n  }\n\n  return this\n}\n\n// HTTP methods whose capitalization should be normalized\nvar methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT']\n\nfunction normalizeMethod(method) {\n  var upcased = method.toUpperCase()\n  return methods.indexOf(upcased) > -1 ? upcased : method\n}\n\nfunction Request(input, options) {\n  options = options || {}\n  var body = options.body\n\n  if (input instanceof Request) {\n    if (input.bodyUsed) {\n      throw new TypeError('Already read')\n    }\n    this.url = input.url\n    this.credentials = input.credentials\n    if (!options.headers) {\n      this.headers = new Headers(input.headers)\n    }\n    this.method = input.method\n    this.mode = input.mode\n    this.signal = input.signal\n    if (!body && input._bodyInit != null) {\n      body = input._bodyInit\n      input.bodyUsed = true\n    }\n  } else {\n    this.url = String(input)\n  }\n\n  this.credentials = options.credentials || this.credentials || 'same-origin'\n  if (options.headers || !this.headers) {\n    this.headers = new Headers(options.headers)\n  }\n  this.method = normalizeMethod(options.method || this.method || 'GET')\n  this.mode = options.mode || this.mode || null\n  this.signal = options.signal || this.signal\n  this.referrer = null\n\n  if ((this.method === 'GET' || this.method === 'HEAD') && body) {\n    throw new TypeError('Body not allowed for GET or HEAD requests')\n  }\n  this._initBody(body)\n}\n\nRequest.prototype.clone = function() {\n  return new Request(this, {body: this._bodyInit})\n}\n\nfunction decode(body) {\n  var form = new FormData()\n  body\n    .trim()\n    .split('&')\n    .forEach(function(bytes) {\n      if (bytes) {\n        var split = bytes.split('=')\n        var name = split.shift().replace(/\\+/g, ' ')\n        var value = split.join('=').replace(/\\+/g, ' ')\n        form.append(decodeURIComponent(name), decodeURIComponent(value))\n      }\n    })\n  return form\n}\n\nfunction parseHeaders(rawHeaders) {\n  var headers = new Headers()\n  // Replace instances of \\r\\n and \\n followed by at least one space or horizontal tab with a space\n  // https://tools.ietf.org/html/rfc7230#section-3.2\n  var preProcessedHeaders = rawHeaders.replace(/\\r?\\n[\\t ]+/g, ' ')\n  preProcessedHeaders.split(/\\r?\\n/).forEach(function(line) {\n    var parts = line.split(':')\n    var key = parts.shift().trim()\n    if (key) {\n      var value = parts.join(':').trim()\n      headers.append(key, value)\n    }\n  })\n  return headers\n}\n\nBody.call(Request.prototype)\n\nfunction Response(bodyInit, options) {\n  if (!options) {\n    options = {}\n  }\n\n  this.type = 'default'\n  this.status = options.status === undefined ? 200 : options.status\n  this.ok = this.status >= 200 && this.status < 300\n  this.statusText = 'statusText' in options ? options.statusText : 'OK'\n  this.headers = new Headers(options.headers)\n  this.url = options.url || ''\n  this._initBody(bodyInit)\n}\n\nBody.call(Response.prototype)\n\nResponse.prototype.clone = function() {\n  return new Response(this._bodyInit, {\n    status: this.status,\n    statusText: this.statusText,\n    headers: new Headers(this.headers),\n    url: this.url\n  })\n}\n\nResponse.error = function() {\n  var response = new Response(null, {status: 0, statusText: ''})\n  response.type = 'error'\n  return response\n}\n\nvar redirectStatuses = [301, 302, 303, 307, 308]\n\nResponse.redirect = function(url, status) {\n  if (redirectStatuses.indexOf(status) === -1) {\n    throw new RangeError('Invalid status code')\n  }\n\n  return new Response(null, {status: status, headers: {location: url}})\n}\n\nvar DOMException = self.DOMException\ntry {\n  new DOMException()\n} catch (err) {\n  DOMException = function(message, name) {\n    this.message = message\n    this.name = name\n    var error = Error(message)\n    this.stack = error.stack\n  }\n  DOMException.prototype = Object.create(Error.prototype)\n  DOMException.prototype.constructor = DOMException\n}\n\nfunction fetch(input, init) {\n  return new Promise(function(resolve, reject) {\n    var request = new Request(input, init)\n\n    if (request.signal && request.signal.aborted) {\n      return reject(new DOMException('Aborted', 'AbortError'))\n    }\n\n    var xhr = new XMLHttpRequest()\n\n    function abortXhr() {\n      xhr.abort()\n    }\n\n    xhr.onload = function() {\n      var options = {\n        status: xhr.status,\n        statusText: xhr.statusText,\n        headers: parseHeaders(xhr.getAllResponseHeaders() || '')\n      }\n      options.url = 'responseURL' in xhr ? xhr.responseURL : options.headers.get('X-Request-URL')\n      var body = 'response' in xhr ? xhr.response : xhr.responseText\n      resolve(new Response(body, options))\n    }\n\n    xhr.onerror = function() {\n      reject(new TypeError('Network request failed'))\n    }\n\n    xhr.ontimeout = function() {\n      reject(new TypeError('Network request failed'))\n    }\n\n    xhr.onabort = function() {\n      reject(new DOMException('Aborted', 'AbortError'))\n    }\n\n    xhr.open(request.method, request.url, true)\n\n    if (request.credentials === 'include') {\n      xhr.withCredentials = true\n    } else if (request.credentials === 'omit') {\n      xhr.withCredentials = false\n    }\n\n    if ('responseType' in xhr && support.blob) {\n      xhr.responseType = 'blob'\n    }\n\n    request.headers.forEach(function(value, name) {\n      xhr.setRequestHeader(name, value)\n    })\n\n    if (request.signal) {\n      request.signal.addEventListener('abort', abortXhr)\n\n      xhr.onreadystatechange = function() {\n        // DONE (success or failure)\n        if (xhr.readyState === 4) {\n          request.signal.removeEventListener('abort', abortXhr)\n        }\n      }\n    }\n\n    xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit)\n  })\n}\n\nfetch.polyfill = true\n\nif (!self.fetch) {\n  self.fetch = fetch\n  self.Headers = Headers\n  self.Request = Request\n  self.Response = Response\n}\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! es6-promise */ \"./node_modules/es6-promise/dist/es6-promise.js\")))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvd2hhdHdnLWZldGNoL2ZldGNoLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3doYXR3Zy1mZXRjaC9mZXRjaC5qcz82ZDkzIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBzdXBwb3J0ID0ge1xuICBzZWFyY2hQYXJhbXM6ICdVUkxTZWFyY2hQYXJhbXMnIGluIHNlbGYsXG4gIGl0ZXJhYmxlOiAnU3ltYm9sJyBpbiBzZWxmICYmICdpdGVyYXRvcicgaW4gU3ltYm9sLFxuICBibG9iOlxuICAgICdGaWxlUmVhZGVyJyBpbiBzZWxmICYmXG4gICAgJ0Jsb2InIGluIHNlbGYgJiZcbiAgICAoZnVuY3Rpb24oKSB7XG4gICAgICB0cnkge1xuICAgICAgICBuZXcgQmxvYigpXG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgIH0pKCksXG4gIGZvcm1EYXRhOiAnRm9ybURhdGEnIGluIHNlbGYsXG4gIGFycmF5QnVmZmVyOiAnQXJyYXlCdWZmZXInIGluIHNlbGZcbn1cblxuZnVuY3Rpb24gaXNEYXRhVmlldyhvYmopIHtcbiAgcmV0dXJuIG9iaiAmJiBEYXRhVmlldy5wcm90b3R5cGUuaXNQcm90b3R5cGVPZihvYmopXG59XG5cbmlmIChzdXBwb3J0LmFycmF5QnVmZmVyKSB7XG4gIHZhciB2aWV3Q2xhc3NlcyA9IFtcbiAgICAnW29iamVjdCBJbnQ4QXJyYXldJyxcbiAgICAnW29iamVjdCBVaW50OEFycmF5XScsXG4gICAgJ1tvYmplY3QgVWludDhDbGFtcGVkQXJyYXldJyxcbiAgICAnW29iamVjdCBJbnQxNkFycmF5XScsXG4gICAgJ1tvYmplY3QgVWludDE2QXJyYXldJyxcbiAgICAnW29iamVjdCBJbnQzMkFycmF5XScsXG4gICAgJ1tvYmplY3QgVWludDMyQXJyYXldJyxcbiAgICAnW29iamVjdCBGbG9hdDMyQXJyYXldJyxcbiAgICAnW29iamVjdCBGbG9hdDY0QXJyYXldJ1xuICBdXG5cbiAgdmFyIGlzQXJyYXlCdWZmZXJWaWV3ID1cbiAgICBBcnJheUJ1ZmZlci5pc1ZpZXcgfHxcbiAgICBmdW5jdGlvbihvYmopIHtcbiAgICAgIHJldHVybiBvYmogJiYgdmlld0NsYXNzZXMuaW5kZXhPZihPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqKSkgPiAtMVxuICAgIH1cbn1cblxuZnVuY3Rpb24gbm9ybWFsaXplTmFtZShuYW1lKSB7XG4gIGlmICh0eXBlb2YgbmFtZSAhPT0gJ3N0cmluZycpIHtcbiAgICBuYW1lID0gU3RyaW5nKG5hbWUpXG4gIH1cbiAgaWYgKC9bXmEtejAtOVxcLSMkJSYnKisuXl9gfH5dL2kudGVzdChuYW1lKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgY2hhcmFjdGVyIGluIGhlYWRlciBmaWVsZCBuYW1lJylcbiAgfVxuICByZXR1cm4gbmFtZS50b0xvd2VyQ2FzZSgpXG59XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZVZhbHVlKHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnKSB7XG4gICAgdmFsdWUgPSBTdHJpbmcodmFsdWUpXG4gIH1cbiAgcmV0dXJuIHZhbHVlXG59XG5cbi8vIEJ1aWxkIGEgZGVzdHJ1Y3RpdmUgaXRlcmF0b3IgZm9yIHRoZSB2YWx1ZSBsaXN0XG5mdW5jdGlvbiBpdGVyYXRvckZvcihpdGVtcykge1xuICB2YXIgaXRlcmF0b3IgPSB7XG4gICAgbmV4dDogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgdmFsdWUgPSBpdGVtcy5zaGlmdCgpXG4gICAgICByZXR1cm4ge2RvbmU6IHZhbHVlID09PSB1bmRlZmluZWQsIHZhbHVlOiB2YWx1ZX1cbiAgICB9XG4gIH1cblxuICBpZiAoc3VwcG9ydC5pdGVyYWJsZSkge1xuICAgIGl0ZXJhdG9yW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBpdGVyYXRvclxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBpdGVyYXRvclxufVxuXG5leHBvcnQgZnVuY3Rpb24gSGVhZGVycyhoZWFkZXJzKSB7XG4gIHRoaXMubWFwID0ge31cblxuICBpZiAoaGVhZGVycyBpbnN0YW5jZW9mIEhlYWRlcnMpIHtcbiAgICBoZWFkZXJzLmZvckVhY2goZnVuY3Rpb24odmFsdWUsIG5hbWUpIHtcbiAgICAgIHRoaXMuYXBwZW5kKG5hbWUsIHZhbHVlKVxuICAgIH0sIHRoaXMpXG4gIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShoZWFkZXJzKSkge1xuICAgIGhlYWRlcnMuZm9yRWFjaChmdW5jdGlvbihoZWFkZXIpIHtcbiAgICAgIHRoaXMuYXBwZW5kKGhlYWRlclswXSwgaGVhZGVyWzFdKVxuICAgIH0sIHRoaXMpXG4gIH0gZWxzZSBpZiAoaGVhZGVycykge1xuICAgIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGhlYWRlcnMpLmZvckVhY2goZnVuY3Rpb24obmFtZSkge1xuICAgICAgdGhpcy5hcHBlbmQobmFtZSwgaGVhZGVyc1tuYW1lXSlcbiAgICB9LCB0aGlzKVxuICB9XG59XG5cbkhlYWRlcnMucHJvdG90eXBlLmFwcGVuZCA9IGZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XG4gIG5hbWUgPSBub3JtYWxpemVOYW1lKG5hbWUpXG4gIHZhbHVlID0gbm9ybWFsaXplVmFsdWUodmFsdWUpXG4gIHZhciBvbGRWYWx1ZSA9IHRoaXMubWFwW25hbWVdXG4gIHRoaXMubWFwW25hbWVdID0gb2xkVmFsdWUgPyBvbGRWYWx1ZSArICcsICcgKyB2YWx1ZSA6IHZhbHVlXG59XG5cbkhlYWRlcnMucHJvdG90eXBlWydkZWxldGUnXSA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgZGVsZXRlIHRoaXMubWFwW25vcm1hbGl6ZU5hbWUobmFtZSldXG59XG5cbkhlYWRlcnMucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgbmFtZSA9IG5vcm1hbGl6ZU5hbWUobmFtZSlcbiAgcmV0dXJuIHRoaXMuaGFzKG5hbWUpID8gdGhpcy5tYXBbbmFtZV0gOiBudWxsXG59XG5cbkhlYWRlcnMucHJvdG90eXBlLmhhcyA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgcmV0dXJuIHRoaXMubWFwLmhhc093blByb3BlcnR5KG5vcm1hbGl6ZU5hbWUobmFtZSkpXG59XG5cbkhlYWRlcnMucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XG4gIHRoaXMubWFwW25vcm1hbGl6ZU5hbWUobmFtZSldID0gbm9ybWFsaXplVmFsdWUodmFsdWUpXG59XG5cbkhlYWRlcnMucHJvdG90eXBlLmZvckVhY2ggPSBmdW5jdGlvbihjYWxsYmFjaywgdGhpc0FyZykge1xuICBmb3IgKHZhciBuYW1lIGluIHRoaXMubWFwKSB7XG4gICAgaWYgKHRoaXMubWFwLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICBjYWxsYmFjay5jYWxsKHRoaXNBcmcsIHRoaXMubWFwW25hbWVdLCBuYW1lLCB0aGlzKVxuICAgIH1cbiAgfVxufVxuXG5IZWFkZXJzLnByb3RvdHlwZS5rZXlzID0gZnVuY3Rpb24oKSB7XG4gIHZhciBpdGVtcyA9IFtdXG4gIHRoaXMuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSwgbmFtZSkge1xuICAgIGl0ZW1zLnB1c2gobmFtZSlcbiAgfSlcbiAgcmV0dXJuIGl0ZXJhdG9yRm9yKGl0ZW1zKVxufVxuXG5IZWFkZXJzLnByb3RvdHlwZS52YWx1ZXMgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGl0ZW1zID0gW11cbiAgdGhpcy5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgaXRlbXMucHVzaCh2YWx1ZSlcbiAgfSlcbiAgcmV0dXJuIGl0ZXJhdG9yRm9yKGl0ZW1zKVxufVxuXG5IZWFkZXJzLnByb3RvdHlwZS5lbnRyaWVzID0gZnVuY3Rpb24oKSB7XG4gIHZhciBpdGVtcyA9IFtdXG4gIHRoaXMuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSwgbmFtZSkge1xuICAgIGl0ZW1zLnB1c2goW25hbWUsIHZhbHVlXSlcbiAgfSlcbiAgcmV0dXJuIGl0ZXJhdG9yRm9yKGl0ZW1zKVxufVxuXG5pZiAoc3VwcG9ydC5pdGVyYWJsZSkge1xuICBIZWFkZXJzLnByb3RvdHlwZVtTeW1ib2wuaXRlcmF0b3JdID0gSGVhZGVycy5wcm90b3R5cGUuZW50cmllc1xufVxuXG5mdW5jdGlvbiBjb25zdW1lZChib2R5KSB7XG4gIGlmIChib2R5LmJvZHlVc2VkKSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBUeXBlRXJyb3IoJ0FscmVhZHkgcmVhZCcpKVxuICB9XG4gIGJvZHkuYm9keVVzZWQgPSB0cnVlXG59XG5cbmZ1bmN0aW9uIGZpbGVSZWFkZXJSZWFkeShyZWFkZXIpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgIHJlYWRlci5vbmxvYWQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJlc29sdmUocmVhZGVyLnJlc3VsdClcbiAgICB9XG4gICAgcmVhZGVyLm9uZXJyb3IgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJlamVjdChyZWFkZXIuZXJyb3IpXG4gICAgfVxuICB9KVxufVxuXG5mdW5jdGlvbiByZWFkQmxvYkFzQXJyYXlCdWZmZXIoYmxvYikge1xuICB2YXIgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKVxuICB2YXIgcHJvbWlzZSA9IGZpbGVSZWFkZXJSZWFkeShyZWFkZXIpXG4gIHJlYWRlci5yZWFkQXNBcnJheUJ1ZmZlcihibG9iKVxuICByZXR1cm4gcHJvbWlzZVxufVxuXG5mdW5jdGlvbiByZWFkQmxvYkFzVGV4dChibG9iKSB7XG4gIHZhciByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpXG4gIHZhciBwcm9taXNlID0gZmlsZVJlYWRlclJlYWR5KHJlYWRlcilcbiAgcmVhZGVyLnJlYWRBc1RleHQoYmxvYilcbiAgcmV0dXJuIHByb21pc2Vcbn1cblxuZnVuY3Rpb24gcmVhZEFycmF5QnVmZmVyQXNUZXh0KGJ1Zikge1xuICB2YXIgdmlldyA9IG5ldyBVaW50OEFycmF5KGJ1ZilcbiAgdmFyIGNoYXJzID0gbmV3IEFycmF5KHZpZXcubGVuZ3RoKVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdmlldy5sZW5ndGg7IGkrKykge1xuICAgIGNoYXJzW2ldID0gU3RyaW5nLmZyb21DaGFyQ29kZSh2aWV3W2ldKVxuICB9XG4gIHJldHVybiBjaGFycy5qb2luKCcnKVxufVxuXG5mdW5jdGlvbiBidWZmZXJDbG9uZShidWYpIHtcbiAgaWYgKGJ1Zi5zbGljZSkge1xuICAgIHJldHVybiBidWYuc2xpY2UoMClcbiAgfSBlbHNlIHtcbiAgICB2YXIgdmlldyA9IG5ldyBVaW50OEFycmF5KGJ1Zi5ieXRlTGVuZ3RoKVxuICAgIHZpZXcuc2V0KG5ldyBVaW50OEFycmF5KGJ1ZikpXG4gICAgcmV0dXJuIHZpZXcuYnVmZmVyXG4gIH1cbn1cblxuZnVuY3Rpb24gQm9keSgpIHtcbiAgdGhpcy5ib2R5VXNlZCA9IGZhbHNlXG5cbiAgdGhpcy5faW5pdEJvZHkgPSBmdW5jdGlvbihib2R5KSB7XG4gICAgdGhpcy5fYm9keUluaXQgPSBib2R5XG4gICAgaWYgKCFib2R5KSB7XG4gICAgICB0aGlzLl9ib2R5VGV4dCA9ICcnXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgYm9keSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRoaXMuX2JvZHlUZXh0ID0gYm9keVxuICAgIH0gZWxzZSBpZiAoc3VwcG9ydC5ibG9iICYmIEJsb2IucHJvdG90eXBlLmlzUHJvdG90eXBlT2YoYm9keSkpIHtcbiAgICAgIHRoaXMuX2JvZHlCbG9iID0gYm9keVxuICAgIH0gZWxzZSBpZiAoc3VwcG9ydC5mb3JtRGF0YSAmJiBGb3JtRGF0YS5wcm90b3R5cGUuaXNQcm90b3R5cGVPZihib2R5KSkge1xuICAgICAgdGhpcy5fYm9keUZvcm1EYXRhID0gYm9keVxuICAgIH0gZWxzZSBpZiAoc3VwcG9ydC5zZWFyY2hQYXJhbXMgJiYgVVJMU2VhcmNoUGFyYW1zLnByb3RvdHlwZS5pc1Byb3RvdHlwZU9mKGJvZHkpKSB7XG4gICAgICB0aGlzLl9ib2R5VGV4dCA9IGJvZHkudG9TdHJpbmcoKVxuICAgIH0gZWxzZSBpZiAoc3VwcG9ydC5hcnJheUJ1ZmZlciAmJiBzdXBwb3J0LmJsb2IgJiYgaXNEYXRhVmlldyhib2R5KSkge1xuICAgICAgdGhpcy5fYm9keUFycmF5QnVmZmVyID0gYnVmZmVyQ2xvbmUoYm9keS5idWZmZXIpXG4gICAgICAvLyBJRSAxMC0xMSBjYW4ndCBoYW5kbGUgYSBEYXRhVmlldyBib2R5LlxuICAgICAgdGhpcy5fYm9keUluaXQgPSBuZXcgQmxvYihbdGhpcy5fYm9keUFycmF5QnVmZmVyXSlcbiAgICB9IGVsc2UgaWYgKHN1cHBvcnQuYXJyYXlCdWZmZXIgJiYgKEFycmF5QnVmZmVyLnByb3RvdHlwZS5pc1Byb3RvdHlwZU9mKGJvZHkpIHx8IGlzQXJyYXlCdWZmZXJWaWV3KGJvZHkpKSkge1xuICAgICAgdGhpcy5fYm9keUFycmF5QnVmZmVyID0gYnVmZmVyQ2xvbmUoYm9keSlcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fYm9keVRleHQgPSBib2R5ID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGJvZHkpXG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLmhlYWRlcnMuZ2V0KCdjb250ZW50LXR5cGUnKSkge1xuICAgICAgaWYgKHR5cGVvZiBib2R5ID09PSAnc3RyaW5nJykge1xuICAgICAgICB0aGlzLmhlYWRlcnMuc2V0KCdjb250ZW50LXR5cGUnLCAndGV4dC9wbGFpbjtjaGFyc2V0PVVURi04JylcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5fYm9keUJsb2IgJiYgdGhpcy5fYm9keUJsb2IudHlwZSkge1xuICAgICAgICB0aGlzLmhlYWRlcnMuc2V0KCdjb250ZW50LXR5cGUnLCB0aGlzLl9ib2R5QmxvYi50eXBlKVxuICAgICAgfSBlbHNlIGlmIChzdXBwb3J0LnNlYXJjaFBhcmFtcyAmJiBVUkxTZWFyY2hQYXJhbXMucHJvdG90eXBlLmlzUHJvdG90eXBlT2YoYm9keSkpIHtcbiAgICAgICAgdGhpcy5oZWFkZXJzLnNldCgnY29udGVudC10eXBlJywgJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZDtjaGFyc2V0PVVURi04JylcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoc3VwcG9ydC5ibG9iKSB7XG4gICAgdGhpcy5ibG9iID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgcmVqZWN0ZWQgPSBjb25zdW1lZCh0aGlzKVxuICAgICAgaWYgKHJlamVjdGVkKSB7XG4gICAgICAgIHJldHVybiByZWplY3RlZFxuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5fYm9keUJsb2IpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0aGlzLl9ib2R5QmxvYilcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5fYm9keUFycmF5QnVmZmVyKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobmV3IEJsb2IoW3RoaXMuX2JvZHlBcnJheUJ1ZmZlcl0pKVxuICAgICAgfSBlbHNlIGlmICh0aGlzLl9ib2R5Rm9ybURhdGEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjb3VsZCBub3QgcmVhZCBGb3JtRGF0YSBib2R5IGFzIGJsb2InKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShuZXcgQmxvYihbdGhpcy5fYm9keVRleHRdKSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmFycmF5QnVmZmVyID0gZnVuY3Rpb24oKSB7XG4gICAgICBpZiAodGhpcy5fYm9keUFycmF5QnVmZmVyKSB7XG4gICAgICAgIHJldHVybiBjb25zdW1lZCh0aGlzKSB8fCBQcm9taXNlLnJlc29sdmUodGhpcy5fYm9keUFycmF5QnVmZmVyKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYmxvYigpLnRoZW4ocmVhZEJsb2JBc0FycmF5QnVmZmVyKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHRoaXMudGV4dCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciByZWplY3RlZCA9IGNvbnN1bWVkKHRoaXMpXG4gICAgaWYgKHJlamVjdGVkKSB7XG4gICAgICByZXR1cm4gcmVqZWN0ZWRcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fYm9keUJsb2IpIHtcbiAgICAgIHJldHVybiByZWFkQmxvYkFzVGV4dCh0aGlzLl9ib2R5QmxvYilcbiAgICB9IGVsc2UgaWYgKHRoaXMuX2JvZHlBcnJheUJ1ZmZlcikge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShyZWFkQXJyYXlCdWZmZXJBc1RleHQodGhpcy5fYm9keUFycmF5QnVmZmVyKSlcbiAgICB9IGVsc2UgaWYgKHRoaXMuX2JvZHlGb3JtRGF0YSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdjb3VsZCBub3QgcmVhZCBGb3JtRGF0YSBib2R5IGFzIHRleHQnKVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMuX2JvZHlUZXh0KVxuICAgIH1cbiAgfVxuXG4gIGlmIChzdXBwb3J0LmZvcm1EYXRhKSB7XG4gICAgdGhpcy5mb3JtRGF0YSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMudGV4dCgpLnRoZW4oZGVjb2RlKVxuICAgIH1cbiAgfVxuXG4gIHRoaXMuanNvbiA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnRleHQoKS50aGVuKEpTT04ucGFyc2UpXG4gIH1cblxuICByZXR1cm4gdGhpc1xufVxuXG4vLyBIVFRQIG1ldGhvZHMgd2hvc2UgY2FwaXRhbGl6YXRpb24gc2hvdWxkIGJlIG5vcm1hbGl6ZWRcbnZhciBtZXRob2RzID0gWydERUxFVEUnLCAnR0VUJywgJ0hFQUQnLCAnT1BUSU9OUycsICdQT1NUJywgJ1BVVCddXG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZU1ldGhvZChtZXRob2QpIHtcbiAgdmFyIHVwY2FzZWQgPSBtZXRob2QudG9VcHBlckNhc2UoKVxuICByZXR1cm4gbWV0aG9kcy5pbmRleE9mKHVwY2FzZWQpID4gLTEgPyB1cGNhc2VkIDogbWV0aG9kXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBSZXF1ZXN0KGlucHV0LCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9XG4gIHZhciBib2R5ID0gb3B0aW9ucy5ib2R5XG5cbiAgaWYgKGlucHV0IGluc3RhbmNlb2YgUmVxdWVzdCkge1xuICAgIGlmIChpbnB1dC5ib2R5VXNlZCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQWxyZWFkeSByZWFkJylcbiAgICB9XG4gICAgdGhpcy51cmwgPSBpbnB1dC51cmxcbiAgICB0aGlzLmNyZWRlbnRpYWxzID0gaW5wdXQuY3JlZGVudGlhbHNcbiAgICBpZiAoIW9wdGlvbnMuaGVhZGVycykge1xuICAgICAgdGhpcy5oZWFkZXJzID0gbmV3IEhlYWRlcnMoaW5wdXQuaGVhZGVycylcbiAgICB9XG4gICAgdGhpcy5tZXRob2QgPSBpbnB1dC5tZXRob2RcbiAgICB0aGlzLm1vZGUgPSBpbnB1dC5tb2RlXG4gICAgdGhpcy5zaWduYWwgPSBpbnB1dC5zaWduYWxcbiAgICBpZiAoIWJvZHkgJiYgaW5wdXQuX2JvZHlJbml0ICE9IG51bGwpIHtcbiAgICAgIGJvZHkgPSBpbnB1dC5fYm9keUluaXRcbiAgICAgIGlucHV0LmJvZHlVc2VkID0gdHJ1ZVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0aGlzLnVybCA9IFN0cmluZyhpbnB1dClcbiAgfVxuXG4gIHRoaXMuY3JlZGVudGlhbHMgPSBvcHRpb25zLmNyZWRlbnRpYWxzIHx8IHRoaXMuY3JlZGVudGlhbHMgfHwgJ3NhbWUtb3JpZ2luJ1xuICBpZiAob3B0aW9ucy5oZWFkZXJzIHx8ICF0aGlzLmhlYWRlcnMpIHtcbiAgICB0aGlzLmhlYWRlcnMgPSBuZXcgSGVhZGVycyhvcHRpb25zLmhlYWRlcnMpXG4gIH1cbiAgdGhpcy5tZXRob2QgPSBub3JtYWxpemVNZXRob2Qob3B0aW9ucy5tZXRob2QgfHwgdGhpcy5tZXRob2QgfHwgJ0dFVCcpXG4gIHRoaXMubW9kZSA9IG9wdGlvbnMubW9kZSB8fCB0aGlzLm1vZGUgfHwgbnVsbFxuICB0aGlzLnNpZ25hbCA9IG9wdGlvbnMuc2lnbmFsIHx8IHRoaXMuc2lnbmFsXG4gIHRoaXMucmVmZXJyZXIgPSBudWxsXG5cbiAgaWYgKCh0aGlzLm1ldGhvZCA9PT0gJ0dFVCcgfHwgdGhpcy5tZXRob2QgPT09ICdIRUFEJykgJiYgYm9keSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0JvZHkgbm90IGFsbG93ZWQgZm9yIEdFVCBvciBIRUFEIHJlcXVlc3RzJylcbiAgfVxuICB0aGlzLl9pbml0Qm9keShib2R5KVxufVxuXG5SZXF1ZXN0LnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gbmV3IFJlcXVlc3QodGhpcywge2JvZHk6IHRoaXMuX2JvZHlJbml0fSlcbn1cblxuZnVuY3Rpb24gZGVjb2RlKGJvZHkpIHtcbiAgdmFyIGZvcm0gPSBuZXcgRm9ybURhdGEoKVxuICBib2R5XG4gICAgLnRyaW0oKVxuICAgIC5zcGxpdCgnJicpXG4gICAgLmZvckVhY2goZnVuY3Rpb24oYnl0ZXMpIHtcbiAgICAgIGlmIChieXRlcykge1xuICAgICAgICB2YXIgc3BsaXQgPSBieXRlcy5zcGxpdCgnPScpXG4gICAgICAgIHZhciBuYW1lID0gc3BsaXQuc2hpZnQoKS5yZXBsYWNlKC9cXCsvZywgJyAnKVxuICAgICAgICB2YXIgdmFsdWUgPSBzcGxpdC5qb2luKCc9JykucmVwbGFjZSgvXFwrL2csICcgJylcbiAgICAgICAgZm9ybS5hcHBlbmQoZGVjb2RlVVJJQ29tcG9uZW50KG5hbWUpLCBkZWNvZGVVUklDb21wb25lbnQodmFsdWUpKVxuICAgICAgfVxuICAgIH0pXG4gIHJldHVybiBmb3JtXG59XG5cbmZ1bmN0aW9uIHBhcnNlSGVhZGVycyhyYXdIZWFkZXJzKSB7XG4gIHZhciBoZWFkZXJzID0gbmV3IEhlYWRlcnMoKVxuICAvLyBSZXBsYWNlIGluc3RhbmNlcyBvZiBcXHJcXG4gYW5kIFxcbiBmb2xsb3dlZCBieSBhdCBsZWFzdCBvbmUgc3BhY2Ugb3IgaG9yaXpvbnRhbCB0YWIgd2l0aCBhIHNwYWNlXG4gIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM3MjMwI3NlY3Rpb24tMy4yXG4gIHZhciBwcmVQcm9jZXNzZWRIZWFkZXJzID0gcmF3SGVhZGVycy5yZXBsYWNlKC9cXHI/XFxuW1xcdCBdKy9nLCAnICcpXG4gIHByZVByb2Nlc3NlZEhlYWRlcnMuc3BsaXQoL1xccj9cXG4vKS5mb3JFYWNoKGZ1bmN0aW9uKGxpbmUpIHtcbiAgICB2YXIgcGFydHMgPSBsaW5lLnNwbGl0KCc6JylcbiAgICB2YXIga2V5ID0gcGFydHMuc2hpZnQoKS50cmltKClcbiAgICBpZiAoa2V5KSB7XG4gICAgICB2YXIgdmFsdWUgPSBwYXJ0cy5qb2luKCc6JykudHJpbSgpXG4gICAgICBoZWFkZXJzLmFwcGVuZChrZXksIHZhbHVlKVxuICAgIH1cbiAgfSlcbiAgcmV0dXJuIGhlYWRlcnNcbn1cblxuQm9keS5jYWxsKFJlcXVlc3QucHJvdG90eXBlKVxuXG5leHBvcnQgZnVuY3Rpb24gUmVzcG9uc2UoYm9keUluaXQsIG9wdGlvbnMpIHtcbiAgaWYgKCFvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IHt9XG4gIH1cblxuICB0aGlzLnR5cGUgPSAnZGVmYXVsdCdcbiAgdGhpcy5zdGF0dXMgPSBvcHRpb25zLnN0YXR1cyA9PT0gdW5kZWZpbmVkID8gMjAwIDogb3B0aW9ucy5zdGF0dXNcbiAgdGhpcy5vayA9IHRoaXMuc3RhdHVzID49IDIwMCAmJiB0aGlzLnN0YXR1cyA8IDMwMFxuICB0aGlzLnN0YXR1c1RleHQgPSAnc3RhdHVzVGV4dCcgaW4gb3B0aW9ucyA/IG9wdGlvbnMuc3RhdHVzVGV4dCA6ICdPSydcbiAgdGhpcy5oZWFkZXJzID0gbmV3IEhlYWRlcnMob3B0aW9ucy5oZWFkZXJzKVxuICB0aGlzLnVybCA9IG9wdGlvbnMudXJsIHx8ICcnXG4gIHRoaXMuX2luaXRCb2R5KGJvZHlJbml0KVxufVxuXG5Cb2R5LmNhbGwoUmVzcG9uc2UucHJvdG90eXBlKVxuXG5SZXNwb25zZS5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIG5ldyBSZXNwb25zZSh0aGlzLl9ib2R5SW5pdCwge1xuICAgIHN0YXR1czogdGhpcy5zdGF0dXMsXG4gICAgc3RhdHVzVGV4dDogdGhpcy5zdGF0dXNUZXh0LFxuICAgIGhlYWRlcnM6IG5ldyBIZWFkZXJzKHRoaXMuaGVhZGVycyksXG4gICAgdXJsOiB0aGlzLnVybFxuICB9KVxufVxuXG5SZXNwb25zZS5lcnJvciA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcmVzcG9uc2UgPSBuZXcgUmVzcG9uc2UobnVsbCwge3N0YXR1czogMCwgc3RhdHVzVGV4dDogJyd9KVxuICByZXNwb25zZS50eXBlID0gJ2Vycm9yJ1xuICByZXR1cm4gcmVzcG9uc2Vcbn1cblxudmFyIHJlZGlyZWN0U3RhdHVzZXMgPSBbMzAxLCAzMDIsIDMwMywgMzA3LCAzMDhdXG5cblJlc3BvbnNlLnJlZGlyZWN0ID0gZnVuY3Rpb24odXJsLCBzdGF0dXMpIHtcbiAgaWYgKHJlZGlyZWN0U3RhdHVzZXMuaW5kZXhPZihzdGF0dXMpID09PSAtMSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbnZhbGlkIHN0YXR1cyBjb2RlJylcbiAgfVxuXG4gIHJldHVybiBuZXcgUmVzcG9uc2UobnVsbCwge3N0YXR1czogc3RhdHVzLCBoZWFkZXJzOiB7bG9jYXRpb246IHVybH19KVxufVxuXG5leHBvcnQgdmFyIERPTUV4Y2VwdGlvbiA9IHNlbGYuRE9NRXhjZXB0aW9uXG50cnkge1xuICBuZXcgRE9NRXhjZXB0aW9uKClcbn0gY2F0Y2ggKGVycikge1xuICBET01FeGNlcHRpb24gPSBmdW5jdGlvbihtZXNzYWdlLCBuYW1lKSB7XG4gICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZVxuICAgIHRoaXMubmFtZSA9IG5hbWVcbiAgICB2YXIgZXJyb3IgPSBFcnJvcihtZXNzYWdlKVxuICAgIHRoaXMuc3RhY2sgPSBlcnJvci5zdGFja1xuICB9XG4gIERPTUV4Y2VwdGlvbi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEVycm9yLnByb3RvdHlwZSlcbiAgRE9NRXhjZXB0aW9uLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IERPTUV4Y2VwdGlvblxufVxuXG5leHBvcnQgZnVuY3Rpb24gZmV0Y2goaW5wdXQsIGluaXQpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgIHZhciByZXF1ZXN0ID0gbmV3IFJlcXVlc3QoaW5wdXQsIGluaXQpXG5cbiAgICBpZiAocmVxdWVzdC5zaWduYWwgJiYgcmVxdWVzdC5zaWduYWwuYWJvcnRlZCkge1xuICAgICAgcmV0dXJuIHJlamVjdChuZXcgRE9NRXhjZXB0aW9uKCdBYm9ydGVkJywgJ0Fib3J0RXJyb3InKSlcbiAgICB9XG5cbiAgICB2YXIgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KClcblxuICAgIGZ1bmN0aW9uIGFib3J0WGhyKCkge1xuICAgICAgeGhyLmFib3J0KClcbiAgICB9XG5cbiAgICB4aHIub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgICAgc3RhdHVzOiB4aHIuc3RhdHVzLFxuICAgICAgICBzdGF0dXNUZXh0OiB4aHIuc3RhdHVzVGV4dCxcbiAgICAgICAgaGVhZGVyczogcGFyc2VIZWFkZXJzKHhoci5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKSB8fCAnJylcbiAgICAgIH1cbiAgICAgIG9wdGlvbnMudXJsID0gJ3Jlc3BvbnNlVVJMJyBpbiB4aHIgPyB4aHIucmVzcG9uc2VVUkwgOiBvcHRpb25zLmhlYWRlcnMuZ2V0KCdYLVJlcXVlc3QtVVJMJylcbiAgICAgIHZhciBib2R5ID0gJ3Jlc3BvbnNlJyBpbiB4aHIgPyB4aHIucmVzcG9uc2UgOiB4aHIucmVzcG9uc2VUZXh0XG4gICAgICByZXNvbHZlKG5ldyBSZXNwb25zZShib2R5LCBvcHRpb25zKSlcbiAgICB9XG5cbiAgICB4aHIub25lcnJvciA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmVqZWN0KG5ldyBUeXBlRXJyb3IoJ05ldHdvcmsgcmVxdWVzdCBmYWlsZWQnKSlcbiAgICB9XG5cbiAgICB4aHIub250aW1lb3V0ID0gZnVuY3Rpb24oKSB7XG4gICAgICByZWplY3QobmV3IFR5cGVFcnJvcignTmV0d29yayByZXF1ZXN0IGZhaWxlZCcpKVxuICAgIH1cblxuICAgIHhoci5vbmFib3J0ID0gZnVuY3Rpb24oKSB7XG4gICAgICByZWplY3QobmV3IERPTUV4Y2VwdGlvbignQWJvcnRlZCcsICdBYm9ydEVycm9yJykpXG4gICAgfVxuXG4gICAgeGhyLm9wZW4ocmVxdWVzdC5tZXRob2QsIHJlcXVlc3QudXJsLCB0cnVlKVxuXG4gICAgaWYgKHJlcXVlc3QuY3JlZGVudGlhbHMgPT09ICdpbmNsdWRlJykge1xuICAgICAgeGhyLndpdGhDcmVkZW50aWFscyA9IHRydWVcbiAgICB9IGVsc2UgaWYgKHJlcXVlc3QuY3JlZGVudGlhbHMgPT09ICdvbWl0Jykge1xuICAgICAgeGhyLndpdGhDcmVkZW50aWFscyA9IGZhbHNlXG4gICAgfVxuXG4gICAgaWYgKCdyZXNwb25zZVR5cGUnIGluIHhociAmJiBzdXBwb3J0LmJsb2IpIHtcbiAgICAgIHhoci5yZXNwb25zZVR5cGUgPSAnYmxvYidcbiAgICB9XG5cbiAgICByZXF1ZXN0LmhlYWRlcnMuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSwgbmFtZSkge1xuICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIobmFtZSwgdmFsdWUpXG4gICAgfSlcblxuICAgIGlmIChyZXF1ZXN0LnNpZ25hbCkge1xuICAgICAgcmVxdWVzdC5zaWduYWwuYWRkRXZlbnRMaXN0ZW5lcignYWJvcnQnLCBhYm9ydFhocilcblxuICAgICAgeGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAvLyBET05FIChzdWNjZXNzIG9yIGZhaWx1cmUpXG4gICAgICAgIGlmICh4aHIucmVhZHlTdGF0ZSA9PT0gNCkge1xuICAgICAgICAgIHJlcXVlc3Quc2lnbmFsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Fib3J0JywgYWJvcnRYaHIpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB4aHIuc2VuZCh0eXBlb2YgcmVxdWVzdC5fYm9keUluaXQgPT09ICd1bmRlZmluZWQnID8gbnVsbCA6IHJlcXVlc3QuX2JvZHlJbml0KVxuICB9KVxufVxuXG5mZXRjaC5wb2x5ZmlsbCA9IHRydWVcblxuaWYgKCFzZWxmLmZldGNoKSB7XG4gIHNlbGYuZmV0Y2ggPSBmZXRjaFxuICBzZWxmLkhlYWRlcnMgPSBIZWFkZXJzXG4gIHNlbGYuUmVxdWVzdCA9IFJlcXVlc3RcbiAgc2VsZi5SZXNwb25zZSA9IFJlc3BvbnNlXG59XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/whatwg-fetch/fetch.js\n");

/***/ }),

/***/ "./src/main.ts":
/*!*********************!*\
  !*** ./src/main.ts ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar __importStar = (this && this.__importStar) || function (mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result[\"default\"] = mod;\r\n    return result;\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar Qns = __importStar(__webpack_require__(/*! ./metadata/questions.json */ \"./src/metadata/questions.json\"));\r\nvar mappingData = __importStar(__webpack_require__(/*! ./metadata/mapping.json */ \"./src/metadata/mapping.json\"));\r\n__webpack_require__(/*! ts-polyfill */ \"./node_modules/ts-polyfill/dist/ts-polyfill.js\");\r\n__webpack_require__(/*! whatwg-fetch */ \"./node_modules/whatwg-fetch/fetch.js\");\r\nvar Main = /** @class */ (function () {\r\n    function Main() {\r\n        this.indexGlobal = 0;\r\n        this.checkShowAll = false;\r\n        this.data = Qns.elements;\r\n        //#region Static HTML Question Page\r\n        this.template = \"\\n    <div class=\\\"tyfb_heading\\\">Question @index of @totalQuestions</div>\\n    <div class=\\\"tyfb_ques\\\">@index. @question</div>\\n    <div class=\\\"tyfb_opt\\\">\\n        @options\\n    </div>\\n    <button id=\\\"btnContinue\\\" type=\\\"button\\\" class=\\\"tyfb_btn\\\" onclick=\\\"click\\\">Continue</button>\";\r\n        this.optionHTML = \"<div class=\\\"tyfb_option\\\">\\n    <input class=\\\"inp-cbx\\\" id=\\\"option-@optionIndex\\\" name=\\\"@name\\\" type=\\\"@type\\\" style=\\\"display: none;\\\">\\n    <label class=\\\"cbx\\\" for=\\\"option-@optionIndex\\\">\\n        <span class=\\\"tyfb_chk\\\">\\n            <svg width=\\\"14px\\\" height=\\\"12px\\\" viewBox=\\\"0 0 14 12\\\">\\n                <polyline points=\\\"1.5 6 4.5 9 10.5 1\\\"></polyline>\\n            </svg>\\n        </span>\\n        <span class=\\\"chk-options\\\">@optionValue\\n            \\n            </span>\\n    </span>\\n    </label>\\n    <span class=\\\"tyfb_tooltip\\\"><i>?</i></span>\\n    <div class=\\\"tyfb-panel\\\">@tooltipText</div>\\n    </div>\";\r\n        this.radioOptionHTML = \"<div class=\\\"tyfb_option\\\">\\n        <label for=\\\"option-@optionIndex\\\" class=\\\"radio\\\">\\n            <input type=\\\"radio\\\" name=\\\"@name\\\" id=\\\"option-@optionIndex\\\" class=\\\"hidden\\\" />\\n            <span class=\\\"label\\\"></span><span class=\\\"radio-txt\\\">@optionValue</span>\\n        </label>\\n    </div>\";\r\n        //#endregion\r\n        //#region Static Result Page HTML\r\n        this.currentSelectionTemplate = \"<div class=\\\"tyfb_filter-col\\\">\\n    <strong>@questionKeyword</strong>\\n    @selectionOptions\\n    </div>\";\r\n        this.currentSelectionOptiontemplate = \"<span class=\\\"tyfb_option tyfb_option--inline\\\">\\n    <input class=\\\"inp-cbx\\\" id=\\\"resultOption-@index\\\" type=\\\"@type\\\" name=\\\"@name\\\" @checked style=\\\"display: none;\\\">\\n    <label class=\\\"cbx\\\" for=\\\"resultOption-@index\\\">\\n        <span class=\\\"tyfb_chk\\\">\\n            <svg width=\\\"14px\\\" height=\\\"12px\\\" viewBox=\\\"0 0 14 12\\\">\\n                <polyline points=\\\"1.5 6 4.5 9 10.5 1\\\"></polyline>\\n            </svg>\\n        </span>\\n        <span class=\\\"chk-options\\\">@keyword</span>\\n    </label>\\n</span>\";\r\n        this.currentSelectionRadioOptiontemplate = \"<span class=\\\"tyfb_option tyfb_option--inline\\\">\\n<label for=\\\"resultOption-@index\\\" class=\\\"radio\\\">\\n<input type=\\\"radio\\\" name=\\\"@name\\\" id=\\\"resultOption-@index\\\" class=\\\"hidden\\\" @checked/>\\n<span class=\\\"label\\\"></span><span class=\\\"radio-txt\\\">@keyword</span>\\n</label>\\n</span>\";\r\n        this.InitialLoad();\r\n    }\r\n    Main.prototype.InitialLoad = function () {\r\n        var _this = this;\r\n        this.indexGlobal = 0;\r\n        this.checkShowAll = false;\r\n        // const noResultDiv: HTMLElement = document.getElementById('noResultDiv');\r\n        // noResultDiv.style.display = \"none\";\r\n        var productDiv = document.getElementById('productDiv');\r\n        productDiv.style.display = \"none\";\r\n        productDiv.innerHTML = \"\";\r\n        // const suggestedDiv: HTMLElement = document.getElementById('suggestedDiv');\r\n        // suggestedDiv.style.display = \"none\";\r\n        var headingShowAll = document.getElementById('headingShowAll');\r\n        headingShowAll.style.display = \"none\";\r\n        var newSearchBtn = document.getElementById(\"newSearchBtn\");\r\n        newSearchBtn.style.display = 'none';\r\n        var mainHeading = document.getElementById('mainHeading');\r\n        mainHeading.style.display = \"block\";\r\n        var el = document.getElementById('questionDiv');\r\n        el.style.display = \"block\";\r\n        el.innerHTML = this.getQuestion(0);\r\n        var resultDiv = document.getElementById('resultDiv');\r\n        resultDiv.style.display = \"none\";\r\n        // const headerCurrentSelection: HTMLElement = document.getElementById('headerCurrentSelection');\r\n        // headerCurrentSelection.style.display = \"none\";\r\n        // const currentSelections: HTMLElement = document.getElementById('currentSelections');\r\n        // currentSelections.style.display = \"none\";\r\n        var showAllBtn = document.getElementById(\"showAllbtn\");\r\n        showAllBtn.addEventListener(\"click\", function (e) { return _this.ShowAll(); });\r\n        var btn = document.getElementById(\"btnContinue\");\r\n        btn.addEventListener(\"click\", function (e) { return _this.btnClick(); });\r\n        this.linkHintData();\r\n    };\r\n    Main.prototype.btnClick = function () {\r\n        var _this = this;\r\n        //Get all the options of current questions and check which one are selected\r\n        //#region\r\n        for (var index = 0; index < this.data[this.indexGlobal].answers.length; index++) {\r\n            var option = document.getElementById(\"option-\" + index + \"\");\r\n            if (option.checked) {\r\n                this.data[this.indexGlobal].answers[index].isSelected = true;\r\n            }\r\n        }\r\n        var el = document.getElementById('questionDiv');\r\n        var arLength = Object.keys(this.data).length;\r\n        this.indexGlobal = this.indexGlobal + 1;\r\n        //Below, we are checking, if it is the last question then show result page. otherwise show next question\r\n        if (this.indexGlobal < arLength) {\r\n            el.innerHTML = this.getQuestion(this.indexGlobal);\r\n            var btn = document.getElementById(\"btnContinue\");\r\n            btn.addEventListener(\"click\", function (e) { return _this.btnClick(); });\r\n            this.linkHintData();\r\n        }\r\n        else {\r\n            this.showResultPage();\r\n        }\r\n    };\r\n    Main.prototype.getQuestion = function (indexLocal) {\r\n        var _this = this;\r\n        var questionData = this.data[indexLocal];\r\n        var templateData = this.template.replace(\"@question\", questionData.title)\r\n            .replace(\"@index\", (indexLocal + 1).toString())\r\n            .replace(\"@index\", (indexLocal + 1).toString())\r\n            .replace(\"@totalQuestions\", this.data.length.toString());\r\n        var optionIndex = 0;\r\n        var optionsWithHTML = \"\";\r\n        if (questionData.answerType == 1) {\r\n            //For CheckBox\r\n            questionData.answers.forEach(function (x) {\r\n                optionsWithHTML += _this.optionHTML.replace(\"@type\", \"checkbox\")\r\n                    .replace(\"@optionIndex\", optionIndex.toString())\r\n                    .replace(\"@optionIndex\", optionIndex.toString())\r\n                    .replace(\"@optionValue\", x.lineItem)\r\n                    .replace(\"@name\", \"chkBoxQuestion\")\r\n                    .replace(\"@tooltipText\", x.toolTipText);\r\n                optionIndex++;\r\n            });\r\n        }\r\n        else if (questionData.answerType == 2) {\r\n            //For RadioButton\r\n            questionData.answers.forEach(function (x) {\r\n                optionsWithHTML += _this.radioOptionHTML.replace(\"@type\", \"radio\")\r\n                    .replace(\"@optionIndex\", optionIndex.toString())\r\n                    .replace(\"@optionIndex\", optionIndex.toString())\r\n                    .replace(\"@optionValue\", x.lineItem)\r\n                    .replace(\"@name\", \"rdoBtnQuestion\");\r\n                optionIndex++;\r\n            });\r\n        }\r\n        templateData = templateData.replace(\"@options\", optionsWithHTML);\r\n        return templateData;\r\n    };\r\n    Main.prototype.showResultPage = function () {\r\n        var productDiv = document.getElementById('productDiv');\r\n        productDiv.innerHTML = \"\";\r\n        this.showCurrentSelections();\r\n        this.filterData();\r\n    };\r\n    Main.prototype.showCurrentSelections = function () {\r\n        var _this = this;\r\n        var resultDiv = document.getElementById('resultDiv');\r\n        resultDiv.style.display = \"block\";\r\n        var questionDiv = document.getElementById('questionDiv');\r\n        questionDiv.style.display = \"none\";\r\n        var currentSelectionsDiv = document.getElementById('currentSelections');\r\n        currentSelectionsDiv.style.display = \"block\";\r\n        var headerCurrentSelection = document.getElementById('headerCurrentSelection');\r\n        headerCurrentSelection.style.display = \"block\";\r\n        //#region Create current selections options on result page\r\n        var arLength = Object.keys(this.data).length;\r\n        var template = \"\";\r\n        var _loop_1 = function (index) {\r\n            questionData = this_1.data[index];\r\n            optionsHTML = \"\";\r\n            optionIndex = 0;\r\n            questionData.answers.forEach(function (x) {\r\n                if (questionData.answerType.toString() == \"1\") {\r\n                    optionsHTML += _this.currentSelectionOptiontemplate.replace(\"@index\", index.toString() + \"-\" + optionIndex.toString())\r\n                        .replace(\"@index\", index.toString() + \"-\" + optionIndex.toString())\r\n                        .replace(\"@name\", index.toString())\r\n                        .replace(\"@type\", \"checkbox\")\r\n                        .replace(\"@checked\", x.isSelected ? \"checked\" : \"\")\r\n                        .replace(\"@keyword\", x.keyword);\r\n                }\r\n                else {\r\n                    optionsHTML += _this.currentSelectionRadioOptiontemplate.replace(\"@index\", index.toString() + \"-\" + optionIndex.toString())\r\n                        .replace(\"@index\", index.toString() + \"-\" + optionIndex.toString())\r\n                        .replace(\"@name\", index.toString())\r\n                        .replace(\"@type\", \"radio\")\r\n                        .replace(\"@checked\", x.isSelected ? \"checked\" : \"\")\r\n                        .replace(\"@keyword\", x.keyword);\r\n                }\r\n                optionIndex++;\r\n            });\r\n            template += this_1.currentSelectionTemplate.replace(\"@questionKeyword\", questionData.keyword)\r\n                .replace(\"@selectionOptions\", optionsHTML);\r\n        };\r\n        var this_1 = this, questionData, optionsHTML, optionIndex;\r\n        for (var index = 0; index < arLength; index++) {\r\n            _loop_1(index);\r\n        }\r\n        currentSelectionsDiv.innerHTML = template;\r\n        var checkboxes = document.querySelectorAll('*[id^=\"resultOption\"]');\r\n        for (var index = 0; index < checkboxes.length; index++) {\r\n            var element = checkboxes[index];\r\n            element.addEventListener(\"click\", function (e) { return _this.filterData(); });\r\n        }\r\n        //#endregion\r\n    };\r\n    Main.prototype.filterData = function () {\r\n        //On the change of checkboxes on result page, this method will be called and we are getting all the checked input elements\r\n        var checkboxes = document.querySelectorAll('*[id^=\"resultOption\"]');\r\n        for (var index = 0; index < checkboxes.length; index++) {\r\n            if (checkboxes[index].checked) {\r\n                var questionIndex = checkboxes[index].id.split('-')[1];\r\n                var optionIndex = checkboxes[index].id.split('-')[2];\r\n                this.data[questionIndex].answers[optionIndex].isSelected = true;\r\n            }\r\n            else {\r\n                var questionIndex = checkboxes[index].id.split('-')[1];\r\n                var optionIndex = checkboxes[index].id.split('-')[2];\r\n                this.data[questionIndex].answers[optionIndex].isSelected = false;\r\n            }\r\n        }\r\n        var foundBooks = [];\r\n        var questions;\r\n        questions = Object.assign([], this.data);\r\n        foundBooks = this.searchAlgorithm(questions);\r\n        var suggestedBooks = false;\r\n        if (foundBooks.length == 0) {\r\n            suggestedBooks = true;\r\n            for (var noOfQuestionToSkip = 1; noOfQuestionToSkip < questions.length; noOfQuestionToSkip++) {\r\n                //index is level as well as no of questions to s\r\n                for (var removeIndex = 0; removeIndex < questions.length; removeIndex++) {\r\n                    var tempQuestions = Object.assign([], questions);\r\n                    if ((removeIndex + noOfQuestionToSkip - 1) >= questions.length) {\r\n                        tempQuestions.splice(removeIndex, questions.length - removeIndex);\r\n                        tempQuestions.splice(0, noOfQuestionToSkip + removeIndex - questions.length);\r\n                    }\r\n                    else {\r\n                        tempQuestions.splice(removeIndex, noOfQuestionToSkip);\r\n                    }\r\n                    var tempBooks = this.searchAlgorithm(tempQuestions);\r\n                    if (tempBooks.length > 0) {\r\n                        tempBooks.forEach(function (x) {\r\n                            if (foundBooks.indexOf(x) == -1)\r\n                                foundBooks.push(x);\r\n                        });\r\n                    }\r\n                }\r\n                if (foundBooks.length > 0) {\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        if (foundBooks.length == 0) {\r\n            var arMapping = mappingData.mapping;\r\n            foundBooks = arMapping.map(function (x) { return x.ISBN; });\r\n        }\r\n        var currentSelections = document.getElementById('currentSelections');\r\n        currentSelections.style.pointerEvents = \"none\";\r\n        console.log(\"Found books\", foundBooks);\r\n        this.callAPI(foundBooks, suggestedBooks);\r\n    };\r\n    Main.prototype.searchAlgorithm = function (questions) {\r\n        var arMapping = mappingData.mapping;\r\n        var foundBooks = [];\r\n        if (arMapping) {\r\n            var selectedOptions = void 0;\r\n            var isbnArray = [];\r\n            arMapping.forEach(function (mapping) {\r\n                var isHit = false;\r\n                questions.every(function (qns) {\r\n                    var ans = qns.answers.filter(function (a) { return a.isSelected; });\r\n                    if (ans.length > 0) {\r\n                        var foundAns_1 = false;\r\n                        ans.every(function (z) {\r\n                            if (mapping[qns.keyword])\r\n                                if (mapping[qns.keyword].indexOf(z.keyword) > -1) {\r\n                                    foundAns_1 = true;\r\n                                    return false;\r\n                                }\r\n                                else {\r\n                                    foundAns_1 = false;\r\n                                    return true;\r\n                                }\r\n                        });\r\n                        if (foundAns_1) {\r\n                            isHit = true;\r\n                            return true;\r\n                        }\r\n                        else {\r\n                            isHit = false;\r\n                            return false;\r\n                        }\r\n                    }\r\n                    else {\r\n                        isHit = true;\r\n                        return true;\r\n                    }\r\n                });\r\n                if (isHit) {\r\n                    foundBooks.push(mapping.ISBN);\r\n                }\r\n            });\r\n        }\r\n        return foundBooks;\r\n    };\r\n    Main.prototype.callAPI = function (isbnNumbers, showSuggestionsDiv) {\r\n        var _this = this;\r\n        if (isbnNumbers.length == null || isbnNumbers.length == 0) {\r\n            isbnNumbers = mappingData.mapping.map(function (x) { return x.ISBN; });\r\n            showSuggestionsDiv = true;\r\n        }\r\n        var params = {\r\n            \"scopeid\": \"1\",\r\n            \"products\": isbnNumbers\r\n        };\r\n        window.fetch(\"https://ws.tyndale.com/api/products/get\", {\r\n            method: 'post',\r\n            headers: {\r\n                'Accept': 'application/json',\r\n                'Content-Type': 'application/json',\r\n                'api-key': '>Qm-v*]M9np,u#+'\r\n            },\r\n            mode: 'cors',\r\n            body: JSON.stringify(params)\r\n        }).then(function (response) { return response.json(); })\r\n            .then(function (response) {\r\n            console.log('in response api call');\r\n            var arRawProducts = response.Products;\r\n            var products;\r\n            var productTemplate = \"<div class=\\\"tyfb_col-sm-3\\\">\\n                    <div class=\\\"tyfb_prd-im\\\">\\n                        <img src=\\\"@imagePath\\\" alt=\\\"Product\\\" width=\\\"250\\\"/>\\n                    </div>\\n                    <div class=\\\"tyfb_prd-content\\\">\\n                        <p>@title</p>\\n                        <span class=\\\"tyfb_prd-content__type\\\">@coverType</span>\\n                        <span class=\\\"tyfb_prd-content__price\\\">$@price</span>\\n                        <a href=\\\"https://www.tyndale.com/p/@isbnNumber\\\" target=\\\"_blank\\\" class=\\\"tyfb_prd-content__detail\\\">Product Details</a>\\n                        <a href=\\\"javascript:void(0)\\\">Buy Now</a>\\n                        <select class=\\\"tyfb_prd-content__selectpicker\\\" onchange=\\\"if (this.value) window.location.href=this.value\\\">\\n                            <option>Choose A Retailer</option>\\n                            @purchaseOptions\\n                        </select>\\n                    </div>\\n                </div>\";\r\n            isbnNumbers.forEach(function (x) {\r\n                if (arRawProducts[x] != null) {\r\n                    if (products != null) {\r\n                        products.push(arRawProducts[x].ProductForms[x]);\r\n                    }\r\n                    else {\r\n                        products = [arRawProducts[x].ProductForms[x]];\r\n                    }\r\n                }\r\n            });\r\n            var productsHTML = \"\";\r\n            products.forEach(function (x) {\r\n                var storeList = \"\";\r\n                x.Stores.forEach(function (y) {\r\n                    storeList += \"<option value='\" + y.Url + \"' >\" + y.Label + \"</option>\";\r\n                });\r\n                productsHTML += productTemplate.replace(\"@imagePath\", \"https:\" + x.CoverImage + \"?width=250&quality=60\")\r\n                    .replace(\"@title\", x.Title)\r\n                    .replace(\"@coverType\", \"\")\r\n                    .replace(\"@price\", x.ListPrice)\r\n                    .replace(\"@purchaseOptions\", storeList)\r\n                    .replace(\"@isbnNumber\", x.Isbn);\r\n            });\r\n            var noResultDiv = document.getElementById('noResultDiv');\r\n            var suggestedDiv = document.getElementById('suggestedDiv');\r\n            if (showSuggestionsDiv) {\r\n                noResultDiv.style.display = \"block\";\r\n                suggestedDiv.style.display = \"block\";\r\n            }\r\n            else {\r\n                noResultDiv.style.display = \"none\";\r\n                suggestedDiv.style.display = \"none\";\r\n            }\r\n            if (_this.checkShowAll) {\r\n                var newSearchBtn = document.getElementById(\"newSearchBtn\");\r\n                newSearchBtn.style.display = 'inline-block';\r\n            }\r\n            var currentSelections = document.getElementById('currentSelections');\r\n            currentSelections.style.pointerEvents = \"all\";\r\n            var resultDiv = document.getElementById('resultDiv');\r\n            resultDiv.style.display = \"block\";\r\n            var productDiv = document.getElementById('productDiv');\r\n            productDiv.style.display = \"flex\";\r\n            productDiv.innerHTML = productsHTML;\r\n        })\r\n            .catch(function (error) {\r\n            console.log('Request failed', error);\r\n            var currentSelections = document.getElementById('currentSelections');\r\n            currentSelections.style.pointerEvents = \"all\";\r\n        });\r\n        console.log('after api call');\r\n    };\r\n    Main.prototype.ShowAll = function () {\r\n        var _this = this;\r\n        var newSearchBtn = document.getElementById(\"newSearchBtn\");\r\n        newSearchBtn.addEventListener(\"click\", function (e) { return _this.newSearch(); });\r\n        this.checkShowAll = true;\r\n        this.showHideDivForShowAll(\"none\");\r\n        var headingShowAll = document.getElementById('headingShowAll');\r\n        headingShowAll.style.display = \"block\";\r\n        var arMapping = mappingData.mapping;\r\n        this.callAPI(arMapping.map(function (x) { return x.ISBN; }), false);\r\n        this.data.map(function (x) { return x.answers.map(function (y) { return y.isSelected = false; }); });\r\n    };\r\n    Main.prototype.showHideDivForShowAll = function (val) {\r\n        var questionDiv = document.getElementById('questionDiv');\r\n        questionDiv.style.display = val;\r\n        var mainHeading = document.getElementById('mainHeading');\r\n        mainHeading.style.display = val;\r\n        var headerCurrentSelection = document.getElementById('headerCurrentSelection');\r\n        headerCurrentSelection.style.display = val;\r\n        var currentSelections = document.getElementById('currentSelections');\r\n        currentSelections.style.display = val;\r\n        var noResultDiv = document.getElementById('noResultDiv');\r\n        noResultDiv.style.display = val;\r\n        var suggestedDiv = document.getElementById('suggestedDiv');\r\n        suggestedDiv.style.display = val;\r\n        var productDiv = document.getElementById('productDiv');\r\n        productDiv.innerHTML = \"\";\r\n    };\r\n    Main.prototype.newSearch = function () {\r\n        this.InitialLoad();\r\n    };\r\n    Main.prototype.linkHintData = function () {\r\n        var _this = this;\r\n        var acc = document.getElementsByClassName(\"tyfb_tooltip\");\r\n        for (var i = 0; i < acc.length; i++) {\r\n            acc[i].addEventListener(\"click\", function (e) { return _this.toolTipText(e); });\r\n        }\r\n    };\r\n    Main.prototype.toolTipText = function (ctrl) {\r\n        debugger;\r\n        var acc = document.getElementsByClassName(\"tyfb_tooltip\");\r\n        var panel = document.getElementsByClassName('tyfb-panel');\r\n        var helpBtn = ctrl.srcElement.classList.contains(\"tyfb_tooltip\") ? ctrl.srcElement : ctrl.srcElement.parentElement;\r\n        var setClasses = !helpBtn.classList.contains('active');\r\n        this.setClass(acc, 'active', 'remove');\r\n        this.setClass(panel, 'show', 'remove');\r\n        if (setClasses) {\r\n            helpBtn.classList.toggle(\"active\");\r\n            helpBtn.nextElementSibling.classList.toggle(\"show\");\r\n        }\r\n    };\r\n    Main.prototype.setClass = function (els, className, fnName) {\r\n        for (var i = 0; i < els.length; i++) {\r\n            els[i].classList[fnName](className);\r\n        }\r\n    };\r\n    return Main;\r\n}());\r\nexports.Main = Main;\r\nvar opr = new Main();\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvbWFpbi50cy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9tYWluLnRzPzc5NGYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XHJcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xyXG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcclxuICAgIHZhciByZXN1bHQgPSB7fTtcclxuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSByZXN1bHRba10gPSBtb2Rba107XHJcbiAgICByZXN1bHRbXCJkZWZhdWx0XCJdID0gbW9kO1xyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgUW5zID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuL21ldGFkYXRhL3F1ZXN0aW9ucy5qc29uXCIpKTtcclxudmFyIG1hcHBpbmdEYXRhID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuL21ldGFkYXRhL21hcHBpbmcuanNvblwiKSk7XHJcbnJlcXVpcmUoXCJ0cy1wb2x5ZmlsbFwiKTtcclxucmVxdWlyZShcIndoYXR3Zy1mZXRjaFwiKTtcclxudmFyIE1haW4gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBNYWluKCkge1xyXG4gICAgICAgIHRoaXMuaW5kZXhHbG9iYWwgPSAwO1xyXG4gICAgICAgIHRoaXMuY2hlY2tTaG93QWxsID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5kYXRhID0gUW5zLmVsZW1lbnRzO1xyXG4gICAgICAgIC8vI3JlZ2lvbiBTdGF0aWMgSFRNTCBRdWVzdGlvbiBQYWdlXHJcbiAgICAgICAgdGhpcy50ZW1wbGF0ZSA9IFwiXFxuICAgIDxkaXYgY2xhc3M9XFxcInR5ZmJfaGVhZGluZ1xcXCI+UXVlc3Rpb24gQGluZGV4IG9mIEB0b3RhbFF1ZXN0aW9uczwvZGl2PlxcbiAgICA8ZGl2IGNsYXNzPVxcXCJ0eWZiX3F1ZXNcXFwiPkBpbmRleC4gQHF1ZXN0aW9uPC9kaXY+XFxuICAgIDxkaXYgY2xhc3M9XFxcInR5ZmJfb3B0XFxcIj5cXG4gICAgICAgIEBvcHRpb25zXFxuICAgIDwvZGl2PlxcbiAgICA8YnV0dG9uIGlkPVxcXCJidG5Db250aW51ZVxcXCIgdHlwZT1cXFwiYnV0dG9uXFxcIiBjbGFzcz1cXFwidHlmYl9idG5cXFwiIG9uY2xpY2s9XFxcImNsaWNrXFxcIj5Db250aW51ZTwvYnV0dG9uPlwiO1xyXG4gICAgICAgIHRoaXMub3B0aW9uSFRNTCA9IFwiPGRpdiBjbGFzcz1cXFwidHlmYl9vcHRpb25cXFwiPlxcbiAgICA8aW5wdXQgY2xhc3M9XFxcImlucC1jYnhcXFwiIGlkPVxcXCJvcHRpb24tQG9wdGlvbkluZGV4XFxcIiBuYW1lPVxcXCJAbmFtZVxcXCIgdHlwZT1cXFwiQHR5cGVcXFwiIHN0eWxlPVxcXCJkaXNwbGF5OiBub25lO1xcXCI+XFxuICAgIDxsYWJlbCBjbGFzcz1cXFwiY2J4XFxcIiBmb3I9XFxcIm9wdGlvbi1Ab3B0aW9uSW5kZXhcXFwiPlxcbiAgICAgICAgPHNwYW4gY2xhc3M9XFxcInR5ZmJfY2hrXFxcIj5cXG4gICAgICAgICAgICA8c3ZnIHdpZHRoPVxcXCIxNHB4XFxcIiBoZWlnaHQ9XFxcIjEycHhcXFwiIHZpZXdCb3g9XFxcIjAgMCAxNCAxMlxcXCI+XFxuICAgICAgICAgICAgICAgIDxwb2x5bGluZSBwb2ludHM9XFxcIjEuNSA2IDQuNSA5IDEwLjUgMVxcXCI+PC9wb2x5bGluZT5cXG4gICAgICAgICAgICA8L3N2Zz5cXG4gICAgICAgIDwvc3Bhbj5cXG4gICAgICAgIDxzcGFuIGNsYXNzPVxcXCJjaGstb3B0aW9uc1xcXCI+QG9wdGlvblZhbHVlXFxuICAgICAgICAgICAgXFxuICAgICAgICAgICAgPC9zcGFuPlxcbiAgICA8L3NwYW4+XFxuICAgIDwvbGFiZWw+XFxuICAgIDxzcGFuIGNsYXNzPVxcXCJ0eWZiX3Rvb2x0aXBcXFwiPjxpPj88L2k+PC9zcGFuPlxcbiAgICA8ZGl2IGNsYXNzPVxcXCJ0eWZiLXBhbmVsXFxcIj5AdG9vbHRpcFRleHQ8L2Rpdj5cXG4gICAgPC9kaXY+XCI7XHJcbiAgICAgICAgdGhpcy5yYWRpb09wdGlvbkhUTUwgPSBcIjxkaXYgY2xhc3M9XFxcInR5ZmJfb3B0aW9uXFxcIj5cXG4gICAgICAgIDxsYWJlbCBmb3I9XFxcIm9wdGlvbi1Ab3B0aW9uSW5kZXhcXFwiIGNsYXNzPVxcXCJyYWRpb1xcXCI+XFxuICAgICAgICAgICAgPGlucHV0IHR5cGU9XFxcInJhZGlvXFxcIiBuYW1lPVxcXCJAbmFtZVxcXCIgaWQ9XFxcIm9wdGlvbi1Ab3B0aW9uSW5kZXhcXFwiIGNsYXNzPVxcXCJoaWRkZW5cXFwiIC8+XFxuICAgICAgICAgICAgPHNwYW4gY2xhc3M9XFxcImxhYmVsXFxcIj48L3NwYW4+PHNwYW4gY2xhc3M9XFxcInJhZGlvLXR4dFxcXCI+QG9wdGlvblZhbHVlPC9zcGFuPlxcbiAgICAgICAgPC9sYWJlbD5cXG4gICAgPC9kaXY+XCI7XHJcbiAgICAgICAgLy8jZW5kcmVnaW9uXHJcbiAgICAgICAgLy8jcmVnaW9uIFN0YXRpYyBSZXN1bHQgUGFnZSBIVE1MXHJcbiAgICAgICAgdGhpcy5jdXJyZW50U2VsZWN0aW9uVGVtcGxhdGUgPSBcIjxkaXYgY2xhc3M9XFxcInR5ZmJfZmlsdGVyLWNvbFxcXCI+XFxuICAgIDxzdHJvbmc+QHF1ZXN0aW9uS2V5d29yZDwvc3Ryb25nPlxcbiAgICBAc2VsZWN0aW9uT3B0aW9uc1xcbiAgICA8L2Rpdj5cIjtcclxuICAgICAgICB0aGlzLmN1cnJlbnRTZWxlY3Rpb25PcHRpb250ZW1wbGF0ZSA9IFwiPHNwYW4gY2xhc3M9XFxcInR5ZmJfb3B0aW9uIHR5ZmJfb3B0aW9uLS1pbmxpbmVcXFwiPlxcbiAgICA8aW5wdXQgY2xhc3M9XFxcImlucC1jYnhcXFwiIGlkPVxcXCJyZXN1bHRPcHRpb24tQGluZGV4XFxcIiB0eXBlPVxcXCJAdHlwZVxcXCIgbmFtZT1cXFwiQG5hbWVcXFwiIEBjaGVja2VkIHN0eWxlPVxcXCJkaXNwbGF5OiBub25lO1xcXCI+XFxuICAgIDxsYWJlbCBjbGFzcz1cXFwiY2J4XFxcIiBmb3I9XFxcInJlc3VsdE9wdGlvbi1AaW5kZXhcXFwiPlxcbiAgICAgICAgPHNwYW4gY2xhc3M9XFxcInR5ZmJfY2hrXFxcIj5cXG4gICAgICAgICAgICA8c3ZnIHdpZHRoPVxcXCIxNHB4XFxcIiBoZWlnaHQ9XFxcIjEycHhcXFwiIHZpZXdCb3g9XFxcIjAgMCAxNCAxMlxcXCI+XFxuICAgICAgICAgICAgICAgIDxwb2x5bGluZSBwb2ludHM9XFxcIjEuNSA2IDQuNSA5IDEwLjUgMVxcXCI+PC9wb2x5bGluZT5cXG4gICAgICAgICAgICA8L3N2Zz5cXG4gICAgICAgIDwvc3Bhbj5cXG4gICAgICAgIDxzcGFuIGNsYXNzPVxcXCJjaGstb3B0aW9uc1xcXCI+QGtleXdvcmQ8L3NwYW4+XFxuICAgIDwvbGFiZWw+XFxuPC9zcGFuPlwiO1xyXG4gICAgICAgIHRoaXMuY3VycmVudFNlbGVjdGlvblJhZGlvT3B0aW9udGVtcGxhdGUgPSBcIjxzcGFuIGNsYXNzPVxcXCJ0eWZiX29wdGlvbiB0eWZiX29wdGlvbi0taW5saW5lXFxcIj5cXG48bGFiZWwgZm9yPVxcXCJyZXN1bHRPcHRpb24tQGluZGV4XFxcIiBjbGFzcz1cXFwicmFkaW9cXFwiPlxcbjxpbnB1dCB0eXBlPVxcXCJyYWRpb1xcXCIgbmFtZT1cXFwiQG5hbWVcXFwiIGlkPVxcXCJyZXN1bHRPcHRpb24tQGluZGV4XFxcIiBjbGFzcz1cXFwiaGlkZGVuXFxcIiBAY2hlY2tlZC8+XFxuPHNwYW4gY2xhc3M9XFxcImxhYmVsXFxcIj48L3NwYW4+PHNwYW4gY2xhc3M9XFxcInJhZGlvLXR4dFxcXCI+QGtleXdvcmQ8L3NwYW4+XFxuPC9sYWJlbD5cXG48L3NwYW4+XCI7XHJcbiAgICAgICAgdGhpcy5Jbml0aWFsTG9hZCgpO1xyXG4gICAgfVxyXG4gICAgTWFpbi5wcm90b3R5cGUuSW5pdGlhbExvYWQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB0aGlzLmluZGV4R2xvYmFsID0gMDtcclxuICAgICAgICB0aGlzLmNoZWNrU2hvd0FsbCA9IGZhbHNlO1xyXG4gICAgICAgIC8vIGNvbnN0IG5vUmVzdWx0RGl2OiBIVE1MRWxlbWVudCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdub1Jlc3VsdERpdicpO1xyXG4gICAgICAgIC8vIG5vUmVzdWx0RGl2LnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcclxuICAgICAgICB2YXIgcHJvZHVjdERpdiA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdwcm9kdWN0RGl2Jyk7XHJcbiAgICAgICAgcHJvZHVjdERpdi5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XHJcbiAgICAgICAgcHJvZHVjdERpdi5pbm5lckhUTUwgPSBcIlwiO1xyXG4gICAgICAgIC8vIGNvbnN0IHN1Z2dlc3RlZERpdjogSFRNTEVsZW1lbnQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnc3VnZ2VzdGVkRGl2Jyk7XHJcbiAgICAgICAgLy8gc3VnZ2VzdGVkRGl2LnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcclxuICAgICAgICB2YXIgaGVhZGluZ1Nob3dBbGwgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnaGVhZGluZ1Nob3dBbGwnKTtcclxuICAgICAgICBoZWFkaW5nU2hvd0FsbC5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XHJcbiAgICAgICAgdmFyIG5ld1NlYXJjaEJ0biA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwibmV3U2VhcmNoQnRuXCIpO1xyXG4gICAgICAgIG5ld1NlYXJjaEJ0bi5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xyXG4gICAgICAgIHZhciBtYWluSGVhZGluZyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdtYWluSGVhZGluZycpO1xyXG4gICAgICAgIG1haW5IZWFkaW5nLnN0eWxlLmRpc3BsYXkgPSBcImJsb2NrXCI7XHJcbiAgICAgICAgdmFyIGVsID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3F1ZXN0aW9uRGl2Jyk7XHJcbiAgICAgICAgZWwuc3R5bGUuZGlzcGxheSA9IFwiYmxvY2tcIjtcclxuICAgICAgICBlbC5pbm5lckhUTUwgPSB0aGlzLmdldFF1ZXN0aW9uKDApO1xyXG4gICAgICAgIHZhciByZXN1bHREaXYgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgncmVzdWx0RGl2Jyk7XHJcbiAgICAgICAgcmVzdWx0RGl2LnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcclxuICAgICAgICAvLyBjb25zdCBoZWFkZXJDdXJyZW50U2VsZWN0aW9uOiBIVE1MRWxlbWVudCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdoZWFkZXJDdXJyZW50U2VsZWN0aW9uJyk7XHJcbiAgICAgICAgLy8gaGVhZGVyQ3VycmVudFNlbGVjdGlvbi5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XHJcbiAgICAgICAgLy8gY29uc3QgY3VycmVudFNlbGVjdGlvbnM6IEhUTUxFbGVtZW50ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2N1cnJlbnRTZWxlY3Rpb25zJyk7XHJcbiAgICAgICAgLy8gY3VycmVudFNlbGVjdGlvbnMuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xyXG4gICAgICAgIHZhciBzaG93QWxsQnRuID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJzaG93QWxsYnRuXCIpO1xyXG4gICAgICAgIHNob3dBbGxCdG4uYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIGZ1bmN0aW9uIChlKSB7IHJldHVybiBfdGhpcy5TaG93QWxsKCk7IH0pO1xyXG4gICAgICAgIHZhciBidG4gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImJ0bkNvbnRpbnVlXCIpO1xyXG4gICAgICAgIGJ0bi5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgZnVuY3Rpb24gKGUpIHsgcmV0dXJuIF90aGlzLmJ0bkNsaWNrKCk7IH0pO1xyXG4gICAgICAgIHRoaXMubGlua0hpbnREYXRhKCk7XHJcbiAgICB9O1xyXG4gICAgTWFpbi5wcm90b3R5cGUuYnRuQ2xpY2sgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICAvL0dldCBhbGwgdGhlIG9wdGlvbnMgb2YgY3VycmVudCBxdWVzdGlvbnMgYW5kIGNoZWNrIHdoaWNoIG9uZSBhcmUgc2VsZWN0ZWRcclxuICAgICAgICAvLyNyZWdpb25cclxuICAgICAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgdGhpcy5kYXRhW3RoaXMuaW5kZXhHbG9iYWxdLmFuc3dlcnMubGVuZ3RoOyBpbmRleCsrKSB7XHJcbiAgICAgICAgICAgIHZhciBvcHRpb24gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcIm9wdGlvbi1cIiArIGluZGV4ICsgXCJcIik7XHJcbiAgICAgICAgICAgIGlmIChvcHRpb24uY2hlY2tlZCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kYXRhW3RoaXMuaW5kZXhHbG9iYWxdLmFuc3dlcnNbaW5kZXhdLmlzU2VsZWN0ZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBlbCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdxdWVzdGlvbkRpdicpO1xyXG4gICAgICAgIHZhciBhckxlbmd0aCA9IE9iamVjdC5rZXlzKHRoaXMuZGF0YSkubGVuZ3RoO1xyXG4gICAgICAgIHRoaXMuaW5kZXhHbG9iYWwgPSB0aGlzLmluZGV4R2xvYmFsICsgMTtcclxuICAgICAgICAvL0JlbG93LCB3ZSBhcmUgY2hlY2tpbmcsIGlmIGl0IGlzIHRoZSBsYXN0IHF1ZXN0aW9uIHRoZW4gc2hvdyByZXN1bHQgcGFnZS4gb3RoZXJ3aXNlIHNob3cgbmV4dCBxdWVzdGlvblxyXG4gICAgICAgIGlmICh0aGlzLmluZGV4R2xvYmFsIDwgYXJMZW5ndGgpIHtcclxuICAgICAgICAgICAgZWwuaW5uZXJIVE1MID0gdGhpcy5nZXRRdWVzdGlvbih0aGlzLmluZGV4R2xvYmFsKTtcclxuICAgICAgICAgICAgdmFyIGJ0biA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiYnRuQ29udGludWVcIik7XHJcbiAgICAgICAgICAgIGJ0bi5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgZnVuY3Rpb24gKGUpIHsgcmV0dXJuIF90aGlzLmJ0bkNsaWNrKCk7IH0pO1xyXG4gICAgICAgICAgICB0aGlzLmxpbmtIaW50RGF0YSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5zaG93UmVzdWx0UGFnZSgpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBNYWluLnByb3RvdHlwZS5nZXRRdWVzdGlvbiA9IGZ1bmN0aW9uIChpbmRleExvY2FsKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB2YXIgcXVlc3Rpb25EYXRhID0gdGhpcy5kYXRhW2luZGV4TG9jYWxdO1xyXG4gICAgICAgIHZhciB0ZW1wbGF0ZURhdGEgPSB0aGlzLnRlbXBsYXRlLnJlcGxhY2UoXCJAcXVlc3Rpb25cIiwgcXVlc3Rpb25EYXRhLnRpdGxlKVxyXG4gICAgICAgICAgICAucmVwbGFjZShcIkBpbmRleFwiLCAoaW5kZXhMb2NhbCArIDEpLnRvU3RyaW5nKCkpXHJcbiAgICAgICAgICAgIC5yZXBsYWNlKFwiQGluZGV4XCIsIChpbmRleExvY2FsICsgMSkudG9TdHJpbmcoKSlcclxuICAgICAgICAgICAgLnJlcGxhY2UoXCJAdG90YWxRdWVzdGlvbnNcIiwgdGhpcy5kYXRhLmxlbmd0aC50b1N0cmluZygpKTtcclxuICAgICAgICB2YXIgb3B0aW9uSW5kZXggPSAwO1xyXG4gICAgICAgIHZhciBvcHRpb25zV2l0aEhUTUwgPSBcIlwiO1xyXG4gICAgICAgIGlmIChxdWVzdGlvbkRhdGEuYW5zd2VyVHlwZSA9PSAxKSB7XHJcbiAgICAgICAgICAgIC8vRm9yIENoZWNrQm94XHJcbiAgICAgICAgICAgIHF1ZXN0aW9uRGF0YS5hbnN3ZXJzLmZvckVhY2goZnVuY3Rpb24gKHgpIHtcclxuICAgICAgICAgICAgICAgIG9wdGlvbnNXaXRoSFRNTCArPSBfdGhpcy5vcHRpb25IVE1MLnJlcGxhY2UoXCJAdHlwZVwiLCBcImNoZWNrYm94XCIpXHJcbiAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoXCJAb3B0aW9uSW5kZXhcIiwgb3B0aW9uSW5kZXgudG9TdHJpbmcoKSlcclxuICAgICAgICAgICAgICAgICAgICAucmVwbGFjZShcIkBvcHRpb25JbmRleFwiLCBvcHRpb25JbmRleC50b1N0cmluZygpKVxyXG4gICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKFwiQG9wdGlvblZhbHVlXCIsIHgubGluZUl0ZW0pXHJcbiAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoXCJAbmFtZVwiLCBcImNoa0JveFF1ZXN0aW9uXCIpXHJcbiAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoXCJAdG9vbHRpcFRleHRcIiwgeC50b29sVGlwVGV4dCk7XHJcbiAgICAgICAgICAgICAgICBvcHRpb25JbmRleCsrO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAocXVlc3Rpb25EYXRhLmFuc3dlclR5cGUgPT0gMikge1xyXG4gICAgICAgICAgICAvL0ZvciBSYWRpb0J1dHRvblxyXG4gICAgICAgICAgICBxdWVzdGlvbkRhdGEuYW5zd2Vycy5mb3JFYWNoKGZ1bmN0aW9uICh4KSB7XHJcbiAgICAgICAgICAgICAgICBvcHRpb25zV2l0aEhUTUwgKz0gX3RoaXMucmFkaW9PcHRpb25IVE1MLnJlcGxhY2UoXCJAdHlwZVwiLCBcInJhZGlvXCIpXHJcbiAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoXCJAb3B0aW9uSW5kZXhcIiwgb3B0aW9uSW5kZXgudG9TdHJpbmcoKSlcclxuICAgICAgICAgICAgICAgICAgICAucmVwbGFjZShcIkBvcHRpb25JbmRleFwiLCBvcHRpb25JbmRleC50b1N0cmluZygpKVxyXG4gICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKFwiQG9wdGlvblZhbHVlXCIsIHgubGluZUl0ZW0pXHJcbiAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoXCJAbmFtZVwiLCBcInJkb0J0blF1ZXN0aW9uXCIpO1xyXG4gICAgICAgICAgICAgICAgb3B0aW9uSW5kZXgrKztcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRlbXBsYXRlRGF0YSA9IHRlbXBsYXRlRGF0YS5yZXBsYWNlKFwiQG9wdGlvbnNcIiwgb3B0aW9uc1dpdGhIVE1MKTtcclxuICAgICAgICByZXR1cm4gdGVtcGxhdGVEYXRhO1xyXG4gICAgfTtcclxuICAgIE1haW4ucHJvdG90eXBlLnNob3dSZXN1bHRQYWdlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBwcm9kdWN0RGl2ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3Byb2R1Y3REaXYnKTtcclxuICAgICAgICBwcm9kdWN0RGl2LmlubmVySFRNTCA9IFwiXCI7XHJcbiAgICAgICAgdGhpcy5zaG93Q3VycmVudFNlbGVjdGlvbnMoKTtcclxuICAgICAgICB0aGlzLmZpbHRlckRhdGEoKTtcclxuICAgIH07XHJcbiAgICBNYWluLnByb3RvdHlwZS5zaG93Q3VycmVudFNlbGVjdGlvbnMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB2YXIgcmVzdWx0RGl2ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3Jlc3VsdERpdicpO1xyXG4gICAgICAgIHJlc3VsdERpdi5zdHlsZS5kaXNwbGF5ID0gXCJibG9ja1wiO1xyXG4gICAgICAgIHZhciBxdWVzdGlvbkRpdiA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdxdWVzdGlvbkRpdicpO1xyXG4gICAgICAgIHF1ZXN0aW9uRGl2LnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcclxuICAgICAgICB2YXIgY3VycmVudFNlbGVjdGlvbnNEaXYgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnY3VycmVudFNlbGVjdGlvbnMnKTtcclxuICAgICAgICBjdXJyZW50U2VsZWN0aW9uc0Rpdi5zdHlsZS5kaXNwbGF5ID0gXCJibG9ja1wiO1xyXG4gICAgICAgIHZhciBoZWFkZXJDdXJyZW50U2VsZWN0aW9uID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2hlYWRlckN1cnJlbnRTZWxlY3Rpb24nKTtcclxuICAgICAgICBoZWFkZXJDdXJyZW50U2VsZWN0aW9uLnN0eWxlLmRpc3BsYXkgPSBcImJsb2NrXCI7XHJcbiAgICAgICAgLy8jcmVnaW9uIENyZWF0ZSBjdXJyZW50IHNlbGVjdGlvbnMgb3B0aW9ucyBvbiByZXN1bHQgcGFnZVxyXG4gICAgICAgIHZhciBhckxlbmd0aCA9IE9iamVjdC5rZXlzKHRoaXMuZGF0YSkubGVuZ3RoO1xyXG4gICAgICAgIHZhciB0ZW1wbGF0ZSA9IFwiXCI7XHJcbiAgICAgICAgdmFyIF9sb29wXzEgPSBmdW5jdGlvbiAoaW5kZXgpIHtcclxuICAgICAgICAgICAgcXVlc3Rpb25EYXRhID0gdGhpc18xLmRhdGFbaW5kZXhdO1xyXG4gICAgICAgICAgICBvcHRpb25zSFRNTCA9IFwiXCI7XHJcbiAgICAgICAgICAgIG9wdGlvbkluZGV4ID0gMDtcclxuICAgICAgICAgICAgcXVlc3Rpb25EYXRhLmFuc3dlcnMuZm9yRWFjaChmdW5jdGlvbiAoeCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHF1ZXN0aW9uRGF0YS5hbnN3ZXJUeXBlLnRvU3RyaW5nKCkgPT0gXCIxXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICBvcHRpb25zSFRNTCArPSBfdGhpcy5jdXJyZW50U2VsZWN0aW9uT3B0aW9udGVtcGxhdGUucmVwbGFjZShcIkBpbmRleFwiLCBpbmRleC50b1N0cmluZygpICsgXCItXCIgKyBvcHRpb25JbmRleC50b1N0cmluZygpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZShcIkBpbmRleFwiLCBpbmRleC50b1N0cmluZygpICsgXCItXCIgKyBvcHRpb25JbmRleC50b1N0cmluZygpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZShcIkBuYW1lXCIsIGluZGV4LnRvU3RyaW5nKCkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKFwiQHR5cGVcIiwgXCJjaGVja2JveFwiKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZShcIkBjaGVja2VkXCIsIHguaXNTZWxlY3RlZCA/IFwiY2hlY2tlZFwiIDogXCJcIilcclxuICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoXCJAa2V5d29yZFwiLCB4LmtleXdvcmQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9uc0hUTUwgKz0gX3RoaXMuY3VycmVudFNlbGVjdGlvblJhZGlvT3B0aW9udGVtcGxhdGUucmVwbGFjZShcIkBpbmRleFwiLCBpbmRleC50b1N0cmluZygpICsgXCItXCIgKyBvcHRpb25JbmRleC50b1N0cmluZygpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZShcIkBpbmRleFwiLCBpbmRleC50b1N0cmluZygpICsgXCItXCIgKyBvcHRpb25JbmRleC50b1N0cmluZygpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZShcIkBuYW1lXCIsIGluZGV4LnRvU3RyaW5nKCkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKFwiQHR5cGVcIiwgXCJyYWRpb1wiKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZShcIkBjaGVja2VkXCIsIHguaXNTZWxlY3RlZCA/IFwiY2hlY2tlZFwiIDogXCJcIilcclxuICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoXCJAa2V5d29yZFwiLCB4LmtleXdvcmQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgb3B0aW9uSW5kZXgrKztcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHRlbXBsYXRlICs9IHRoaXNfMS5jdXJyZW50U2VsZWN0aW9uVGVtcGxhdGUucmVwbGFjZShcIkBxdWVzdGlvbktleXdvcmRcIiwgcXVlc3Rpb25EYXRhLmtleXdvcmQpXHJcbiAgICAgICAgICAgICAgICAucmVwbGFjZShcIkBzZWxlY3Rpb25PcHRpb25zXCIsIG9wdGlvbnNIVE1MKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHZhciB0aGlzXzEgPSB0aGlzLCBxdWVzdGlvbkRhdGEsIG9wdGlvbnNIVE1MLCBvcHRpb25JbmRleDtcclxuICAgICAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgYXJMZW5ndGg7IGluZGV4KyspIHtcclxuICAgICAgICAgICAgX2xvb3BfMShpbmRleCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGN1cnJlbnRTZWxlY3Rpb25zRGl2LmlubmVySFRNTCA9IHRlbXBsYXRlO1xyXG4gICAgICAgIHZhciBjaGVja2JveGVzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnKltpZF49XCJyZXN1bHRPcHRpb25cIl0nKTtcclxuICAgICAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgY2hlY2tib3hlcy5sZW5ndGg7IGluZGV4KyspIHtcclxuICAgICAgICAgICAgdmFyIGVsZW1lbnQgPSBjaGVja2JveGVzW2luZGV4XTtcclxuICAgICAgICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgZnVuY3Rpb24gKGUpIHsgcmV0dXJuIF90aGlzLmZpbHRlckRhdGEoKTsgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vI2VuZHJlZ2lvblxyXG4gICAgfTtcclxuICAgIE1haW4ucHJvdG90eXBlLmZpbHRlckRhdGEgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgLy9PbiB0aGUgY2hhbmdlIG9mIGNoZWNrYm94ZXMgb24gcmVzdWx0IHBhZ2UsIHRoaXMgbWV0aG9kIHdpbGwgYmUgY2FsbGVkIGFuZCB3ZSBhcmUgZ2V0dGluZyBhbGwgdGhlIGNoZWNrZWQgaW5wdXQgZWxlbWVudHNcclxuICAgICAgICB2YXIgY2hlY2tib3hlcyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJypbaWRePVwicmVzdWx0T3B0aW9uXCJdJyk7XHJcbiAgICAgICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IGNoZWNrYm94ZXMubGVuZ3RoOyBpbmRleCsrKSB7XHJcbiAgICAgICAgICAgIGlmIChjaGVja2JveGVzW2luZGV4XS5jaGVja2VkKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcXVlc3Rpb25JbmRleCA9IGNoZWNrYm94ZXNbaW5kZXhdLmlkLnNwbGl0KCctJylbMV07XHJcbiAgICAgICAgICAgICAgICB2YXIgb3B0aW9uSW5kZXggPSBjaGVja2JveGVzW2luZGV4XS5pZC5zcGxpdCgnLScpWzJdO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kYXRhW3F1ZXN0aW9uSW5kZXhdLmFuc3dlcnNbb3B0aW9uSW5kZXhdLmlzU2VsZWN0ZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdmFyIHF1ZXN0aW9uSW5kZXggPSBjaGVja2JveGVzW2luZGV4XS5pZC5zcGxpdCgnLScpWzFdO1xyXG4gICAgICAgICAgICAgICAgdmFyIG9wdGlvbkluZGV4ID0gY2hlY2tib3hlc1tpbmRleF0uaWQuc3BsaXQoJy0nKVsyXTtcclxuICAgICAgICAgICAgICAgIHRoaXMuZGF0YVtxdWVzdGlvbkluZGV4XS5hbnN3ZXJzW29wdGlvbkluZGV4XS5pc1NlbGVjdGVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGZvdW5kQm9va3MgPSBbXTtcclxuICAgICAgICB2YXIgcXVlc3Rpb25zO1xyXG4gICAgICAgIHF1ZXN0aW9ucyA9IE9iamVjdC5hc3NpZ24oW10sIHRoaXMuZGF0YSk7XHJcbiAgICAgICAgZm91bmRCb29rcyA9IHRoaXMuc2VhcmNoQWxnb3JpdGhtKHF1ZXN0aW9ucyk7XHJcbiAgICAgICAgdmFyIHN1Z2dlc3RlZEJvb2tzID0gZmFsc2U7XHJcbiAgICAgICAgaWYgKGZvdW5kQm9va3MubGVuZ3RoID09IDApIHtcclxuICAgICAgICAgICAgc3VnZ2VzdGVkQm9va3MgPSB0cnVlO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBub09mUXVlc3Rpb25Ub1NraXAgPSAxOyBub09mUXVlc3Rpb25Ub1NraXAgPCBxdWVzdGlvbnMubGVuZ3RoOyBub09mUXVlc3Rpb25Ub1NraXArKykge1xyXG4gICAgICAgICAgICAgICAgLy9pbmRleCBpcyBsZXZlbCBhcyB3ZWxsIGFzIG5vIG9mIHF1ZXN0aW9ucyB0byBzXHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciByZW1vdmVJbmRleCA9IDA7IHJlbW92ZUluZGV4IDwgcXVlc3Rpb25zLmxlbmd0aDsgcmVtb3ZlSW5kZXgrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB0ZW1wUXVlc3Rpb25zID0gT2JqZWN0LmFzc2lnbihbXSwgcXVlc3Rpb25zKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoKHJlbW92ZUluZGV4ICsgbm9PZlF1ZXN0aW9uVG9Ta2lwIC0gMSkgPj0gcXVlc3Rpb25zLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZW1wUXVlc3Rpb25zLnNwbGljZShyZW1vdmVJbmRleCwgcXVlc3Rpb25zLmxlbmd0aCAtIHJlbW92ZUluZGV4KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGVtcFF1ZXN0aW9ucy5zcGxpY2UoMCwgbm9PZlF1ZXN0aW9uVG9Ta2lwICsgcmVtb3ZlSW5kZXggLSBxdWVzdGlvbnMubGVuZ3RoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRlbXBRdWVzdGlvbnMuc3BsaWNlKHJlbW92ZUluZGV4LCBub09mUXVlc3Rpb25Ub1NraXApO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB2YXIgdGVtcEJvb2tzID0gdGhpcy5zZWFyY2hBbGdvcml0aG0odGVtcFF1ZXN0aW9ucyk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRlbXBCb29rcy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRlbXBCb29rcy5mb3JFYWNoKGZ1bmN0aW9uICh4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZm91bmRCb29rcy5pbmRleE9mKHgpID09IC0xKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvdW5kQm9va3MucHVzaCh4KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGZvdW5kQm9va3MubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChmb3VuZEJvb2tzLmxlbmd0aCA9PSAwKSB7XHJcbiAgICAgICAgICAgIHZhciBhck1hcHBpbmcgPSBtYXBwaW5nRGF0YS5tYXBwaW5nO1xyXG4gICAgICAgICAgICBmb3VuZEJvb2tzID0gYXJNYXBwaW5nLm1hcChmdW5jdGlvbiAoeCkgeyByZXR1cm4geC5JU0JOOyB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGN1cnJlbnRTZWxlY3Rpb25zID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2N1cnJlbnRTZWxlY3Rpb25zJyk7XHJcbiAgICAgICAgY3VycmVudFNlbGVjdGlvbnMuc3R5bGUucG9pbnRlckV2ZW50cyA9IFwibm9uZVwiO1xyXG4gICAgICAgIGNvbnNvbGUubG9nKFwiRm91bmQgYm9va3NcIiwgZm91bmRCb29rcyk7XHJcbiAgICAgICAgdGhpcy5jYWxsQVBJKGZvdW5kQm9va3MsIHN1Z2dlc3RlZEJvb2tzKTtcclxuICAgIH07XHJcbiAgICBNYWluLnByb3RvdHlwZS5zZWFyY2hBbGdvcml0aG0gPSBmdW5jdGlvbiAocXVlc3Rpb25zKSB7XHJcbiAgICAgICAgdmFyIGFyTWFwcGluZyA9IG1hcHBpbmdEYXRhLm1hcHBpbmc7XHJcbiAgICAgICAgdmFyIGZvdW5kQm9va3MgPSBbXTtcclxuICAgICAgICBpZiAoYXJNYXBwaW5nKSB7XHJcbiAgICAgICAgICAgIHZhciBzZWxlY3RlZE9wdGlvbnMgPSB2b2lkIDA7XHJcbiAgICAgICAgICAgIHZhciBpc2JuQXJyYXkgPSBbXTtcclxuICAgICAgICAgICAgYXJNYXBwaW5nLmZvckVhY2goZnVuY3Rpb24gKG1hcHBpbmcpIHtcclxuICAgICAgICAgICAgICAgIHZhciBpc0hpdCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgcXVlc3Rpb25zLmV2ZXJ5KGZ1bmN0aW9uIChxbnMpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYW5zID0gcW5zLmFuc3dlcnMuZmlsdGVyKGZ1bmN0aW9uIChhKSB7IHJldHVybiBhLmlzU2VsZWN0ZWQ7IH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChhbnMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZm91bmRBbnNfMSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhbnMuZXZlcnkoZnVuY3Rpb24gKHopIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtYXBwaW5nW3Fucy5rZXl3b3JkXSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobWFwcGluZ1txbnMua2V5d29yZF0uaW5kZXhPZih6LmtleXdvcmQpID4gLTEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm91bmRBbnNfMSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvdW5kQW5zXzEgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZvdW5kQW5zXzEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzSGl0ID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNIaXQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaXNIaXQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIGlmIChpc0hpdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGZvdW5kQm9va3MucHVzaChtYXBwaW5nLklTQk4pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZvdW5kQm9va3M7XHJcbiAgICB9O1xyXG4gICAgTWFpbi5wcm90b3R5cGUuY2FsbEFQSSA9IGZ1bmN0aW9uIChpc2JuTnVtYmVycywgc2hvd1N1Z2dlc3Rpb25zRGl2KSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICBpZiAoaXNibk51bWJlcnMubGVuZ3RoID09IG51bGwgfHwgaXNibk51bWJlcnMubGVuZ3RoID09IDApIHtcclxuICAgICAgICAgICAgaXNibk51bWJlcnMgPSBtYXBwaW5nRGF0YS5tYXBwaW5nLm1hcChmdW5jdGlvbiAoeCkgeyByZXR1cm4geC5JU0JOOyB9KTtcclxuICAgICAgICAgICAgc2hvd1N1Z2dlc3Rpb25zRGl2ID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHBhcmFtcyA9IHtcclxuICAgICAgICAgICAgXCJzY29wZWlkXCI6IFwiMVwiLFxyXG4gICAgICAgICAgICBcInByb2R1Y3RzXCI6IGlzYm5OdW1iZXJzXHJcbiAgICAgICAgfTtcclxuICAgICAgICB3aW5kb3cuZmV0Y2goXCJodHRwczovL3dzLnR5bmRhbGUuY29tL2FwaS9wcm9kdWN0cy9nZXRcIiwge1xyXG4gICAgICAgICAgICBtZXRob2Q6ICdwb3N0JyxcclxuICAgICAgICAgICAgaGVhZGVyczoge1xyXG4gICAgICAgICAgICAgICAgJ0FjY2VwdCc6ICdhcHBsaWNhdGlvbi9qc29uJyxcclxuICAgICAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXHJcbiAgICAgICAgICAgICAgICAnYXBpLWtleSc6ICc+UW0tdipdTTlucCx1IysnXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIG1vZGU6ICdjb3JzJyxcclxuICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkocGFyYW1zKVxyXG4gICAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKHJlc3BvbnNlKSB7IHJldHVybiByZXNwb25zZS5qc29uKCk7IH0pXHJcbiAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChyZXNwb25zZSkge1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZygnaW4gcmVzcG9uc2UgYXBpIGNhbGwnKTtcclxuICAgICAgICAgICAgdmFyIGFyUmF3UHJvZHVjdHMgPSByZXNwb25zZS5Qcm9kdWN0cztcclxuICAgICAgICAgICAgdmFyIHByb2R1Y3RzO1xyXG4gICAgICAgICAgICB2YXIgcHJvZHVjdFRlbXBsYXRlID0gXCI8ZGl2IGNsYXNzPVxcXCJ0eWZiX2NvbC1zbS0zXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcInR5ZmJfcHJkLWltXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8aW1nIHNyYz1cXFwiQGltYWdlUGF0aFxcXCIgYWx0PVxcXCJQcm9kdWN0XFxcIiB3aWR0aD1cXFwiMjUwXFxcIi8+XFxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcInR5ZmJfcHJkLWNvbnRlbnRcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDxwPkB0aXRsZTwvcD5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cXFwidHlmYl9wcmQtY29udGVudF9fdHlwZVxcXCI+QGNvdmVyVHlwZTwvc3Bhbj5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cXFwidHlmYl9wcmQtY29udGVudF9fcHJpY2VcXFwiPiRAcHJpY2U8L3NwYW4+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPGEgaHJlZj1cXFwiaHR0cHM6Ly93d3cudHluZGFsZS5jb20vcC9AaXNibk51bWJlclxcXCIgdGFyZ2V0PVxcXCJfYmxhbmtcXFwiIGNsYXNzPVxcXCJ0eWZiX3ByZC1jb250ZW50X19kZXRhaWxcXFwiPlByb2R1Y3QgRGV0YWlsczwvYT5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8YSBocmVmPVxcXCJqYXZhc2NyaXB0OnZvaWQoMClcXFwiPkJ1eSBOb3c8L2E+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPHNlbGVjdCBjbGFzcz1cXFwidHlmYl9wcmQtY29udGVudF9fc2VsZWN0cGlja2VyXFxcIiBvbmNoYW5nZT1cXFwiaWYgKHRoaXMudmFsdWUpIHdpbmRvdy5sb2NhdGlvbi5ocmVmPXRoaXMudmFsdWVcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8b3B0aW9uPkNob29zZSBBIFJldGFpbGVyPC9vcHRpb24+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIEBwdXJjaGFzZU9wdGlvbnNcXG4gICAgICAgICAgICAgICAgICAgICAgICA8L3NlbGVjdD5cXG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgICAgICA8L2Rpdj5cIjtcclxuICAgICAgICAgICAgaXNibk51bWJlcnMuZm9yRWFjaChmdW5jdGlvbiAoeCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGFyUmF3UHJvZHVjdHNbeF0gIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChwcm9kdWN0cyAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb2R1Y3RzLnB1c2goYXJSYXdQcm9kdWN0c1t4XS5Qcm9kdWN0Rm9ybXNbeF0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvZHVjdHMgPSBbYXJSYXdQcm9kdWN0c1t4XS5Qcm9kdWN0Rm9ybXNbeF1dO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHZhciBwcm9kdWN0c0hUTUwgPSBcIlwiO1xyXG4gICAgICAgICAgICBwcm9kdWN0cy5mb3JFYWNoKGZ1bmN0aW9uICh4KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgc3RvcmVMaXN0ID0gXCJcIjtcclxuICAgICAgICAgICAgICAgIHguU3RvcmVzLmZvckVhY2goZnVuY3Rpb24gKHkpIHtcclxuICAgICAgICAgICAgICAgICAgICBzdG9yZUxpc3QgKz0gXCI8b3B0aW9uIHZhbHVlPSdcIiArIHkuVXJsICsgXCInID5cIiArIHkuTGFiZWwgKyBcIjwvb3B0aW9uPlwiO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICBwcm9kdWN0c0hUTUwgKz0gcHJvZHVjdFRlbXBsYXRlLnJlcGxhY2UoXCJAaW1hZ2VQYXRoXCIsIFwiaHR0cHM6XCIgKyB4LkNvdmVySW1hZ2UgKyBcIj93aWR0aD0yNTAmcXVhbGl0eT02MFwiKVxyXG4gICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKFwiQHRpdGxlXCIsIHguVGl0bGUpXHJcbiAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoXCJAY292ZXJUeXBlXCIsIFwiXCIpXHJcbiAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoXCJAcHJpY2VcIiwgeC5MaXN0UHJpY2UpXHJcbiAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoXCJAcHVyY2hhc2VPcHRpb25zXCIsIHN0b3JlTGlzdClcclxuICAgICAgICAgICAgICAgICAgICAucmVwbGFjZShcIkBpc2JuTnVtYmVyXCIsIHguSXNibik7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB2YXIgbm9SZXN1bHREaXYgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbm9SZXN1bHREaXYnKTtcclxuICAgICAgICAgICAgdmFyIHN1Z2dlc3RlZERpdiA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdzdWdnZXN0ZWREaXYnKTtcclxuICAgICAgICAgICAgaWYgKHNob3dTdWdnZXN0aW9uc0Rpdikge1xyXG4gICAgICAgICAgICAgICAgbm9SZXN1bHREaXYuc3R5bGUuZGlzcGxheSA9IFwiYmxvY2tcIjtcclxuICAgICAgICAgICAgICAgIHN1Z2dlc3RlZERpdi5zdHlsZS5kaXNwbGF5ID0gXCJibG9ja1wiO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgbm9SZXN1bHREaXYuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xyXG4gICAgICAgICAgICAgICAgc3VnZ2VzdGVkRGl2LnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoX3RoaXMuY2hlY2tTaG93QWxsKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbmV3U2VhcmNoQnRuID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJuZXdTZWFyY2hCdG5cIik7XHJcbiAgICAgICAgICAgICAgICBuZXdTZWFyY2hCdG4uc3R5bGUuZGlzcGxheSA9ICdpbmxpbmUtYmxvY2snO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBjdXJyZW50U2VsZWN0aW9ucyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdjdXJyZW50U2VsZWN0aW9ucycpO1xyXG4gICAgICAgICAgICBjdXJyZW50U2VsZWN0aW9ucy5zdHlsZS5wb2ludGVyRXZlbnRzID0gXCJhbGxcIjtcclxuICAgICAgICAgICAgdmFyIHJlc3VsdERpdiA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdyZXN1bHREaXYnKTtcclxuICAgICAgICAgICAgcmVzdWx0RGl2LnN0eWxlLmRpc3BsYXkgPSBcImJsb2NrXCI7XHJcbiAgICAgICAgICAgIHZhciBwcm9kdWN0RGl2ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3Byb2R1Y3REaXYnKTtcclxuICAgICAgICAgICAgcHJvZHVjdERpdi5zdHlsZS5kaXNwbGF5ID0gXCJmbGV4XCI7XHJcbiAgICAgICAgICAgIHByb2R1Y3REaXYuaW5uZXJIVE1MID0gcHJvZHVjdHNIVE1MO1xyXG4gICAgICAgIH0pXHJcbiAgICAgICAgICAgIC5jYXRjaChmdW5jdGlvbiAoZXJyb3IpIHtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coJ1JlcXVlc3QgZmFpbGVkJywgZXJyb3IpO1xyXG4gICAgICAgICAgICB2YXIgY3VycmVudFNlbGVjdGlvbnMgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnY3VycmVudFNlbGVjdGlvbnMnKTtcclxuICAgICAgICAgICAgY3VycmVudFNlbGVjdGlvbnMuc3R5bGUucG9pbnRlckV2ZW50cyA9IFwiYWxsXCI7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgY29uc29sZS5sb2coJ2FmdGVyIGFwaSBjYWxsJyk7XHJcbiAgICB9O1xyXG4gICAgTWFpbi5wcm90b3R5cGUuU2hvd0FsbCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHZhciBuZXdTZWFyY2hCdG4gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcIm5ld1NlYXJjaEJ0blwiKTtcclxuICAgICAgICBuZXdTZWFyY2hCdG4uYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIGZ1bmN0aW9uIChlKSB7IHJldHVybiBfdGhpcy5uZXdTZWFyY2goKTsgfSk7XHJcbiAgICAgICAgdGhpcy5jaGVja1Nob3dBbGwgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuc2hvd0hpZGVEaXZGb3JTaG93QWxsKFwibm9uZVwiKTtcclxuICAgICAgICB2YXIgaGVhZGluZ1Nob3dBbGwgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnaGVhZGluZ1Nob3dBbGwnKTtcclxuICAgICAgICBoZWFkaW5nU2hvd0FsbC5zdHlsZS5kaXNwbGF5ID0gXCJibG9ja1wiO1xyXG4gICAgICAgIHZhciBhck1hcHBpbmcgPSBtYXBwaW5nRGF0YS5tYXBwaW5nO1xyXG4gICAgICAgIHRoaXMuY2FsbEFQSShhck1hcHBpbmcubWFwKGZ1bmN0aW9uICh4KSB7IHJldHVybiB4LklTQk47IH0pLCBmYWxzZSk7XHJcbiAgICAgICAgdGhpcy5kYXRhLm1hcChmdW5jdGlvbiAoeCkgeyByZXR1cm4geC5hbnN3ZXJzLm1hcChmdW5jdGlvbiAoeSkgeyByZXR1cm4geS5pc1NlbGVjdGVkID0gZmFsc2U7IH0pOyB9KTtcclxuICAgIH07XHJcbiAgICBNYWluLnByb3RvdHlwZS5zaG93SGlkZURpdkZvclNob3dBbGwgPSBmdW5jdGlvbiAodmFsKSB7XHJcbiAgICAgICAgdmFyIHF1ZXN0aW9uRGl2ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3F1ZXN0aW9uRGl2Jyk7XHJcbiAgICAgICAgcXVlc3Rpb25EaXYuc3R5bGUuZGlzcGxheSA9IHZhbDtcclxuICAgICAgICB2YXIgbWFpbkhlYWRpbmcgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbWFpbkhlYWRpbmcnKTtcclxuICAgICAgICBtYWluSGVhZGluZy5zdHlsZS5kaXNwbGF5ID0gdmFsO1xyXG4gICAgICAgIHZhciBoZWFkZXJDdXJyZW50U2VsZWN0aW9uID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2hlYWRlckN1cnJlbnRTZWxlY3Rpb24nKTtcclxuICAgICAgICBoZWFkZXJDdXJyZW50U2VsZWN0aW9uLnN0eWxlLmRpc3BsYXkgPSB2YWw7XHJcbiAgICAgICAgdmFyIGN1cnJlbnRTZWxlY3Rpb25zID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2N1cnJlbnRTZWxlY3Rpb25zJyk7XHJcbiAgICAgICAgY3VycmVudFNlbGVjdGlvbnMuc3R5bGUuZGlzcGxheSA9IHZhbDtcclxuICAgICAgICB2YXIgbm9SZXN1bHREaXYgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbm9SZXN1bHREaXYnKTtcclxuICAgICAgICBub1Jlc3VsdERpdi5zdHlsZS5kaXNwbGF5ID0gdmFsO1xyXG4gICAgICAgIHZhciBzdWdnZXN0ZWREaXYgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnc3VnZ2VzdGVkRGl2Jyk7XHJcbiAgICAgICAgc3VnZ2VzdGVkRGl2LnN0eWxlLmRpc3BsYXkgPSB2YWw7XHJcbiAgICAgICAgdmFyIHByb2R1Y3REaXYgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgncHJvZHVjdERpdicpO1xyXG4gICAgICAgIHByb2R1Y3REaXYuaW5uZXJIVE1MID0gXCJcIjtcclxuICAgIH07XHJcbiAgICBNYWluLnByb3RvdHlwZS5uZXdTZWFyY2ggPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5Jbml0aWFsTG9hZCgpO1xyXG4gICAgfTtcclxuICAgIE1haW4ucHJvdG90eXBlLmxpbmtIaW50RGF0YSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHZhciBhY2MgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKFwidHlmYl90b29sdGlwXCIpO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYWNjLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGFjY1tpXS5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgZnVuY3Rpb24gKGUpIHsgcmV0dXJuIF90aGlzLnRvb2xUaXBUZXh0KGUpOyB9KTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgTWFpbi5wcm90b3R5cGUudG9vbFRpcFRleHQgPSBmdW5jdGlvbiAoY3RybCkge1xyXG4gICAgICAgIGRlYnVnZ2VyO1xyXG4gICAgICAgIHZhciBhY2MgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKFwidHlmYl90b29sdGlwXCIpO1xyXG4gICAgICAgIHZhciBwYW5lbCA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoJ3R5ZmItcGFuZWwnKTtcclxuICAgICAgICB2YXIgaGVscEJ0biA9IGN0cmwuc3JjRWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoXCJ0eWZiX3Rvb2x0aXBcIikgPyBjdHJsLnNyY0VsZW1lbnQgOiBjdHJsLnNyY0VsZW1lbnQucGFyZW50RWxlbWVudDtcclxuICAgICAgICB2YXIgc2V0Q2xhc3NlcyA9ICFoZWxwQnRuLmNsYXNzTGlzdC5jb250YWlucygnYWN0aXZlJyk7XHJcbiAgICAgICAgdGhpcy5zZXRDbGFzcyhhY2MsICdhY3RpdmUnLCAncmVtb3ZlJyk7XHJcbiAgICAgICAgdGhpcy5zZXRDbGFzcyhwYW5lbCwgJ3Nob3cnLCAncmVtb3ZlJyk7XHJcbiAgICAgICAgaWYgKHNldENsYXNzZXMpIHtcclxuICAgICAgICAgICAgaGVscEJ0bi5jbGFzc0xpc3QudG9nZ2xlKFwiYWN0aXZlXCIpO1xyXG4gICAgICAgICAgICBoZWxwQnRuLm5leHRFbGVtZW50U2libGluZy5jbGFzc0xpc3QudG9nZ2xlKFwic2hvd1wiKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgTWFpbi5wcm90b3R5cGUuc2V0Q2xhc3MgPSBmdW5jdGlvbiAoZWxzLCBjbGFzc05hbWUsIGZuTmFtZSkge1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWxzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGVsc1tpXS5jbGFzc0xpc3RbZm5OYW1lXShjbGFzc05hbWUpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICByZXR1cm4gTWFpbjtcclxufSgpKTtcclxuZXhwb3J0cy5NYWluID0gTWFpbjtcclxudmFyIG9wciA9IG5ldyBNYWluKCk7XHJcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/main.ts\n");

/***/ }),

/***/ "./src/metadata/mapping.json":
/*!***********************************!*\
  !*** ./src/metadata/mapping.json ***!
  \***********************************/
/*! exports provided: mapping, default */
/***/ (function(module) {

eval("module.exports = JSON.parse(\"{\\\"mapping\\\":[{\\\"ISBN\\\":\\\"9781414337678\\\",\\\"Translation\\\":[\\\"NLT\\\"],\\\"Content\\\":[\\\"Chrono\\\"],\\\"Journaling & Coloring\\\":[\\\"No\\\"]},{\\\"ISBN\\\":\\\"9781414363318\\\",\\\"Translation\\\":[\\\"NLT\\\"],\\\"Content\\\":[\\\"Chrono\\\"],\\\"Journaling & Coloring\\\":[\\\"No\\\"]},{\\\"ISBN\\\":\\\"9781414314082\\\",\\\"Translation\\\":[\\\"NLT\\\"],\\\"Content\\\":[\\\"Chrono\\\"],\\\"Journaling & Coloring\\\":[\\\"No\\\"]},{\\\"ISBN\\\":\\\"9781496416780\\\",\\\"Translation\\\":[\\\"NLT\\\"],\\\"Content\\\":[\\\"Daily\\\"],\\\"Journaling & Coloring\\\":[\\\"Yes\\\"]},{\\\"ISBN\\\":\\\"9781496416797\\\",\\\"Translation\\\":[\\\"NLT\\\"],\\\"Content\\\":[\\\"Daily\\\"],\\\"Journaling & Coloring\\\":[\\\"Yes\\\"]},{\\\"ISBN\\\":\\\"9781496420176\\\",\\\"Translation\\\":[\\\"NLT\\\"],\\\"Content\\\":[\\\"Chrono\\\"],\\\"Journaling & Coloring\\\":[\\\"Yes\\\"]},{\\\"ISBN\\\":\\\"9781496420183\\\",\\\"Translation\\\":[\\\"NLT\\\"],\\\"Content\\\":[\\\"Chrono\\\"],\\\"Journaling & Coloring\\\":[\\\"Yes\\\"]},{\\\"ISBN\\\":\\\"9781496420152\\\",\\\"Translation\\\":[\\\"NLT\\\"],\\\"Content\\\":[\\\"Daily\\\"],\\\"Journaling & Coloring\\\":[\\\"Yes\\\"]},{\\\"ISBN\\\":\\\"9781496420169\\\",\\\"Translation\\\":[\\\"NLT\\\"],\\\"Content\\\":[\\\"Daily\\\"],\\\"Journaling & Coloring\\\":[\\\"Yes\\\"]},{\\\"ISBN\\\":\\\"9781414314136\\\",\\\"Translation\\\":[\\\"NLT\\\"],\\\"Content\\\":[\\\"Daily\\\"],\\\"Journaling & Coloring\\\":[\\\"No\\\"]},{\\\"ISBN\\\":\\\"9781414312446\\\",\\\"Translation\\\":[\\\"NLT\\\"],\\\"Content\\\":[\\\"Daily\\\"],\\\"Journaling & Coloring\\\":[\\\"No\\\"]},{\\\"ISBN\\\":\\\"9781414338637\\\",\\\"Translation\\\":[\\\"NLT\\\"],\\\"Content\\\":[\\\"Daily\\\"],\\\"Journaling & Coloring\\\":[\\\"No\\\"]},{\\\"ISBN\\\":\\\"9781414302041\\\",\\\"Translation\\\":[\\\"NLT\\\"],\\\"Content\\\":[\\\"Daily\\\"],\\\"Journaling & Coloring\\\":[\\\"No\\\"]},{\\\"ISBN\\\":\\\"9781496443731\\\",\\\"Translation\\\":[\\\"NLT\\\"],\\\"Content\\\":[\\\"Daily\\\"],\\\"Journaling & Coloring\\\":[\\\"No\\\"]},{\\\"ISBN\\\":\\\"9781414359939\\\",\\\"Translation\\\":[\\\"NIV\\\"],\\\"Content\\\":[\\\"Chrono\\\"],\\\"Journaling & Coloring\\\":[\\\"No\\\"]},{\\\"ISBN\\\":\\\"9781414359854\\\",\\\"Translation\\\":[\\\"NIV\\\"],\\\"Content\\\":[\\\"Daily\\\"],\\\"Journaling & Coloring\\\":[\\\"No\\\"]},{\\\"ISBN\\\":\\\"9781414359915\\\",\\\"Translation\\\":[\\\"NIV\\\"],\\\"Content\\\":[\\\"Daily\\\"],\\\"Journaling & Coloring\\\":[\\\"No\\\"]},{\\\"ISBN\\\":\\\"9780842325769\\\",\\\"Translation\\\":[\\\"KJV\\\"],\\\"Content\\\":[\\\"Daily\\\"],\\\"Journaling & Coloring\\\":[\\\"No\\\"]},{\\\"ISBN\\\":\\\"9781414376561\\\",\\\"Translation\\\":[\\\"NKJV\\\"],\\\"Content\\\":[\\\"Daily\\\",\\\"Chrono\\\"],\\\"Journaling & Coloring\\\":[\\\"No\\\"]},{\\\"ISBN\\\":\\\"9781414363264\\\",\\\"Translation\\\":[\\\"NKJV\\\"],\\\"Content\\\":[\\\"Daily\\\"],\\\"Journaling & Coloring\\\":[\\\"No\\\"]}]}\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvbWV0YWRhdGEvbWFwcGluZy5qc29uLmpzIiwic291cmNlcyI6W10sIm1hcHBpbmdzIjoiIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/metadata/mapping.json\n");

/***/ }),

/***/ "./src/metadata/questions.json":
/*!*************************************!*\
  !*** ./src/metadata/questions.json ***!
  \*************************************/
/*! exports provided: elements, default */
/***/ (function(module) {

eval("module.exports = JSON.parse(\"{\\\"elements\\\":[{\\\"title\\\":\\\"What Translation are You Interested In\\\",\\\"keyword\\\":\\\"Translation\\\",\\\"answerType\\\":1,\\\"answers\\\":[{\\\"lineItem\\\":\\\"New Living Translation (NLT)\\\",\\\"isSelected\\\":false,\\\"toolTipText\\\":\\\"The New Living Translation combines the latest biblical scholarship with a clear, dynamic writing style that communicates Gods Word powerfully to all who hear and read it. It renders the message of the original texts of Scripture into clear, contemporary English that was written to be read aloud. With a focus on clarity, The New Living Translation invites readers to go deeper into the biblical text to discover Gods story for their lives and the world.\\\",\\\"keyword\\\":\\\"NLT\\\"},{\\\"lineItem\\\":\\\"New International Versions (NIV)\\\",\\\"isSelected\\\":false,\\\"toolTipText\\\":\\\"The New International Version (NIV) is a completely original translation of the Bible developed by more than one hundred scholars working from the best available Hebrew, Aramaic, and Greek texts. For the 2011 update the Committee on Bible Translation worked with pastors and Bible scholars grappling with the latest discoveries about biblical languages and the biblical world, and using cutting-edge research on English usage.\\\",\\\"keyword\\\":\\\"NIV\\\"},{\\\"lineItem\\\":\\\"King James Version (KJV)\\\",\\\"isSelected\\\":false,\\\"toolTipText\\\":\\\"In 1604, King James I of England authorized that a new translation of the Bible into English be started. It was finished in 1611, just 85 years after the first translation of the New Testament into English appeared (Tyndale, 1526). The Authorized Version, or King James Version, quickly became the standard for English-speaking Protestants. Its flowing language and prose rhythm has had a profound influence on the literature of the past 400 years. \\\",\\\"keyword\\\":\\\"KJV\\\"},{\\\"lineItem\\\":\\\"New King James Version (NKJV)\\\",\\\"isSelected\\\":false,\\\"toolTipText\\\":\\\"Commissioned in 1975 by Thomas Nelson Publishers, 130 respected Bible scholars, church leaders, and lay Christians worked for seven years to create a completely new, modern translation of Scripture, yet one that would retain the purity and stylistic beauty of the original King James. With unyielding faithfulness to the original Greek, Hebrew, and Aramaic texts, the translation applies the most recent research in archaeology, linguistics, and textual studies.\\\",\\\"keyword\\\":\\\"NKJV\\\"}]},{\\\"title\\\":\\\"What sort of reading experience would you like?\\\",\\\"keyword\\\":\\\"Content\\\",\\\"answerType\\\":1,\\\"answers\\\":[{\\\"lineItem\\\":\\\"Daily Variety\\\",\\\"isSelected\\\":false,\\\"toolTipText\\\":\\\"Each days reading contains a portion of the Old Testament, the New Testament, Psalms, and Proverbs.\\\",\\\"keyword\\\":\\\"Daily\\\"},{\\\"lineItem\\\":\\\"Historical Trek\\\",\\\"isSelected\\\":false,\\\"toolTipText\\\":\\\"Arranged into 365 daily readings, this chronological setting will help you experience Bible events in the order they actually occurred.\\\",\\\"keyword\\\":\\\"Chrono\\\"}]},{\\\"title\\\":\\\"Would you like a Bible that you can color or journal in \\\",\\\"keyword\\\":\\\"Journaling & Coloring\\\",\\\"answerType\\\":2,\\\"answers\\\":[{\\\"lineItem\\\":\\\"Yes\\\",\\\"isSelected\\\":false,\\\"toolTipText\\\":\\\"\\\",\\\"keyword\\\":\\\"Yes\\\"},{\\\"lineItem\\\":\\\"No\\\",\\\"isSelected\\\":false,\\\"toolTipText\\\":\\\"\\\",\\\"keyword\\\":\\\"No\\\"}]}]}\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvbWV0YWRhdGEvcXVlc3Rpb25zLmpzb24uanMiLCJzb3VyY2VzIjpbXSwibWFwcGluZ3MiOiIiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/metadata/questions.json\n");

/***/ })

/******/ });